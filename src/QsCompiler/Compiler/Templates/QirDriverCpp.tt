<#@ template language="C#" linePragmas="false" #>
<#@ import namespace="Microsoft.Quantum.QsCompiler.BondSchemas.Execution" #>
//------------------------------------------------------------------------------
// This code was generated by a tool.
// <auto-generated />
//------------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <vector>

#include "CLI11.hpp"

#include "QirContext.hpp"
#include "QirRuntime.hpp"
#include "SimFactory.hpp"

using namespace Microsoft::Quantum;
using namespace std;
    
<# if (entryPointOperation.ContainsParameterType(DataType.ArrayType)) { #>

struct InteropArray
{
    int64_t Size;
    void* Data;

    InteropArray(int64_t size, void* data) :
        Size(size),
        Data(data){}
};

template<typename T>
unique_ptr<InteropArray> CreateInteropArray(vector<T>& v)
{
    unique_ptr<InteropArray> array(new InteropArray(v.size(), v.data()));
    return array;
}

template<typename S, typename D>
void TranslateVector(vector<S>& sourceVector, vector<D>& destinationVector, function<D(S&)> translationFunction)
{
    destinationVector.resize(sourceVector.size());
    transform(sourceVector.begin(), sourceVector.end(), destinationVector.begin(), translationFunction);
}
<# } #>
<# if (entryPointOperation.ContainsParameterType(DataType.RangeType) || entryPointOperation.ContainsArrayType(DataType.RangeType)) { #>

using RangeTuple = tuple<int64_t, int64_t, int64_t>;
struct InteropRange
{
    int64_t Start;
    int64_t Step;
    int64_t End;

    InteropRange() :
        Start(0),
        Step(0),
        End(0){}

    InteropRange(RangeTuple rangeTuple) :
        Start(get<0>(rangeTuple)),
        Step(get<1>(rangeTuple)),
        End(get<2>(rangeTuple)){}
};

unique_ptr<InteropRange> CreateInteropRange(RangeTuple rangeTuple)
{
    unique_ptr<InteropRange> range(new InteropRange(rangeTuple));
    return range;
}

InteropRange* TranslateRangeTupleToInteropRangePointer(RangeTuple& rangeTuple)
{
    InteropRange* range = new InteropRange(rangeTuple);
    return range;
}
<# } #>
<# if (entryPointOperation.ContainsArrayType(DataType.RangeType)) { #>

template<typename T>
void FreePointerVector(vector<T*>& v)
{
    for (auto p : v)
    {
        delete p;
    }
}
<# } #>

// This is the function corresponding to the QIR entry-point.
extern "C" void <#= entryPointOperation.Name #>( // NOLINT
<# for (int i = 0; i < entryPointOperation.Parameters.Count; i++) {
    var param = entryPointOperation.Parameters[i];
    Write($"    {param.CppType()} {param.InteropVariableName()}");
    if (i < entryPointOperation.Parameters.Count-1) {
        WriteLine(",");
    }
} #>

);

<# if (entryPointOperation.ContainsParameterType(DataType.BoolType) || entryPointOperation.ContainsArrayType(DataType.BoolType)) { #>

const char InteropFalseAsChar = 0x0;
const char InteropTrueAsChar = 0x1;
map<string, bool> <#= ParameterCppExtensions.DataTypeTransformerMapName(DataType.BoolType) #>{
    {"0", InteropFalseAsChar},
    {"false", InteropFalseAsChar},
    {"1", InteropTrueAsChar},
    {"true", InteropTrueAsChar}};
<# } #>
<# if (entryPointOperation.ContainsParameterType(DataType.PauliType) || entryPointOperation.ContainsArrayType(DataType.PauliType)) { #>

map<string, PauliId> <#= ParameterCppExtensions.DataTypeTransformerMapName(DataType.PauliType) #>{
    {"PauliI", PauliId::PauliId_I},
    {"PauliX", PauliId::PauliId_X},
    {"PauliY", PauliId::PauliId_Y},
    {"PauliZ", PauliId::PauliId_Z}};


char TranslatePauliToChar(PauliId& pauli)
{
    return static_cast<char>(pauli);
}
<# } #>
<# if (entryPointOperation.ContainsParameterType(DataType.ResultType) || entryPointOperation.ContainsArrayType(DataType.ResultType)) { #>

const char InteropResultZeroAsChar = 0x0;
const char InteropResultOneAsChar = 0x1;
map<string, char> <#= ParameterCppExtensions.DataTypeTransformerMapName(DataType.ResultType) #>{
    {"0", InteropResultZeroAsChar},
    {"Zero", InteropResultZeroAsChar},
    {"1", InteropResultOneAsChar},
    {"One", InteropResultOneAsChar}
};
<# } #>

<# if (entryPointOperation.ContainsParameterType(DataType.StringType) || entryPointOperation.ContainsArrayType(DataType.StringType)) { #>

const char* TranslateStringToCharBuffer(string& s)
{
    return s.c_str();
}
<# } #>
int main(int argc, char* argv[])
{
    CLI::App app("QIR Standalone Entry Point Inputs Reference");

    // Initialize simulator.
    unique_ptr<IRuntimeDriver> sim = CreateFullstateSimulator();
    QirContextScope qirctx(sim.get(), false /*trackAllocatedObjects*/);

    // Add the --simulation-output options.
    // N.B. This option should be present in all standalone drivers.
    string simulationOutputFile;
    CLI::Option* simulationOutputFileOpt = app.add_option(
        "--simulation-output", simulationOutputFile,
        "File where the output produced during the simulation is written");
<# foreach (var param in entryPointOperation.Parameters) {
    WriteLine("");
    WriteLine($"    {param.CppCliValueType()} {param.CliValueVariableName()};"); 
    if (param.CppCliVariableInitialValue() != null) {
        WriteLine($"    {param.CliValueVariableName()} = {param.CppCliVariableInitialValue()};");
    }
    Write($"    app.add_option(\"{param.CliOptionString()}\", {param.CliValueVariableName()}, \"{param.CliDescription()}\")->required()");
    if (param.TransformerMapName() != null) {
    WriteLine("");
        Write($"        ->transform(CLI::CheckedTransformer({param.TransformerMapName()}, CLI::ignore_case))");
    }
    WriteLine(";");
    
} #>

    // With all the options added, parse arguments from the command line.
    CLI11_PARSE(app, argc, argv);

<# foreach (var param in entryPointOperation.Parameters) {
    switch (param.Type) {
        case DataType.PauliType:
            WriteLine("    // Translate a PauliID value to its char representation.");
            WriteLine($"    char {param.InteropVariableName()} = TranslatePauliToChar({param.CliValueVariableName()});");
            break;
        case DataType.RangeType:
            WriteLine("    // Create an interop range.");
            WriteLine($"    unique_ptr<InteropRange> {param.InteropVariableName()} = CreateInteropRange({param.CliValueVariableName()});");
            break;
        case DataType.ArrayType:
            switch (param.ArrayType) {
                case DataType.IntegerType:
                case DataType.DoubleType:
                case DataType.BoolType:
                case DataType.ResultType:
                    WriteLine("    // Translate values to its final form after parsing.");
                    WriteLine("    // Create an interop array of values.");
                    WriteLine($"    unique_ptr<InteropArray> {param.InteropVariableName()} = CreateInteropArray({param.CliValueVariableName()});");
                    break;
                case DataType.PauliType:
                    WriteLine("    // Create an interop array of Pauli values represented as chars.");
                    WriteLine($"    vector<char> {param.IntermediateVariableName()};");
                    WriteLine($"    TranslateVector<PauliId, char>({param.CliValueVariableName()}, {param.IntermediateVariableName()}, TranslatePauliToChar);");
                    WriteLine($"    unique_ptr<InteropArray> {param.InteropVariableName()} = CreateInteropArray({param.IntermediateVariableName()});");
                    break;
                case DataType.RangeType:
                    WriteLine($"    vector<InteropRange*> {param.IntermediateVariableName()};");
                    WriteLine($"    TranslateVector<RangeTuple, InteropRange*>({param.CliValueVariableName()}, {param.IntermediateVariableName()}, TranslateRangeTupleToInteropRangePointer);");
                    WriteLine($"    unique_ptr<InteropArray> {param.InteropVariableName()} = CreateInteropArray({param.IntermediateVariableName()});");
                    break;
                case DataType.StringType:
                    WriteLine("    // Create an interop array of String values.");
                    WriteLine($"    vector<const char *> {param.IntermediateVariableName()};");
                    WriteLine($"    TranslateVector<string, const char*>({param.CliValueVariableName()}, {param.IntermediateVariableName()}, TranslateStringToCharBuffer);");
                    WriteLine($"    unique_ptr<InteropArray> {param.InteropVariableName()} = CreateInteropArray({param.IntermediateVariableName()});");
                    break;
            }
            break;
        default:
            WriteLine($"    {param.CppCliValueType()} {param.InteropVariableName()} = {param.CliValueVariableName()};");
            break;
    }
    WriteLine("");
} #>
    // Redirect the simulator output from std::cout if the --simulation-output option is present.
    ostream* simulatorOutputStream = &cout;
    ofstream simulationOutputFileStream;
    if (!simulationOutputFileOpt->empty())
    {
        simulationOutputFileStream.open(simulationOutputFile);
        SetOutputStream(simulationOutputFileStream);
        simulatorOutputStream = &simulationOutputFileStream;
    }

    // Run simulation and write the output of the operation to the corresponding stream.
    <#= entryPointOperation.Name #>(
<# for (int i = 0; i < entryPointOperation.Parameters.Count; i++) {
    var param = entryPointOperation.Parameters[i];
    switch (param.Type) {
        case DataType.StringType:
            Write($"        {param.InteropVariableName()}.c_str()");
            break;
        case DataType.ArrayType:
        case DataType.RangeType:
            Write($"        {param.InteropVariableName()}.get()");
            break;
        default:
            Write($"        {param.InteropVariableName()}");
            break;
    }
    if (i < entryPointOperation.Parameters.Count-1 ) {
        WriteLine(",");
    }
} #>

    );

<# foreach (var param in entryPointOperation.Parameters) {
    if (param.Type == DataType.ArrayType && param.Type == DataType.RangeType) {
        Write($"    FreePointerVector({param.IntermediateVariableName()});");
    }
} #>

    simulatorOutputStream->flush();
    if (simulationOutputFileStream.is_open())
    {
        simulationOutputFileStream.close();
    }
}
