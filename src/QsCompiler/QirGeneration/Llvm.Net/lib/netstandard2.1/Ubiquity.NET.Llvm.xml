<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Ubiquity.NET.Llvm</name>
    </assembly>
    <members>
        <member name="T:Ubiquity.NET.Llvm.ModuleFlagBehavior">
            <summary>Enumeration to indicate the behavior of module level flags metadata sharing the same name in a <see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/></summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ModuleFlagBehavior.Invalid">
            <summary>Invalid value (default value for this enumeration)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ModuleFlagBehavior.Error">
            <summary>Emits an error if two values disagree, otherwise the resulting value is that of the operands</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ModuleFlagBehavior.Warning">
            <summary>Emits a warning if two values disagree. The result will be the operand for the flag from the first module being linked</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ModuleFlagBehavior.Require">
            <summary>Adds a requirement that another module flag be present and have a specified value after linking is performed</summary>
            <remarks>
            The value must be a metadata pair, where the first element of the pair is the ID of the module flag to be restricted, and the
            second element of the pair is the value the module flag should be restricted to. This behavior can be used to restrict the
            allowable results (via triggering of an error) of linking IDs with the <see cref="F:Ubiquity.NET.Llvm.ModuleFlagBehavior.Override"/> behavior
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ModuleFlagBehavior.Override">
            <summary>Uses the specified value, regardless of the behavior or value of the other module</summary>
            <remarks>If both modules specify Override, but the values differ, and error will be emitted</remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ModuleFlagBehavior.Append">
            <summary>Appends the two values, which are required to be metadata nodes</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ModuleFlagBehavior.AppendUnique">
            <summary>Appends the two values, which are required to be metadata nodes dropping duplicate entries in the second list</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.BitcodeModule">
            <summary>LLVM Bit-code module</summary>
            <remarks>
            A module is the basic unit for containing code in LLVM. Modules are an in memory
            representation of the LLVM Intermediate Representation (IR) bit-code. Each
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.IsDisposed">
            <summary>Gets a value indicating whether the module is disposed or not</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.SourceFileName">
            <summary>Gets or sets the name of the source file generating this module</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.BitcodeModule.DebugVersionValue">
            <summary>Name of the Debug Version information module flag</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.BitcodeModule.DwarfVersionValue">
            <summary>Name of the Dwarf Version module flag</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.BitcodeModule.DebugMetadataVersion">
            <summary>Version of the Debug information Metadata</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.Comdats">
            <summary>Gets the Comdats for this module</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.Context">
            <summary>Gets the <see cref="P:Ubiquity.NET.Llvm.BitcodeModule.Context"/> this module belongs to</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.ModuleFlags">
            <summary>Gets the Metadata for module level flags</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.DIBuilder">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/> used to create debug information for this module</summary>
            <remarks>The builder returned from this property is lazy constructed on first access so doesn't consume resources unless used.</remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.DICompileUnit">
            <summary>Gets the Debug Compile unit for this module</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.DataLayoutString">
            <summary>Gets the Data layout string for this module</summary>
            <remarks>
            <note type="note">The data layout string doesn't do what seems obvious.
            That is, it doesn't force the target back-end to generate code
            or types with a particular layout. Rather, the layout string has
            to match the implicit layout of the target. Thus it should only
            come from the actual <see cref="T:Ubiquity.NET.Llvm.TargetMachine"/> the code is
            targeting.</note>
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.Layout">
            <summary>Gets or sets the target data layout for this module</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.TargetTriple">
            <summary>Gets or sets the Target Triple describing the target, ABI and OS</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.Globals">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.Values.GlobalVariable"/>s contained by this module</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.Functions">
            <summary>Gets the functions contained in this module</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.Aliases">
            <summary>Gets the global aliases in this module</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.NamedMetadata">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.NamedMDNode"/>s for this module</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.IndirectFunctions">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.Values.GlobalIFunc"/>s in this module</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.Name">
            <summary>Gets the name of the module</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.BitcodeModule.ModuleInlineAsm">
            <summary>Gets or sets the module level inline assembly</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.AppendInlineAsm(System.String)">
            <summary>Appends inline assembly to the module's inline assembly</summary>
            <param name="asm">assembly text</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.Dispose">
            <summary>Disposes the <see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/>, releasing resources associated with the module in native code</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.Link(Ubiquity.NET.Llvm.BitcodeModule)">
            <summary>Link another module into this one</summary>
            <param name="otherModule">module to link into this one</param>
            <remarks>
            <note type="warning">
            <paramref name="otherModule"/> is destroyed by this process and no longer usable
            when this method returns.
            </note>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.Verify(System.String@)">
            <summary>Verifies a bit-code module</summary>
            <param name="errorMessage">Error messages describing any issues found in the bit-code</param>
            <returns>true if the verification succeeded and false if not.</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.GetFunction(System.String)">
            <summary>Gets a function by name from this module</summary>
            <param name="name">Name of the function to get</param>
            <returns>The function or null if not found</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.TryGetFunction(System.String,Ubiquity.NET.Llvm.Values.IrFunction@)">
            <summary>Looks up a function in the module by name</summary>
            <param name="name">Name of the function</param>
            <param name="function">The function or <see langword="null"/> if not found</param>
            <returns><see langword="true"/> if the function was found or <see langword="false"/> if not</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.CreateAndAddGlobalIFunc(System.String,Ubiquity.NET.Llvm.Types.ITypeRef,System.UInt32,Ubiquity.NET.Llvm.Values.IrFunction)">
            <summary>Create and add a global indirect function</summary>
            <param name="name">Name of the function</param>
            <param name="type">Signature of the function</param>
            <param name="addressSpace">Address space for the indirect function</param>
            <param name="resolver">Resolver for the indirect function</param>
            <returns>New <see cref="T:Ubiquity.NET.Llvm.Values.GlobalIFunc"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.TryGetNamedGlobalIFunc(System.String,Ubiquity.NET.Llvm.Values.GlobalIFunc@)">
            <summary>Get a named Global Indirect function in the module</summary>
            <param name="name">Name of the ifunc to find</param>
            <param name="function">Function or <see langword="null"/> if not found</param>
            <returns><see langword="true"/> if the function was found or <see langword="false"/> if not</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.AddFunction(System.String,Ubiquity.NET.Llvm.Types.IFunctionType)">
            <summary>Add a function with the specified signature to the module</summary>
            <param name="name">Name of the function to add</param>
            <param name="signature">Signature of the function</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.IrFunction"/>matching the specified signature and name</returns>
            <remarks>
            If a matching function already exists it is returned, and therefore the returned
            <see cref="T:Ubiquity.NET.Llvm.Values.IrFunction"/> may have a body and additional attributes. If a function of
            the same name exists with a different signature an exception is thrown as LLVM does
            not perform any function overloading.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.CreateFunction(System.String,Ubiquity.NET.Llvm.Types.IFunctionType)">
            <summary>Gets an existing function with the specified signature to the module or creates a new one if it doesn't exist</summary>
            <param name="name">Name of the function to add</param>
            <param name="signature">Signature of the function</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.IrFunction"/>matching the specified signature and name</returns>
            <remarks>
            If a matching function already exists it is returned, and therefore the returned
            <see cref="T:Ubiquity.NET.Llvm.Values.IrFunction"/> may have a body and additional attributes. If a function of
            the same name exists with a different signature an exception is thrown as LLVM does
            not perform any function overloading.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.WriteToFile(System.String)">
            <summary>Writes a bit-code module to a file</summary>
            <param name="path">Path to write the bit-code into</param>
            <remarks>
            This is a blind write. (e.g. no verification is performed)
            So if an invalid module is saved it might not work with any
            later stage processing tools.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.WriteToTextFile(System.String,System.String@)">
            <summary>Writes this module as LLVM IR source to a file</summary>
            <param name="path">File to write the LLVM IR source to</param>
            <param name="errMsg">Error messages encountered, if any</param>
            <returns><see langword="true"/> if successful or <see langword="false"/> if not</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.WriteToString">
            <summary>Creates a string representation of the module</summary>
            <returns>LLVM textual representation of the module</returns>
            <remarks>
            This is intentionally NOT an override of ToString() as that is
            used by debuggers to show the value of a type and this can take
            an extremely long time (up to many seconds depending on complexity
            of the module) which is bad for the debugger.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.WriteToBuffer">
            <summary>Writes the LLVM IR bit code into a memory buffer</summary>
            <returns><see cref="T:Ubiquity.NET.Llvm.MemoryBuffer"/> containing the bit code module</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.AddAlias(Ubiquity.NET.Llvm.Values.Value,System.String)">
            <summary>Add an alias to the module</summary>
            <param name="aliasee">Value being aliased</param>
            <param name="aliasName">Name of the alias</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.GlobalAlias"/> for the alias</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.GetAlias(System.String)">
            <summary>Get an alias by name</summary>
            <param name="name">name of the alias to get</param>
            <returns>Alias matching <paramref name="name"/> or null if no such alias exists</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.AddGlobalInAddressSpace(System.UInt32,Ubiquity.NET.Llvm.Types.ITypeRef,System.String)">
            <summary>Adds a global to this module with a specific address space</summary>
            <param name="addressSpace">Address space to add the global to</param>
            <param name="typeRef">Type of the value</param>
            <param name="name">Name of the global</param>
            <returns>The new <see cref="T:Ubiquity.NET.Llvm.Values.GlobalVariable"/></returns>
            <openissues>
            - What does LLVM do if creating a second Global with the same name (return null, throw, crash??,...)
            </openissues>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.AddGlobalInAddressSpace(System.UInt32,Ubiquity.NET.Llvm.Types.ITypeRef,System.Boolean,Ubiquity.NET.Llvm.Values.Linkage,Ubiquity.NET.Llvm.Values.Constant)">
            <summary>Adds a global to this module</summary>
            <param name="addressSpace">Address space to add the global to</param>
            <param name="typeRef">Type of the value</param>
            <param name="isConst">Flag to indicate if this global is a constant</param>
            <param name="linkage">Linkage type for this global</param>
            <param name="constVal">Initial value for the global</param>
            <returns>New global variable</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.AddGlobalInAddressSpace(System.UInt32,Ubiquity.NET.Llvm.Types.ITypeRef,System.Boolean,Ubiquity.NET.Llvm.Values.Linkage,Ubiquity.NET.Llvm.Values.Constant,System.String)">
            <summary>Adds a global to this module</summary>
            <param name="addressSpace">Address space to add the global to</param>
            <param name="typeRef">Type of the value</param>
            <param name="isConst">Flag to indicate if this global is a constant</param>
            <param name="linkage">Linkage type for this global</param>
            <param name="constVal">Initial value for the global</param>
            <param name="name">Name of the variable</param>
            <returns>New global variable</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.AddGlobal(Ubiquity.NET.Llvm.Types.ITypeRef,System.String)">
            <summary>Adds a global to this module</summary>
            <param name="typeRef">Type of the value</param>
            <param name="name">Name of the global</param>
            <returns>The new <see cref="T:Ubiquity.NET.Llvm.Values.GlobalVariable"/></returns>
            <openissues>
            - What does LLVM do if creating a second Global with the same name (return null, throw, crash??,...)
            </openissues>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.AddGlobal(Ubiquity.NET.Llvm.Types.ITypeRef,System.Boolean,Ubiquity.NET.Llvm.Values.Linkage,Ubiquity.NET.Llvm.Values.Constant)">
            <summary>Adds a global to this module</summary>
            <param name="typeRef">Type of the value</param>
            <param name="isConst">Flag to indicate if this global is a constant</param>
            <param name="linkage">Linkage type for this global</param>
            <param name="constVal">Initial value for the global</param>
            <returns>New global variable</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.AddGlobal(Ubiquity.NET.Llvm.Types.ITypeRef,System.Boolean,Ubiquity.NET.Llvm.Values.Linkage,Ubiquity.NET.Llvm.Values.Constant,System.String)">
            <summary>Adds a global to this module</summary>
            <param name="typeRef">Type of the value</param>
            <param name="isConst">Flag to indicate if this global is a constant</param>
            <param name="linkage">Linkage type for this global</param>
            <param name="constVal">Initial value for the global</param>
            <param name="name">Name of the variable</param>
            <returns>New global variable</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.GetTypeByName(System.String)">
            <summary>Retrieves a <see cref="T:Ubiquity.NET.Llvm.Types.ITypeRef"/> by name from the module</summary>
            <param name="name">Name of the type</param>
            <returns>The type or null if no type with the specified name exists in the module</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.GetNamedGlobal(System.String)">
            <summary>Retrieves a named global from the module</summary>
            <param name="name">Name of the global</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.GlobalVariable"/> or <see langword="null"/> if not found</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.AddModuleFlag(Ubiquity.NET.Llvm.ModuleFlagBehavior,System.String,System.UInt32)">
            <summary>Adds a module flag to the module</summary>
            <param name="behavior">Module flag behavior for this flag</param>
            <param name="name">Name of the flag</param>
            <param name="value">Value of the flag</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.AddModuleFlag(Ubiquity.NET.Llvm.ModuleFlagBehavior,System.String,Ubiquity.NET.Llvm.LlvmMetadata)">
            <summary>Adds a module flag to the module</summary>
            <param name="behavior">Module flag behavior for this flag</param>
            <param name="name">Name of the flag</param>
            <param name="value">Value of the flag</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.AddNamedMetadataOperand(System.String,Ubiquity.NET.Llvm.LlvmMetadata)">
            <summary>Adds operand value to named metadata</summary>
            <param name="name">Name of the metadata</param>
            <param name="value">operand value</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.AddVersionIdentMetadata(System.String)">
            <summary>Adds an llvm.ident metadata string to the module</summary>
            <param name="version">version information to place in the llvm.ident metadata</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.CreateFunction(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugFunctionType,System.Boolean,System.Boolean,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.Boolean)">
            <summary>Creates a Function definition with Debug information</summary>
            <param name="scope">Containing scope for the function</param>
            <param name="name">Name of the function in source language form</param>
            <param name="linkageName">Mangled linker visible name of the function (may be same as <paramref name="name"/> if mangling not required by source language</param>
            <param name="file">File containing the function definition</param>
            <param name="line">Line number of the function definition</param>
            <param name="signature">LLVM Function type for the signature of the function</param>
            <param name="isLocalToUnit">Flag to indicate if this function is local to the compilation unit</param>
            <param name="isDefinition">Flag to indicate if this is a definition</param>
            <param name="scopeLine">First line of the function's outermost scope, this may not be the same as the first line of the function definition due to source formatting</param>
            <param name="debugFlags">Additional flags describing this function</param>
            <param name="isOptimized">Flag to indicate if this function is optimized</param>
            <returns>Function described by the arguments</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.CreateFunction(System.String,System.Boolean,Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType},System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType}})">
            <summary>Creates a function</summary>
            <param name="name">Name of the function</param>
            <param name="isVarArg">Flag indicating if the function supports a variadic argument list</param>
            <param name="returnType">Return type of the function</param>
            <param name="argumentTypes">Arguments for the function</param>
            <returns>
            Function, matching the signature specified. This may be a previously declared or defined
            function or a new function if none matching the name and signature is already present.
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.CreateFunction(System.String,System.Boolean,Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType},Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType}[])">
            <summary>Creates a function</summary>
            <param name="name">Name of the function</param>
            <param name="isVarArg">Flag indicating if the function supports a variadic argument list</param>
            <param name="returnType">Return type of the function</param>
            <param name="argumentTypes">Arguments for the function</param>
            <returns>
            Function, matching the signature specified. This may be a previously declared or defined
            function or a new function if none matching the name and signature is already present.
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.GetIntrinsicDeclaration(System.String,Ubiquity.NET.Llvm.Types.ITypeRef[])">
            <summary>Gets a declaration for an LLVM intrinsic function</summary>
            <param name="name">Name of the intrinsic</param>
            <param name="args">Args for the intrinsic</param>
            <returns>Function declaration</returns>
            <remarks>
            This method will match overloaded intrinsics based on the parameter types. If an intrinsic
            has no overloads then an exact match is required. If the intrinsic has overloads than a prefix
            match is used.
            <note type="important">
            It is important to note that the prefix match requires the name provided to have a length greater
            than that of the name of the intrinsic and that the name starts with a matching overloaded intrinsic.
            for example: 'llvm.memset' would not match the overloaded memset intrinsic but 'llvm.memset.p.i' does.
            Thus, it is generally a good idea to use the signature from the LLVM documentation without the address
            space, or bit widths. That is instead of 'llvm.memset.p0i8.i32' use 'llvm.memset.p.i'.
            </note>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.GetIntrinsicDeclaration(System.UInt32,Ubiquity.NET.Llvm.Types.ITypeRef[])">
            <summary>Gets a declaration for an LLVM intrinsic function</summary>
            <param name="id">id of the intrinsic</param>
            <param name="args">Arguments for the intrinsic</param>
            <returns>Function declaration</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.Clone">
            <summary>Clones the current module</summary>
            <returns>Cloned module</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.Clone(Ubiquity.NET.Llvm.Context)">
            <summary>Clones the module into a new <see cref="P:Ubiquity.NET.Llvm.BitcodeModule.Context"/></summary>
            <param name="targetContext"><see cref="P:Ubiquity.NET.Llvm.BitcodeModule.Context"/> to clone the module into</param>
            <returns>Cloned copy of the module</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.Ubiquity#NET#Llvm#IExtensiblePropertyContainer#TryGetExtendedPropertyValue``1(System.String,``0@)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.Ubiquity#NET#Llvm#IExtensiblePropertyContainer#AddExtendedPropertyValue(System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.LoadFrom(System.String,Ubiquity.NET.Llvm.Context)">
            <summary>Load a bit-code module from a given file</summary>
            <param name="path">path of the file to load</param>
            <param name="context">Context to use for creating the module</param>
            <returns>Loaded <see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.BitcodeModule.LoadFrom(Ubiquity.NET.Llvm.MemoryBuffer,Ubiquity.NET.Llvm.Context)">
            <summary>Load bit code from a memory buffer</summary>
            <param name="buffer">Buffer to load from</param>
            <param name="context">Context to load the module into</param>
            <returns>Loaded <see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/></returns>
            <remarks>
            This along with <see cref="M:Ubiquity.NET.Llvm.BitcodeModule.WriteToBuffer"/> are useful for "cloning"
            a module from one context to another. This allows creation of multiple
            modules on different threads and contexts and later moving them to a
            single context in order to link them into a single final module for
            optimization.
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ComdatKind">
            <summary>Comdat kind/behavior</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ComdatKind.Any">
            <summary>Linker may choose any COMDAT key, the choice is arbitrary</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ComdatKind.ExactMatch">
            <summary>Linker may choose any COMDAT key but sections must contain the same data</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ComdatKind.Largest">
            <summary>The linker will choose the section containing the targets COMDAT key</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ComdatKind.NoDuplicates">
            <summary>The linker requires that only one section with this COMDAT key exists</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ComdatKind.SameSize">
            <summary>Linker may choose any COMDAT key but sections must contain the same amount of data</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Comdat">
            <summary>Comdat entry for a module</summary>
            <remarks>
            A COMDAT is a named kind pair to ensure that, within a given module there are no two named COMDATs
            with different kinds. Ultimately, Comdat is 'owned' by the module, if the module is disposed the
            Comdats it owns are invalidated. Using a Comdat instance after the module is disposed results in
            an effective NOP.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Comdat.Name">
            <summary>Gets the name of the <see cref="T:Ubiquity.NET.Llvm.Comdat"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Comdat.Kind">
            <summary>Gets or sets the <see cref="T:Ubiquity.NET.Llvm.ComdatKind"/> for this <see cref="T:Ubiquity.NET.Llvm.Comdat"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Comdat.Module">
            <summary>Gets the module the <see cref="T:Ubiquity.NET.Llvm.Comdat"/> belongs to</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Comdat.#ctor(Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.Interop.LLVMComdatRef)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.Comdat"/> class from an LLVM module and reference</summary>
            <param name="module">Owning module for the comdat</param>
            <param name="comdatRef">LLVM-C API handle for the comdat</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Comdat.ComdatHandle">
            <summary>Gets the wrapped <see cref="T:Ubiquity.NET.Llvm.Interop.LLVMComdatRef"/></summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ComdatCollection">
            <summary>Collection of <see cref="T:Ubiquity.NET.Llvm.Comdat"/> entries for a module</summary>
            <remarks>
            This type is used to provide enumeration and manipulation of <see cref="T:Ubiquity.NET.Llvm.Comdat"/>s
            in the module.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ComdatCollection.Item(System.String)">
            <summary>Retrieves <see cref="T:Ubiquity.NET.Llvm.Comdat"/> by its name</summary>
            <param name="key">Name of the <see cref="T:Ubiquity.NET.Llvm.Comdat"/></param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Comdat"/> or <see langword="null"/></returns>
            <exception cref="T:System.ArgumentNullException">Key is null</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Key does not exist in the collection</exception>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ComdatCollection.Count">
            <summary>Gets the number of items in the collection</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ComdatCollection.InsertOrUpdate(System.String,Ubiquity.NET.Llvm.ComdatKind)">
            <summary>Inserts or updates a <see cref="T:Ubiquity.NET.Llvm.Comdat"/> entry</summary>
            <param name="key">Name of the <see cref="T:Ubiquity.NET.Llvm.Comdat"/></param>
            <param name="kind"><see cref="T:Ubiquity.NET.Llvm.ComdatKind"/> for the entry</param>
            <returns>New or updated <see cref="T:Ubiquity.NET.Llvm.Comdat"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ComdatCollection.Clear">
            <summary>Removes all the <see cref="T:Ubiquity.NET.Llvm.Comdat"/> entries from the module</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ComdatCollection.Contains(System.String)">
            <summary>Gets a value that indicates if a <see cref="T:Ubiquity.NET.Llvm.Comdat"/> with a given name exists in the collection</summary>
            <param name="key">Name of the <see cref="T:Ubiquity.NET.Llvm.Comdat"/> to test for</param>
            <returns><see langword="true"/> if the entry is present and <see langword="false"/> if not</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ComdatCollection.GetEnumerator">
            <summary>Gets an enumerator for all the <see cref="T:Ubiquity.NET.Llvm.Comdat"/>s in the collection</summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ComdatCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets an enumerator for all the <see cref="T:Ubiquity.NET.Llvm.Comdat"/>s in the collection</summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ComdatCollection.Remove(System.String)">
            <summary>Removes a <see cref="T:Ubiquity.NET.Llvm.Comdat"/> entry from the module</summary>
            <param name="key">Name of the <see cref="T:Ubiquity.NET.Llvm.Comdat"/></param>
            <returns>
            <see langword="true"/> if the value was in the list or
            <see langword="false"/> otherwise
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ComdatCollection.TryGetValue(System.String,Ubiquity.NET.Llvm.Comdat@)">
            <summary>Gets a value form the collection if it exists</summary>
            <param name="key">Name of the item to retrieve</param>
            <param name="value">Value of the item if found or <see langword="null"/> if not found</param>
            <returns>
            <see langword="true"/> if the value was found
            the list or <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ComdatCollection.#ctor(Ubiquity.NET.Llvm.BitcodeModule)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.ComdatCollection"/> class for a module</summary>
            <param name="module">Module the comdats are enumerated from</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Context">
             <summary>Encapsulates an LLVM context</summary>
             <remarks>
             <para>A context in LLVM is a container for interning (LLVM refers to this as "uniqueing") various types
             and values in the system. This allows running multiple LLVM tool transforms etc.. on different threads
             without causing them to collide namespaces and types even if they use the same name (e.g. module one
             may have a type Foo, and so does module two but they are completely distinct from each other)</para>
            
             <para>LLVM Debug information is ultimately all parented to a top level <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit"/> as
             the scope, and a compilation unit is bound to a <see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/>, even though, technically
             the types are owned by a Context. Thus to keep things simpler and help make working with debug information
             easier. Ubiquity.NET.Llvm encapsulates the native type and the debug type in separate classes that are instances
             of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.IDebugType`2"/> interface </para>
            
             <note type="note">It is important to be aware of the fact that a Context is not thread safe. The context
             itself and the object instances it owns are intended for use by a single thread only. Accessing and
             manipulating LLVM objects from multiple threads may lead to race conditions corrupted state and any number
             of other undefined issues.</note>
             </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.Context"/> class.Creates a new context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.VoidType">
            <summary>Gets the LLVM void type for this context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.BoolType">
            <summary>Gets the LLVM boolean type for this context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.Int8Type">
            <summary>Gets the LLVM 8 bit integer type for this context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.Int16Type">
            <summary>Gets the LLVM 16 bit integer type for this context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.Int32Type">
            <summary>Gets the LLVM 32 bit integer type for this context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.Int64Type">
            <summary>Gets the LLVM 64 bit integer type for this context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.Int128Type">
            <summary>Gets the LLVM 128 bit integer type for this context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.HalfFloatType">
            <summary>Gets the LLVM half precision floating point type for this context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.FloatType">
            <summary>Gets the LLVM single precision floating point type for this context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.DoubleType">
            <summary>Gets the LLVM double precision floating point type for this context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.TokenType">
            <summary>Gets the LLVM token type for this context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.MetadataType">
            <summary>Gets the LLVM Metadata type for this context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.X86Float80Type">
            <summary>Gets the LLVM X86 80-bit floating point type for this context</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.Float128Type">
            <summary>Gets the LLVM 128-Bit floating point type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.PpcFloat128Type">
            <summary>Gets the LLVM PPC 128-bit floating point type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.Metadata">
            <summary>Gets an enumerable collection of all the metadata created in this context</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.GetPointerTypeFor(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Get a type that is a pointer to a value of a given type</summary>
            <param name="elementType">Type of value the pointer points to</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Types.IPointerType"/> for a pointer that references a value of type <paramref name="elementType"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.GetIntType(System.UInt32)">
            <summary>Get's an LLVM integer type of arbitrary bit width</summary>
            <param name="bitWidth">Width of the integer type in bits</param>
            <remarks>
            For standard integer bit widths (e.g. 1,8,16,32,64) this will return
            the same type as the corresponding specialized property.
            (e.g. GetIntType(1) is the same as <see cref="P:Ubiquity.NET.Llvm.Context.BoolType"/>,
             GetIntType(16) is the same as <see cref="P:Ubiquity.NET.Llvm.Context.Int16Type"/>, etc... )
            </remarks>
            <returns>Integer <see cref="T:Ubiquity.NET.Llvm.Types.ITypeRef"/> for the specified width</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.GetFunctionType(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Types.ITypeRef[])">
            <summary>Get an LLVM Function type (e.g. signature)</summary>
            <param name="returnType">Return type of the function</param>
            <param name="args">Optional set of function argument types</param>
            <returns>Signature type for the specified signature</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.GetFunctionType(Ubiquity.NET.Llvm.Types.ITypeRef,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Types.ITypeRef})">
            <summary>Get an LLVM Function type (e.g. signature)</summary>
            <param name="returnType">Return type of the function</param>
            <param name="args">Potentially empty set of function argument types</param>
            <returns>Signature type for the specified signature</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.GetFunctionType(Ubiquity.NET.Llvm.Types.ITypeRef,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Types.ITypeRef},System.Boolean)">
            <summary>Get an LLVM Function type (e.g. signature)</summary>
            <param name="returnType">Return type of the function</param>
            <param name="args">Potentially empty set of function argument types</param>
            <param name="isVarArgs">Flag to indicate if the method supports C/C++ style VarArgs</param>
            <returns>Signature type for the specified signature</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateFunctionType(Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder,Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType},Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType}[])">
            <summary>Creates a FunctionType with Debug information</summary>
            <param name="diBuilder"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/>to use to create the debug information</param>
            <param name="retType">Return type of the function</param>
            <param name="argTypes">Argument types of the function</param>
            <returns>Function signature</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateFunctionType(Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder,Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType},System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType}})">
            <summary>Creates a FunctionType with Debug information</summary>
            <param name="diBuilder"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/>to use to create the debug information</param>
            <param name="retType">Return type of the function</param>
            <param name="argTypes">Argument types of the function</param>
            <returns>Function signature</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateFunctionType(Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder,System.Boolean,Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType},Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType}[])">
            <summary>Creates a FunctionType with Debug information</summary>
            <param name="diBuilder"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/>to use to create the debug information</param>
            <param name="isVarArg">Flag to indicate if this function is variadic</param>
            <param name="retType">Return type of the function</param>
            <param name="argTypes">Argument types of the function</param>
            <returns>Function signature</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateFunctionType(Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder,System.Boolean,Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType},System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType}})">
            <summary>Creates a FunctionType with Debug information</summary>
            <param name="diBuilder"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/>to use to create the debug information</param>
            <param name="isVarArg">Flag to indicate if this function is variadic</param>
            <param name="retType">Return type of the function</param>
            <param name="argTypes">Argument types of the function</param>
            <returns>Function signature</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstantStruct(System.Boolean,Ubiquity.NET.Llvm.Values.Constant[])">
            <summary>Creates a constant structure from a set of values</summary>
            <param name="packed">Flag to indicate if the structure is packed and no alignment should be applied to the members</param>
            <param name="values">Set of values to use in forming the structure</param>
            <returns>Newly created <see cref="T:Ubiquity.NET.Llvm.Values.Constant"/></returns>
            <remarks>
            The actual concrete return type depends on the parameters provided and will be one of the following:
            <list type="table">
            <listheader>
            <term><see cref="T:Ubiquity.NET.Llvm.Values.Constant"/> derived type</term><description>Description</description>
            </listheader>
            <item><term>ConstantAggregateZero</term><description>If all the member values are zero constants</description></item>
            <item><term>UndefValue</term><description>If all the member values are UndefValue</description></item>
            <item><term>ConstantStruct</term><description>All other cases</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstantStruct(System.Boolean,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Constant})">
            <summary>Creates a constant structure from a set of values</summary>
            <param name="packed">Flag to indicate if the structure is packed and no alignment should be applied to the members</param>
            <param name="values">Set of values to use in forming the structure</param>
            <returns>Newly created <see cref="T:Ubiquity.NET.Llvm.Values.Constant"/></returns>
            <remarks>
            <note type="note">The actual concrete return type depends on the parameters provided and will be one of the following:
            <list type="table">
            <listheader>
            <term><see cref="T:Ubiquity.NET.Llvm.Values.Constant"/> derived type</term><description>Description</description>
            </listheader>
            <item><term>ConstantAggregateZero</term><description>If all the member values are zero constants</description></item>
            <item><term>UndefValue</term><description>If all the member values are UndefValue</description></item>
            <item><term>ConstantStruct</term><description>All other cases</description></item>
            </list>
            </note>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateNamedConstantStruct(Ubiquity.NET.Llvm.Types.IStructType,Ubiquity.NET.Llvm.Values.Constant[])">
            <summary>Creates a constant instance of a specified structure type from a set of values</summary>
            <param name="type">Type of the structure to create</param>
            <param name="values">Set of values to use in forming the structure</param>
            <returns>Newly created <see cref="T:Ubiquity.NET.Llvm.Values.Constant"/></returns>
            <remarks>
            <note type="note">The actual concrete return type depends on the parameters provided and will be one of the following:
            <list type="table">
            <listheader>
            <term><see cref="T:Ubiquity.NET.Llvm.Values.Constant"/> derived type</term><description>Description</description>
            </listheader>
            <item><term>ConstantAggregateZero</term><description>If all the member values are zero constants</description></item>
            <item><term>UndefValue</term><description>If all the member values are UndefValue</description></item>
            <item><term>ConstantStruct</term><description>All other cases</description></item>
            </list>
            </note>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateNamedConstantStruct(Ubiquity.NET.Llvm.Types.IStructType,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Constant})">
            <summary>Creates a constant instance of a specified structure type from a set of values</summary>
            <param name="type">Type of the structure to create</param>
            <param name="values">Set of values to use in forming the structure</param>
            <returns>Newly created <see cref="T:Ubiquity.NET.Llvm.Values.Constant"/></returns>
            <remarks>
            <note type="note">The actual concrete return type depends on the parameters provided and will be one of the following:
            <list type="table">
            <listheader>
            <term><see cref="T:Ubiquity.NET.Llvm.Values.Constant"/> derived type</term><description>Description</description>
            </listheader>
            <item><term>ConstantAggregateZero</term><description>If all the member values are zero constants</description></item>
            <item><term>UndefValue</term><description>If all the member values are UndefValue</description></item>
            <item><term>ConstantStruct</term><description>All other cases</description></item>
            </list>
            </note>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateStructType(System.String)">
            <summary>Create an opaque structure type (e.g. a forward reference)</summary>
            <param name="name">Name of the type (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <remarks>
            This method creates an opaque type. The <see cref="M:Ubiquity.NET.Llvm.Types.IStructType.SetBody(System.Boolean,Ubiquity.NET.Llvm.Types.ITypeRef[])"/>
            method provides a means to add a body, including indication of packed status, to an opaque
            type at a later time if the details of the body are required. (If only pointers to the type
            are required then the body isn't required)
            </remarks>
            <returns>New type</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateStructType(System.Boolean,Ubiquity.NET.Llvm.Types.ITypeRef[])">
            <summary>Create an anonymous structure type (e.g. Tuple)</summary>
            <param name="packed">Flag to indicate if the structure is "packed"</param>
            <param name="elements">Types of the fields of the structure</param>
            <returns>
            <see cref="T:Ubiquity.NET.Llvm.Types.IStructType"/> with the specified body defined.
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateStructType(System.String,System.Boolean,Ubiquity.NET.Llvm.Types.ITypeRef[])">
            <summary>Creates a new structure type in this <see cref="T:Ubiquity.NET.Llvm.Context"/></summary>
            <param name="name">Name of the structure</param>
            <param name="packed">Flag indicating if the structure is packed</param>
            <param name="elements">Types for the structures elements in layout order</param>
            <returns>
            <see cref="T:Ubiquity.NET.Llvm.Types.IStructType"/> with the specified body defined.
            </returns>
            <remarks>
            If the elements argument list is empty then a complete 0 sized struct is created
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateStructType(System.String,System.Boolean,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Types.ITypeRef})">
            <summary>Creates a new structure type in this <see cref="T:Ubiquity.NET.Llvm.Context"/></summary>
            <param name="name">Name of the structure (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <param name="packed">Flag indicating if the structure is packed</param>
            <param name="elements">Types for the structures elements in layout order</param>
            <returns>
            <see cref="T:Ubiquity.NET.Llvm.Types.IStructType"/> with the specified body defined.
            </returns>
            <remarks>
            If the elements argument list is empty then a complete 0 sized struct is created
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateMetadataString(System.String)">
            <summary>Creates a metadata string from the given string</summary>
            <param name="value">string to create as metadata</param>
            <returns>new metadata string</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateMDNode(System.String)">
            <summary>Create an <see cref="T:Ubiquity.NET.Llvm.MDNode"/> from a string</summary>
            <param name="value">String value</param>
            <returns>New node with the string as the first element of the <see cref="P:Ubiquity.NET.Llvm.MDNode.Operands"/> property (as an MDString)</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstantString(System.String)">
            <summary>Create a constant data string value</summary>
            <param name="value">string to convert into an LLVM constant value</param>
            <returns>new <see cref="T:Ubiquity.NET.Llvm.Values.ConstantDataArray"/></returns>
            <remarks>
            This converts the string to ANSI form and creates an LLVM constant array of i8
            characters for the data with a terminating null character. To control the enforcement
            of a terminating null character, use the <see cref="M:Ubiquity.NET.Llvm.Context.CreateConstantString(System.String,System.Boolean)"/>
            overload to specify the intended behavior.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstantString(System.String,System.Boolean)">
            <summary>Create a constant data string value</summary>
            <param name="value">string to convert into an LLVM constant value</param>
            <param name="nullTerminate">flag to indicate if the string should include a null terminator</param>
            <returns>new <see cref="T:Ubiquity.NET.Llvm.Values.ConstantDataArray"/></returns>
            <remarks>
            This converts the string to ANSI form and creates an LLVM constant array of i8
            characters for the data. Enforcement of a null terminator depends on the value of <paramref name="nullTerminate"/>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstant(System.Boolean)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> with a bit length of 1</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstant(System.Byte)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> with a bit length of 8</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstant(System.SByte)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> with a bit length of 8</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstant(System.Int16)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> with a bit length of 16</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstant(System.UInt16)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> with a bit length of 16</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstant(System.Int32)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> with a bit length of 32</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstant(System.UInt32)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> with a bit length of 32</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstant(System.Int64)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> with a bit length of 64</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstant(System.UInt64)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> with a bit length of 64</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstant(System.UInt32,System.UInt64,System.Boolean)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> with a bit length of 64</summary>
            <param name="bitWidth">Bit width of the integer</param>
            <param name="constValue">Value for the constant</param>
            <param name="signExtend">flag to indicate if the constant value should be sign extended</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstant(Ubiquity.NET.Llvm.Types.ITypeRef,System.UInt64,System.Boolean)">
            <summary>Create a constant value of the specified integer type</summary>
            <param name="intType">Integer type</param>
            <param name="constValue">value</param>
            <param name="signExtend">flag to indicate if <paramref name="constValue"/> is sign extended</param>
            <returns>Constant for the specified value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstant(System.Single)">
            <summary>Creates a constant floating point value for a given value</summary>
            <param name="constValue">Value to make into a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantFP"/></param>
            <returns>Constant value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateConstant(System.Double)">
            <summary>Creates a constant floating point value for a given value</summary>
            <param name="constValue">Value to make into a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantFP"/></param>
            <returns>Constant value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateAttribute(Ubiquity.NET.Llvm.Values.AttributeKind)">
            <summary>Creates a simple boolean attribute</summary>
            <param name="kind">Kind of attribute</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/> with the specified Kind set</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateAttribute(Ubiquity.NET.Llvm.Values.AttributeKind,System.UInt64)">
            <summary>Creates an attribute with an integer value parameter</summary>
            <param name="kind">The kind of attribute</param>
            <param name="value">Value for the attribute</param>
            <remarks>
            <para>Not all attributes support a value and those that do don't all support
            a full 64bit value. The following table provides the kinds of attributes
            accepting a value and the allowed size of the values.</para>
            <list type="table">
            <listheader><term><see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/></term><term>Bit Length</term></listheader>
            <item><term><see cref="F:Ubiquity.NET.Llvm.Values.AttributeKind.Alignment"/></term><term>32</term></item>
            <item><term><see cref="F:Ubiquity.NET.Llvm.Values.AttributeKind.StackAlignment"/></term><term>32</term></item>
            <item><term><see cref="F:Ubiquity.NET.Llvm.Values.AttributeKind.Dereferenceable"/></term><term>64</term></item>
            <item><term><see cref="F:Ubiquity.NET.Llvm.Values.AttributeKind.DereferenceableOrNull"/></term><term>64</term></item>
            </list>
            </remarks>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/> with the specified kind and value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateAttribute(System.String)">
            <summary>Adds a valueless named attribute</summary>
            <param name="name">Attribute name</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/> with the specified name</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateAttribute(System.String,System.String)">
            <summary>Adds a Target specific named attribute with value</summary>
            <param name="name">Name of the attribute</param>
            <param name="value">Value of the attribute</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/> with the specified name and value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateBasicBlock(System.String)">
            <summary>Create a named <see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> without inserting it into a function</summary>
            <param name="name">Name of the block to create</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> created</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateBitcodeModule">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateBitcodeModule(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.CreateBitcodeModule(System.String,Ubiquity.NET.Llvm.DebugInfo.SourceLanguage,System.String,System.String,System.Boolean,System.String,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.Modules">
            <summary>Gets the modules created in this context</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.GetMDKindId(System.String)">
            <summary>Gets non-zero Metadata kind ID for a given name</summary>
            <param name="name">name of the metadata kind</param>
            <returns>integral constant for the ID</returns>
            <remarks>
            These IDs are uniqued across all modules in this context.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Context.OdrUniqueDebugTypes">
            <summary>Gets or sets a value indicating whether the context keeps a map for uniqueing debug info identifiers across the context</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.OpenBinary(System.String)">
            <summary>Opens a <see cref="T:Ubiquity.NET.Llvm.ObjectFile.TargetBinary"/> from a path</summary>
            <param name="path">path to the object file binary</param>
            <returns>new object file</returns>
            <exception cref="T:System.IO.IOException">File IO failures</exception>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Context.Dispose(System.Boolean)">
            <summary>Disposes the context to release unmanaged resources deterministically</summary>
            <param name="disposing">Indicates whether this is from a call to Dispose (<see langword="true"/>) or if from a finalizer</param>
            <remarks>
            If <paramref name="disposing"/> is <see langword="true"/> then this will release managed and unmanaged resources.
            Otherwise, this will only release the native/unmanaged resources.
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ContextCache">
            <summary>Maintains a global cache of <see cref="T:Ubiquity.NET.Llvm.Interop.LLVMContextRef"/> to <see cref="T:Ubiquity.NET.Llvm.Context"/> mappings</summary>
            <remarks>
            The public constructor <see cref="M:Ubiquity.NET.Llvm.Context.#ctor"/> will add itself to the cache, since it is a new instance
            that is a safe operation. In all other cases a lookup in the cache based on the underlying LLVM handle is
            performed in a thread safe manner.
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ByteOrdering">
            <summary>Byte ordering for target code generation and data type layout</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ByteOrdering.LittleEndian">
            <summary>Little-Endian layout format</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ByteOrdering.BigEndian">
            <summary>Big-Endian layout format</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DataLayout">
             <summary>Provides access to LLVM target data layout information</summary>
             <remarks>
             <para>There is a distinction between various sizes and alignment for a given type
             that are target dependent.</para>
             <para>The following table illustrates the differences in sizes and their meaning
              for a sample set of types.</para>
             |   Type  | SizeInBits | StoreSizeInBits | AbiSizeInBits |
             |---------|------------|-----------------|---------------|
             | i1      | 1          | 8               | 8             |
             | i8      | 8          | 8               | 8             |
             | i19     | 19         | 24              | 32            |
             | i32     | 32         | 32              | 32            |
             | i10     | 100        | 104             | 128           |
             | i128    | 128        | 128             | 128           |
             | Float   | 32         | 32              | 32            |
             | Double  | 64         | 64              | 64            |
             | X86_FP80| 80         | 80              | 96            |
            
             <note type="note">
             The allocation size depends on the alignment, and thus on the target.
             The values in the example table are for x86-32-linux.
             </note>
             |   Property      | Definition |
             |-----------------|------------|
             | SizeInBits      | Minimum number of bits needed to represent the full range of values for the type |
             | StoreSizeInBits | Minimum number of bits needed to actually store a *single* value of the type |
             | AbiSizeInBits   | Total number of bits used to store a value in a sequence, including any alignment padding |
            
             The allocation size determines the total size of each entry in a sequence so that the "next" element is computed
             by adding the size to the start address of the current element.
             </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DataLayout.Endianess">
            <summary>Gets the byte ordering for this target</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.PointerSize">
            <summary>Gets the size of a pointer for the default address space of the target</summary>
            <returns>Size of a pointer to the default address space</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.PointerSize(System.UInt32)">
            <summary>Retrieves the size of a pointer for a given address space of the target</summary>
            <param name="addressSpace">Address space for the pointer</param>
            <returns>Size of a pointer</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.IntPtrType(Ubiquity.NET.Llvm.Context)">
            <summary>Retrieves an LLVM integer type with the same bit width as a pointer for the default address space of the target</summary>
            <param name="context">LLVM <see cref="T:Ubiquity.NET.Llvm.Context"/> that owns the definition of the pointer type to retrieve</param>
            <returns>Integer type matching the bit width of a native pointer in the target's default address space</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.IntPtrType(Ubiquity.NET.Llvm.Context,System.UInt32)">
            <summary>Retrieves an LLVM integer type with the same bit width as
            a pointer for the given address space of the target</summary>
            <param name="context">LLVM <see cref="T:Ubiquity.NET.Llvm.Context"/> that owns the definition of the pointer type to retrieve</param>
            <param name="addressSpace">Address space for the pointer</param>
            <returns>Integer type matching the bit width of a native pointer in the target's address space</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.BitSizeOf(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Returns the number of bits necessary to hold the specified type.</summary>
            <param name="typeRef">Type to retrieve the size of</param>
            <remarks>
            <para>This method determines the bit size of a type (e.g. the minimum number of
            bits required to represent any value of the given type.) This is distinct from the storage
            and stack size due to various target alignment requirements.</para>
            </remarks>
            <returns>Size of the type in bits</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.StoreSizeOf(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Retrieves the number of bits required to store a value of the given type</summary>
            <param name="typeRef">Type to retrieve the storage size of</param>
            <returns>Number of bits required to store a value of the given type in the target</returns>
            <remarks>This method retrieves the storage size in bits of a given type. The storage size
            includes any trailing padding bits that may be needed if the target requires reading a wider
            word size. (e.g. most systems can't write a single bit value for an LLVM i1, thus the
            storage size is whatever the minimum number of bits that the target requires to store a value
            of the given type)
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.AbiSizeOf(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Retrieves the ABI specified size of the given type</summary>
            <param name="typeRef">Type to get the size from</param>
            <returns>Size of the type</returns>
            <remarks>
            Returns the offset in bytes between successive objects of the
            specified type, including alignment padding
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.AbiAlignmentOf(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Retrieves the ABI specified alignment, in bytes, for a specified type</summary>
            <param name="typeRef">Type to get the alignment for</param>
            <returns>ABI specified alignment</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.CallFrameAlignmentOf(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Retrieves the call frame alignment for a given type</summary>
            <param name="typeRef">type to get the alignment of</param>
            <returns>Alignment for the type</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.PreferredAlignmentOf(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Gets the preferred alignment for an LLVM type</summary>
            <param name="typeRef">Type to get the alignment of</param>
            <returns>Preferred alignment</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.PreferredAlignmentOf(Ubiquity.NET.Llvm.Values.Value)">
            <summary>Gets the preferred alignment for a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></summary>
            <param name="value">Value to get the alignment of</param>
            <returns>Preferred alignment</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.ElementAtOffset(Ubiquity.NET.Llvm.Types.IStructType,System.UInt64)">
            <summary>Gets the element index for a specific offset in a given structure</summary>
            <param name="structType">Type of the structure</param>
            <param name="offset">Offset to determine the index of</param>
            <returns>Index of the element</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.OffsetOfElement(Ubiquity.NET.Llvm.Types.IStructType,System.UInt32)">
            <summary>Gets the offset of an element in a structure</summary>
            <param name="structType">Type of the structure</param>
            <param name="element">index of the element in the structure</param>
            <returns>Offset of the element from the beginning of the structure</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.ToString">
            <summary>Converts the layout to a string representation of the layout data</summary>
            <returns>Data layout as a string</returns>
            <seealso href="xref:llvm_langref#data-layout">DICompositeType</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.ByteSizeOf(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Gets the byte size of a type</summary>
            <param name="llvmType">Type to determine the size of</param>
            <returns>Size of the type in bytes</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.PreferredBitAlignmentOf(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Gets the preferred alignment of the type in bits</summary>
            <param name="llvmType">Type to get the alignment of</param>
            <returns>Alignment of the type</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.AbiBitAlignmentOf(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Gets the ABI alignment of the type in bits</summary>
            <param name="llvmType">Type to get the alignment of</param>
            <returns>Alignment of the type</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DataLayout.BitOffsetOfElement(Ubiquity.NET.Llvm.Types.IStructType,System.UInt32)">
            <summary>Gets the offset of a structure element in bits</summary>
            <param name="llvmType">Structure type to get the element offset of</param>
            <param name="element">Index of the element in the structure</param>
            <returns>Offset of the element in bits</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType">
            <summary>Provides debug information binding between an <see cref="T:Ubiquity.NET.Llvm.Types.IArrayType"/> and a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/></summary>
            <seealso href="xref:llvm_langref#dicompositetype">DICompositeType</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType.#ctor(Ubiquity.NET.Llvm.Types.IArrayType,Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType},Ubiquity.NET.Llvm.BitcodeModule,System.UInt32,System.UInt32,System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType"/> class</summary>
            <param name="llvmType">Underlying LLVM array type to bind debug info to</param>
            <param name="elementType">Array element type with debug information</param>
            <param name="module">module to use for creating debug information</param>
            <param name="count">Number of elements in the array</param>
            <param name="lowerBound">Lower bound of the array [default = 0]</param>
            <param name="alignment">Alignment for the type</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType.#ctor(Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType},Ubiquity.NET.Llvm.BitcodeModule,System.UInt32,System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType"/> class.</summary>
            <param name="elementType">Type of elements in the array</param>
            <param name="module"><see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/> to use for the context of the debug information</param>
            <param name="count">Number of elements in the array</param>
            <param name="lowerBound"><see cref="P:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType.LowerBound"/> value for the array indices [Default: 0]</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType.#ctor(Ubiquity.NET.Llvm.Types.IArrayType,Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.DebugInfo.DIType,System.UInt32,System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType"/> class.</summary>
            <param name="llvmType">Native LLVM type for the elements</param>
            <param name="module"><see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/> to use for the context of the debug information</param>
            <param name="elementType">Debug type of the array elements</param>
            <param name="count">Number of elements in the array</param>
            <param name="lowerBound"><see cref="P:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType.LowerBound"/> value for the array indices [Default: 0]</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType.DebugElementType">
            <summary>Gets the full <see cref="T:Ubiquity.NET.Llvm.DebugInfo.IDebugType`2"/> type for the elements</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType.ElementType">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType.Length">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType.LowerBound">
            <summary>Gets the lower bound of the array - usually, but not always, zero</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType.ResolveTemporary(Ubiquity.NET.Llvm.DataLayout,Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder)">
            <summary>Resolves a temporary metadata node for the array if full size information wasn't available at creation time</summary>
            <param name="layout">Type layout information</param>
            <param name="diBuilder">Debug information builder for creating the new debug information</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DebugBasicType">
            <summary>Debug information binding between an LLVM native <see cref="T:Ubiquity.NET.Llvm.Types.ITypeRef"/> and a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIBasicType"/></summary>
            <remarks>
            This class provides a binding between an LLVM type and a corresponding <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIBasicType"/>.
            In LLVM all primitive types are unnamed and interned. That is, any use of an i8 is always the same
            type. However, at the source language level it is common to have named primitive types that map
            to the same underlying LLVM. For example, in C and C++ char maps to i8 but so does unsigned char
            (LLVM integral types don't have signed vs unsigned). This class is designed to handle this sort
            of one to many mapping of the lower level LLVM types to source level debugging types. Each
            instance of this class represents a source level basic type and the corresponding representation
            for LLVM.
            </remarks>
            <seealso href="xref:llvm_langref#dibasictype">LLVM DIBasicType</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugBasicType.#ctor(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.BitcodeModule,System.String,Ubiquity.NET.Llvm.DebugInfo.DiTypeKind)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugBasicType"/> class.</summary>
            <param name="llvmType">Type to wrap debug information for</param>
            <param name="module">Module to use when constructing the debug information</param>
            <param name="name">Source language name of the type</param>
            <param name="encoding">Encoding for the type</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DebugFunctionType">
            <summary>This class provides debug information binding for an <see cref="T:Ubiquity.NET.Llvm.Types.IFunctionType"/>
            and a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubroutineType"/>
            </summary>
            <remarks>
            <para>Function signatures are unnamed interned types in LLVM. While there is usually a one
            to one mapping between an LLVM function signature type and the source language debug
            signature type - that isn't always true. In particular, when passing data by value. In
            cases where the address of a by value structure is needed, a common pattern is to use
            a pointer to the structure in the signature, then perform an Alloca + memcpy. The
            actual approach taken depends on the calling conventions of the target. In these cases
            you get an LLVM signature that doesn't match the source and could actually match another
            source function where a pointer to the structure is actually used in the source.</para>
            <para>For example, the following two C language functions might use the same LLVM signature:
            <code>void foo(struct bar)</code>
            <code>void foo2(struct bar*)</code>
            Implementing both of those might be done in LLVM with a single signature:
            <code>void (%struct.bar*)</code></para>
            <para>This class is designed to provide mapping between the debug signature type
            and the underlying LLVM type</para>
            <note type="note">It is important to keep in mind that signatures are only concerned
            with types. That is, they do not include names of parameters. Parameter information is
            provided by <see cref="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateArgument(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DIType,System.Boolean,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.UInt16)"/>
            and [DebugInfoBuilder.InsertDeclare](xref:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.InsertDeclare*)</note>
            </remarks>
            <seealso href="xref:llvm_langref#disubroutinetype">LLVM DISubroutineType</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugFunctionType.#ctor(Ubiquity.NET.Llvm.Types.IFunctionType,Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType},Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType}[])">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugFunctionType"/> class.</summary>
            <param name="llvmType">Native LLVM function signature</param>
            <param name="module"><see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/> to use when construction debug information</param>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for this signature</param>
            <param name="retType">Return type for the function</param>
            <param name="argTypes">Potentially empty set of argument types for the signature</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugFunctionType.IsVarArg">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugFunctionType.ReturnType">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugFunctionType.ParameterTypes">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugFunctionType.#ctor(Ubiquity.NET.Llvm.Types.IFunctionType,Ubiquity.NET.Llvm.DebugInfo.DISubroutineType)">
            <summary>
            Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugFunctionType"/> class from an LLVM type and <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubroutineType"/></summary>
            <param name="rawType">Raw native type</param>
            <param name="sub">Debug information to bind with the native type</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DwarfEmissionKind">
            <summary>Defines the amount of debug information to emit</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DebugInfo.DwarfEmissionKind.None">
            <summary>No debug information</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DebugInfo.DwarfEmissionKind.Full">
            <summary>Full Debug information</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DebugInfo.DwarfEmissionKind.LineTablesOnly">
            <summary>Emit line tables only</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.MacroKind">
            <summary>Describes the kind of macro declaration</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DebugInfo.MacroKind.Define">
            <summary>Macro definition</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DebugInfo.MacroKind.Undefine">
            <summary>Undefine a macro</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder">
            <summary>DebugInfoBuilder is a factory class for creating DebugInformation for an LLVM <see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/></summary>
            <remarks>
            Many Debug information metadata nodes are created with unresolved references to additional
            metadata. To ensure such metadata is resolved applications should call the <see cref="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.Finish"/>
            method to resolve and finalize the metadata. After this point only fully resolved nodes may
            be added to ensure that the data remains valid.
            </remarks>
            <seealso href="xref:llvm_sourceleveldebugging">LLVM Source Level Debugging</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.OwningModule">
            <summary>Gets the module that owns this builder</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateCompileUnit(Ubiquity.NET.Llvm.DebugInfo.SourceLanguage,System.String,System.String,System.Boolean,System.String,System.UInt32)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit"/></summary>
            <param name="language"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.SourceLanguage"/> for the compilation unit</param>
            <param name="sourceFilePath">Full path to the source file of this compilation unit</param>
            <param name="producer">Name of the application processing the compilation unit</param>
            <param name="optimized">Flag to indicate if the code in this compilation unit is optimized</param>
            <param name="compilationFlags">Additional tool specific flags</param>
            <param name="runtimeVersion">Runtime version</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateCompileUnit(Ubiquity.NET.Llvm.DebugInfo.SourceLanguage,System.String,System.String,System.String,System.Boolean,System.String,System.UInt32)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit"/></summary>
            <param name="language"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.SourceLanguage"/> for the compilation unit</param>
            <param name="fileName">Name of the source file of this compilation unit (without any path)</param>
            <param name="fileDirectory">Path of the directory containing the file</param>
            <param name="producer">Name of the application processing the compilation unit</param>
            <param name="optimized">Flag to indicate if the code in this compilation unit is optimized</param>
            <param name="compilationFlags">Additional tool specific flags</param>
            <param name="runtimeVersion">Runtime version</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateTempMacroFile(Ubiquity.NET.Llvm.DebugInfo.DIMacroFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DIFile)">
            <summary>Creates a debugging information temporary entry for a macro file</summary>
            <param name="parent">Macro file parent, if any</param>
            <param name="line">Source line where the macro file is included</param>
            <param name="file">File information for the file containing the macro</param>
            <returns>Newly created <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIMacroFile"/></returns>
            <remarks>
            The list of macro node direct children is calculated by the use of the <see cref="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateMacro(Ubiquity.NET.Llvm.DebugInfo.DIMacroFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.MacroKind,System.String,System.String)"/>
            functions parentFile parameter.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateMacro(Ubiquity.NET.Llvm.DebugInfo.DIMacroFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.MacroKind,System.String,System.String)">
            <summary>Create a macro</summary>
            <param name="parentFile">Parent file containing the macro</param>
            <param name="line">Source line number where the macro is defined</param>
            <param name="kind">Kind of macro</param>
            <param name="name">Name of the macro</param>
            <param name="value">Value of the macro (use String.Empty for <see cref="F:Ubiquity.NET.Llvm.DebugInfo.MacroKind.Undefine"/>)</param>
            <returns>Newly created macro node</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateNamespace(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,System.Boolean)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DINamespace"/></summary>
            <param name="scope">Containing scope for the namespace or null if the namespace is a global one</param>
            <param name="name">Name of the namespace</param>
            <param name="exportSymbols">export symbols</param>
            <returns>Debug namespace</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateFile(System.String)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIFile"/></summary>
            <param name="path">Path of the file (may be <see langword="null"/> or empty)</param>
            <returns>
            <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIFile"/> or <see langword="null"/> if <paramref name="path"/>
            is <see langword="null"/> empty, or all whitespace
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateFile(System.String,System.String)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIFile"/></summary>
            <param name="fileName">Name of the file (may be <see langword="null"/> or empty)</param>
            <param name="directory">Path of the directory containing the file (may be <see langword="null"/> or empty)</param>
            <returns>
            <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIFile"/> created
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateLexicalBlock(Ubiquity.NET.Llvm.DebugInfo.DIScope,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,System.UInt32)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILexicalBlock"/></summary>
            <param name="scope"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIScope"/> for the block</param>
            <param name="file"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIFile"/> containing the block</param>
            <param name="line">Starting line number for the block</param>
            <param name="column">Starting column for the block</param>
            <returns>
            <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILexicalBlock"/> created from the parameters
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateLexicalBlockFile(Ubiquity.NET.Llvm.DebugInfo.DIScope,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILexicalBlockFile"/></summary>
            <param name="scope"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIScope"/> for the block</param>
            <param name="file"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIFile"/></param>
            <param name="discriminator">Discriminator to disambiguate lexical blocks with the same file info</param>
            <returns>
            <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILexicalBlockFile"/> constructed from the parameters
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateFunction(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DISubroutineType,System.Boolean,System.Boolean,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.Boolean,Ubiquity.NET.Llvm.Values.IrFunction)">
            <summary>Factory method to create a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/> with debug information</summary>
            <param name="scope"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIScope"/> for the function</param>
            <param name="name">Name of the function as it appears in the source language</param>
            <param name="mangledName">Linkage (mangled) name of the function</param>
            <param name="file"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIFile"/> containing the function</param>
            <param name="line">starting line of the function definition</param>
            <param name="signatureType"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubroutineType"/> for the function's signature type</param>
            <param name="isLocalToUnit">Flag to indicate if this function is local to the compilation unit or available externally</param>
            <param name="isDefinition">Flag to indicate if this is a definition or a declaration only</param>
            <param name="scopeLine">starting line of the first scope of the function's body</param>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for this function</param>
            <param name="isOptimized">Flag to indicate if this function is optimized</param>
            <param name="function">Underlying LLVM <see cref="T:Ubiquity.NET.Llvm.Values.IrFunction"/> to attach debug info to</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/> created based on the input parameters</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.ForwardDeclareFunction(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DISubroutineType,System.Boolean,System.Boolean,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.Boolean)">
            <summary>Creates a new forward declaration to a function</summary>
            <param name="scope"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIScope"/> for the declaration</param>
            <param name="name">Name of the function as it appears in source</param>
            <param name="mangledName">mangled name of the function (for linker)</param>
            <param name="file">Source file location for the function</param>
            <param name="line">starting line of the declaration</param>
            <param name="subroutineType">Signature for the function</param>
            <param name="isLocalToUnit">Flag to indicate if this declaration is local to the compilation unit</param>
            <param name="isDefinition">Flag to indicate if this is a definition</param>
            <param name="scopeLine">Line of the first scope block</param>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for the function</param>
            <param name="isOptimized">Flag to indicate if the function is optimized</param>
            <returns>Subprogram as a forward declaration</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateLocalVariable(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DIType,System.Boolean,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.UInt32)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable"/> for a given scope</summary>
            <param name="scope">Scope the variable belongs to</param>
            <param name="name">Name of the variable</param>
            <param name="file">File where the variable is declared</param>
            <param name="line">Line where the variable is declared</param>
            <param name="type">Type of the variable</param>
            <param name="alwaysPreserve">Flag to indicate if this variable's debug information should always be preserved</param>
            <param name="debugFlags">Flags for the variable</param>
            <param name="alignInBits">Variable alignment (in Bits)</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateArgument(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DIType,System.Boolean,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.UInt16)">
            <summary>Creates an argument for a function as a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable"/></summary>
            <param name="scope">Scope for the argument</param>
            <param name="name">Name of the argument</param>
            <param name="file"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIFile"/> containing the function this argument is declared in</param>
            <param name="line">Line number fort his argument</param>
            <param name="type">Debug type for this argument</param>
            <param name="alwaysPreserve">Flag to indicate if this argument is always preserved for debug view even if optimization would remove it</param>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for this argument</param>
            <param name="argNo">One based argument index on the method (e.g the first argument is 1 not 0 )</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable"/> representing the function argument</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateBasicType(System.String,System.UInt64,Ubiquity.NET.Llvm.DebugInfo.DiTypeKind,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags)">
            <summary>Construct debug information for a basic type (a.k.a. primitive type)</summary>
            <param name="name">Name of the type</param>
            <param name="bitSize">Bit size for the type</param>
            <param name="encoding"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DiTypeKind"/> encoding for the type</param>
            <param name="diFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for the type</param>
            <returns>Basic type debugging information</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreatePointerType(Ubiquity.NET.Llvm.DebugInfo.DIType,System.String,System.UInt64,System.UInt32,System.UInt32)">
            <summary>Creates a pointer type with debug information</summary>
            <param name="pointeeType">base type of the pointer (<see langword="null"/> => void)</param>
            <param name="name">Name of the type</param>
            <param name="bitSize">Bit size of the type</param>
            <param name="bitAlign">But alignment of the type</param>
            <param name="addressSpace">Address space for the pointer</param>
            <returns>Pointer type</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateQualifiedType(Ubiquity.NET.Llvm.DebugInfo.DIType,Ubiquity.NET.Llvm.DebugInfo.QualifiedTypeTag)">
            <summary>Creates a qualified type</summary>
            <param name="baseType">Base type to add the qualifier to</param>
            <param name="tag">Qualifier to apply</param>
            <returns>Qualified type</returns>
            <exception cref="T:System.ArgumentException"><paramref name="tag"/> is <see cref="F:Ubiquity.NET.Llvm.DebugInfo.QualifiedTypeTag.None"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="baseType"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateTypeArray(Ubiquity.NET.Llvm.DebugInfo.DIType[])">
            <summary>Create a debug metadata array of debug types</summary>
            <param name="types">Types to include in the array</param>
            <returns>Array containing the types</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateTypeArray(System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DIType})">
            <summary>Create a debug metadata array of debug types</summary>
            <param name="types">Types to include in the array</param>
            <returns>Array containing the types</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateSubroutineType(Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,Ubiquity.NET.Llvm.DebugInfo.DIType[])">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubroutineType"/> to provide debug information for a function/procedure signature</summary>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for this signature</param>
            <param name="types">Parameter types</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubroutineType"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateSubroutineType(Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DIType})">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubroutineType"/> to provide debug information for a function/procedure signature</summary>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for this signature</param>
            <param name="types">Parameter types</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubroutineType"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateSubroutineType(Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubroutineType"/> to provide debug information for a function/procedure signature</summary>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for this signature</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubroutineType"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateSubroutineType(Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,Ubiquity.NET.Llvm.DebugInfo.DIType,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DIType})">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubroutineType"/> to provide debug information for a function/procedure signature</summary>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for this signature</param>
            <param name="returnType">Return type of the signature</param>
            <param name="types">Parameters for the function</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubroutineType"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateStructType(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,System.UInt64,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,Ubiquity.NET.Llvm.DebugInfo.DIType,Ubiquity.NET.Llvm.DebugInfo.DINode[])">
            <summary>Creates debug description of a structure type</summary>
            <param name="scope">Scope containing the structure</param>
            <param name="name">Name of the type (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <param name="file">File containing the type</param>
            <param name="line">Line of the start of the type</param>
            <param name="bitSize">Size of the type in bits</param>
            <param name="bitAlign">Bit alignment of the type</param>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for the structure</param>
            <param name="derivedFrom"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIType"/> this type is derived from, if any</param>
            <param name="elements">Node array describing the elements of the structure</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateStructType(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,System.UInt64,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,Ubiquity.NET.Llvm.DebugInfo.DIType,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DINode},System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DIType,System.String)">
            <summary>Creates debug description of a structure type</summary>
            <param name="scope">Scope containing the structure</param>
            <param name="name">Name of the type (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <param name="file">File containing the type</param>
            <param name="line">Line of the start of the type</param>
            <param name="bitSize">Size of the type in bits</param>
            <param name="bitAlign">Bit alignment of the type</param>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for the structure</param>
            <param name="derivedFrom"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIType"/> this type is derived from, if any</param>
            <param name="elements">Node array describing the elements of the structure</param>
            <param name="runTimeLang">runtime language for the type</param>
            <param name="vTableHolder">VTable holder for the type</param>
            <param name="uniqueId">Unique ID for the type</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateUnionType(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,System.UInt64,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,Ubiquity.NET.Llvm.DebugInfo.DINodeArray)">
            <summary>Creates debug description of a union type</summary>
            <param name="scope">Scope containing the union</param>
            <param name="name">Name of the type (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <param name="file">File containing the union</param>
            <param name="line">Line of the start of the union</param>
            <param name="bitSize">Size of the union in bits</param>
            <param name="bitAlign">Bit alignment of the union</param>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for the union</param>
            <param name="elements">Node array describing the elements of the union</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateUnionType(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,System.UInt64,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,Ubiquity.NET.Llvm.DebugInfo.DINode[])">
            <summary>Creates debug description of a union type</summary>
            <param name="scope">Scope containing the union</param>
            <param name="name">Name of the type (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <param name="file">File containing the union</param>
            <param name="line">Line of the start of the union</param>
            <param name="bitSize">Size of the union in bits</param>
            <param name="bitAlign">Bit alignment of the union</param>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for the union</param>
            <param name="elements">Node array describing the elements of the union</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateUnionType(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,System.UInt64,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DINode},System.UInt32,System.String)">
            <summary>Creates debug description of a union type</summary>
            <param name="scope">Scope containing the union</param>
            <param name="name">Name of the type (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <param name="file">File containing the union</param>
            <param name="line">Line of the start of the union</param>
            <param name="bitSize">Size of the union in bits</param>
            <param name="bitAlign">Bit alignment of the union</param>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for the union</param>
            <param name="elements">Node array describing the elements of the union</param>
            <param name="runTimeLang">Objective-C runtime version [Default=0]</param>
            <param name="uniqueId">A unique identifier for the type</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateMemberType(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,System.UInt64,System.UInt32,System.UInt64,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,Ubiquity.NET.Llvm.DebugInfo.DIType)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIDerivedType"/> for a member of a type</summary>
            <param name="scope">Scope containing the member type</param>
            <param name="name">Name of the member type</param>
            <param name="file">File containing the member type</param>
            <param name="line">Line of the start of the member type</param>
            <param name="bitSize">Size of the member type in bits</param>
            <param name="bitAlign">Bit alignment of the member</param>
            <param name="bitOffset">Bit offset of the member</param>
            <param name="debugFlags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for the type</param>
            <param name="type">LLVM native type for the member type</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateArrayType(System.UInt64,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DIType,Ubiquity.NET.Llvm.DebugInfo.DINodeArray)">
            <summary>Creates debug information for an array type</summary>
            <param name="bitSize">Size, in bits for the type</param>
            <param name="bitAlign">Alignment in bits for the type</param>
            <param name="elementType">Type of elements in the array</param>
            <param name="subscripts">Dimensions for the array</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/> for the array</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateArrayType(System.UInt64,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DIType,Ubiquity.NET.Llvm.DebugInfo.DINode[])">
            <summary>Creates debug information for an array type</summary>
            <param name="bitSize">Size, in bits for the type</param>
            <param name="bitAlign">Alignment in bits for the type</param>
            <param name="elementType">Type of elements in the array</param>
            <param name="subscripts">Dimensions for the array</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/> for the array</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateArrayType(System.UInt64,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DIType,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DINode})">
            <summary>Creates debug information for an array type</summary>
            <param name="bitSize">Size, in bits for the type</param>
            <param name="bitAlign">Alignment in bits for the type</param>
            <param name="elementType">Type of elements in the array</param>
            <param name="subscripts">Dimensions for the array</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/> for the array</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateVectorType(System.UInt64,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DIType,Ubiquity.NET.Llvm.DebugInfo.DINodeArray)">
            <summary>Creates debug information for a vector type</summary>
            <param name="bitSize">Size, in bits for the type</param>
            <param name="bitAlign">Alignment in bits for the type</param>
            <param name="elementType">Type of elements in the Vector</param>
            <param name="subscripts">Dimensions for the Vector</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/> for the Vector</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateVectorType(System.UInt64,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DIType,Ubiquity.NET.Llvm.DebugInfo.DINode[])">
            <summary>Creates debug information for a vector type</summary>
            <param name="bitSize">Size, in bits for the type</param>
            <param name="bitAlign">Alignment in bits for the type</param>
            <param name="elementType">Type of elements in the Vector</param>
            <param name="subscripts">Dimensions for the Vector</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/> for the Vector</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateVectorType(System.UInt64,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DIType,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DINode})">
            <summary>Creates debug information for a vector type</summary>
            <param name="bitSize">Size, in bits for the type</param>
            <param name="bitAlign">Alignment in bits for the type</param>
            <param name="elementType">Type of elements in the Vector</param>
            <param name="subscripts">Dimensions for the Vector</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/> for the Vector</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateTypedef(Ubiquity.NET.Llvm.DebugInfo.DIType,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DINode,System.UInt32)">
            <summary>Creates debug information for a type definition (e.g. type alias)</summary>
            <param name="type">Debug information for the aliased type</param>
            <param name="name">Name of the alias</param>
            <param name="file">File for the declaration of the typedef</param>
            <param name="line">line for the typedef</param>
            <param name="context">Context for creating the typedef</param>
            <param name="alignInBits">Bit alignment for the type</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIDerivedType"/>for the alias</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateSubRange(System.Int64,System.Int64)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubRange"/></summary>
            <param name="lowerBound">Lower bounds of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubRange"/></param>
            <param name="count">Count of elements in the sub range</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubRange"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.GetOrCreateArray(System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DINode})">
            <summary>Gets or creates a node array with the specified elements</summary>
            <param name="elements">Elements of the array</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DINodeArray"/></returns>
            <remarks>
            <note type="Note">
            As of LLVM 8.0 there's not much reason to manually construct a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DINodeArray"/>
            since use as an "in" parameter were superseded by overloads taking an actual array.
            </note>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.GetOrCreateTypeArray(Ubiquity.NET.Llvm.DebugInfo.DIType[])">
            <summary>Gets or creates a Type array with the specified types</summary>
            <param name="types">Types</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DITypeArray"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.GetOrCreateTypeArray(System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DIType})">
            <summary>Gets or creates a Type array with the specified types</summary>
            <param name="types">Types</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DITypeArray"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateEnumeratorValue(System.String,System.Int64,System.Boolean)">
            <summary>Creates a value for an enumeration</summary>
            <param name="name">Name of the value</param>
            <param name="value">Value of the enumerated value</param>
            <param name="isUnsigned">Indicates if the value is unsigned [Default: false]</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIEnumerator"/> for the name, value pair</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateEnumerationType(Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,System.UInt64,System.UInt32,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DIEnumerator},Ubiquity.NET.Llvm.DebugInfo.DIType)">
            <summary>Creates an enumeration type</summary>
            <param name="scope">Containing scope for the type</param>
            <param name="name">source language name of the type (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <param name="file">Source file containing the type</param>
            <param name="lineNumber">Source file line number for the type</param>
            <param name="sizeInBits">Size, in bits, for the type</param>
            <param name="alignInBits">Alignment, in bits for the type</param>
            <param name="elements"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIEnumerator"/> elements for the type</param>
            <param name="underlyingType">Underlying type for the enumerated type</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/> for the enumerated type</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateGlobalVariableExpression(Ubiquity.NET.Llvm.DebugInfo.DINode,System.String,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DIType,System.Boolean,Ubiquity.NET.Llvm.DebugInfo.DIExpression,Ubiquity.NET.Llvm.DebugInfo.DINode,System.UInt32)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariableExpression"/></summary>
            <param name="scope">Scope for the expression</param>
            <param name="name">Source language name of the expression</param>
            <param name="linkageName">Linkage name of the expression</param>
            <param name="file">Source file for the expression</param>
            <param name="lineNo">Source Line number for the expression</param>
            <param name="type"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIType"/> of the expression</param>
            <param name="isLocalToUnit">Flag to indicate if this is local to the compilation unit (e.g. static in C)</param>
            <param name="value"><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the variable</param>
            <param name="declaration"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DINode"/> for the declaration of the variable</param>
            <param name="bitAlign">Bit alignment for the expression</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariableExpression"/> from the parameters</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.Finish(Ubiquity.NET.Llvm.DebugInfo.DISubProgram)">
            <summary>Finalizes debug information for a single <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/></summary>
            <param name="subProgram"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/> to finalize debug information for</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.Finish">
            <summary>Finalizes debug information for all items built by this builder</summary>
            <remarks>
            <note type="note">
             The term "finalize" here is in the context of LLVM rather than the .NET concept of Finalization.
             In particular this will trigger resolving temporaries and will complete the list of locals for
             any functions. So, the only nodes allowed after this is called are those that are fully resolved.
            </note>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.InsertDeclare(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.DebugInfo.DILocalVariable,Ubiquity.NET.Llvm.DebugInfo.DILocation,Ubiquity.NET.Llvm.Instructions.Instruction)">
            <summary>Inserts an llvm.dbg.declare instruction before the given instruction</summary>
            <param name="storage">Value the declaration is bound to</param>
            <param name="varInfo"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable"/> for <paramref name="storage"/></param>
            <param name="location"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocation"/>for the variable</param>
            <param name="insertBefore"><see cref="T:Ubiquity.NET.Llvm.Instructions.Instruction"/> to insert the declaration before</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/> for the call to llvm.dbg.declare</returns>
            <remarks>
            This adds a call to the <see href="xref:llvm_sourcelevel_debugging#lvm-dbg-declare">llvm.dbg.declare</see> intrinsic.
            The call has no impact on the actual machine code generated, as it is removed or ignored for actual target instruction
            selection. Instead this provides a means to bind the LLVM Debug information metadata to a particular LLVM <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            that allows the transformation and optimization passes to track the debug information. Thus, even with optimized code
            the actual debug information is retained.
            </remarks>
            <seealso href="xref:llvm_sourcelevel_debugging#lvm-dbg-declare">LLVM: llvm.dbg.declare</seealso>
            <seealso href="xref:llvm_sourcelevel_debugging#source-level-debugging-with-llvm">LLVM: Source Level Debugging with LLVM</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.InsertDeclare(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.DebugInfo.DILocalVariable,Ubiquity.NET.Llvm.DebugInfo.DIExpression,Ubiquity.NET.Llvm.DebugInfo.DILocation,Ubiquity.NET.Llvm.Instructions.Instruction)">
            <summary>Inserts an llvm.dbg.declare instruction before the given instruction</summary>
            <param name="storage">Value the declaration is bound to</param>
            <param name="varInfo"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable"/> for <paramref name="storage"/></param>
            <param name="expression"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIExpression"/> for a debugger to use when extracting the value</param>
            <param name="location"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocation"/>for the variable</param>
            <param name="insertBefore"><see cref="T:Ubiquity.NET.Llvm.Instructions.Instruction"/> to insert the declaration before</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/> for the call to llvm.dbg.declare</returns>
            <remarks>
            This adds a call to the <see href="xref:llvm_sourcelevel_debugging#lvm-dbg-declare">llvm.dbg.declare</see> intrinsic.
            The call has no impact on the actual machine code generated, as it is removed or ignored for actual target instruction
            selection. Instead this provides a means to bind the LLVM Debug information metadata to a particular LLVM <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            that allows the transformation and optimization passes to track the debug information. Thus, even with optimized code
            the actual debug information is retained.
            </remarks>
            <seealso href="xref:llvm_sourcelevel_debugging#lvm-dbg-declare">LLVM: llvm.dbg.declare</seealso>
            <seealso href="xref:llvm_sourcelevel_debugging#source-level-debugging-with-llvm">LLVM: Source Level Debugging with LLVM</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.InsertDeclare(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.DebugInfo.DILocalVariable,Ubiquity.NET.Llvm.DebugInfo.DILocation,Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Inserts an llvm.dbg.declare instruction before the given instruction</summary>
            <param name="storage">Value the declaration is bound to</param>
            <param name="varInfo"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable"/> for <paramref name="storage"/></param>
            <param name="location"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocation"/>for the variable</param>
            <param name="insertAtEnd"><see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> to insert the declaration at the end of</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/> for the call to llvm.dbg.declare</returns>
            <remarks>
            This adds a call to the <see href="xref:llvm_sourcelevel_debugging#lvm-dbg-declare">llvm.dbg.declare</see> intrinsic.
            The call has no impact on the actual machine code generated, as it is removed or ignored for actual target instruction
            selection. Instead this provides a means to bind the LLVM Debug information metadata to a particular LLVM <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            that allows the transformation and optimization passes to track the debug information. Thus, even with optimized code
            the actual debug information is retained.
            </remarks>
            <seealso href="xref:llvm_sourcelevel_debugging#lvm-dbg-declare">LLVM: llvm.dbg.declare</seealso>
            <seealso href="xref:llvm_sourcelevel_debugging#source-level-debugging-with-llvm">LLVM: Source Level Debugging with LLVM</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.InsertDeclare(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.DebugInfo.DILocalVariable,Ubiquity.NET.Llvm.DebugInfo.DIExpression,Ubiquity.NET.Llvm.DebugInfo.DILocation,Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Inserts an llvm.dbg.declare instruction before the given instruction</summary>
            <param name="storage">Value the declaration is bound to</param>
            <param name="varInfo"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable"/> for <paramref name="storage"/></param>
            <param name="expression"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIExpression"/> for a debugger to use when extracting the value</param>
            <param name="location"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocation"/>for the variable</param>
            <param name="insertAtEnd"><see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> to insert the declaration at the end of</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/> for the call to llvm.dbg.declare</returns>
            <remarks>
            This adds a call to the <see href="xref:llvm_sourcelevel_debugging#lvm-dbg-declare">llvm.dbg.declare</see> intrinsic.
            <note type="note">
            The call has no impact on the actual machine code generated, as it is removed or ignored for actual target instruction
            selection. Instead this provides a means to bind the LLVM Debug information metadata to a particular LLVM <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            that allows the transformation and optimization passes to track the debug information. Thus, even with optimized code
            the actual debug information is retained.
            </note>
            </remarks>
            <seealso href="xref:llvm_sourcelevel_debugging#lvm-dbg-declare">LLVM: llvm.dbg.declare</seealso>
            <seealso href="xref:llvm_sourcelevel_debugging#source-level-debugging-with-llvm">LLVM: Source Level Debugging with LLVM</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.InsertValue(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.DebugInfo.DILocalVariable,Ubiquity.NET.Llvm.DebugInfo.DILocation,Ubiquity.NET.Llvm.Instructions.Instruction)">
            <summary>Inserts a call to the llvm.dbg.value intrinsic before the specified instruction</summary>
            <param name="value">New value</param>
            <param name="varInfo"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable"/> describing the variable</param>
            <param name="location"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocation"/>for the assignment</param>
            <param name="insertBefore">Location to insert the intrinsic</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/> for the intrinsic</returns>
            <remarks>
            This intrinsic provides information when a user source variable is set to a new value.
            <note type="note">
            The call has no impact on the actual machine code generated, as it is removed or ignored for actual target instruction
            selection. Instead this provides a means to bind the LLVM Debug information metadata to a particular LLVM <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            that allows the transformation and optimization passes to track the debug information. Thus, even with optimized code
            the actual debug information is retained.
            </note>
            </remarks>
            <seealso href="xref:llvm_sourcelevel_debugging#lvm-dbg-value">LLVM: llvm.dbg.value</seealso>
            <seealso href="xref:llvm_sourcelevel_debugging#source-level-debugging-with-llvm">LLVM: Source Level Debugging with LLVM</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.InsertValue(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.DebugInfo.DILocalVariable,Ubiquity.NET.Llvm.DebugInfo.DIExpression,Ubiquity.NET.Llvm.DebugInfo.DILocation,Ubiquity.NET.Llvm.Instructions.Instruction)">
            <summary>Inserts a call to the llvm.dbg.value intrinsic before the specified instruction</summary>
            <param name="value">New value</param>
            <param name="varInfo"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable"/> describing the variable</param>
            <param name="expression"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIExpression"/> for the variable</param>
            <param name="location"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocation"/>for the assignment</param>
            <param name="insertBefore">Location to insert the intrinsic</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/> for the intrinsic</returns>
            <remarks>
            This intrinsic provides information when a user source variable is set to a new value.
            <note type="note">
            The call has no impact on the actual machine code generated, as it is removed or ignored for actual target instruction
            selection. Instead this provides a means to bind the LLVM Debug information metadata to a particular LLVM <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            that allows the transformation and optimization passes to track the debug information. Thus, even with optimized code
            the actual debug information is retained.
            </note>
            </remarks>
            <seealso href="xref:llvm_sourcelevel_debugging#lvm-dbg-value">LLVM: llvm.dbg.value</seealso>
            <seealso href="xref:llvm_sourcelevel_debugging#source-level-debugging-with-llvm">LLVM: Source Level Debugging with LLVM</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.InsertValue(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.DebugInfo.DILocalVariable,Ubiquity.NET.Llvm.DebugInfo.DILocation,Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Inserts a call to the llvm.dbg.value intrinsic at the end of a basic block</summary>
            <param name="value">New value</param>
            <param name="varInfo"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable"/> describing the variable</param>
            <param name="location"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocation"/>for the assignment</param>
            <param name="insertAtEnd">Block to append the intrinsic to the end of</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/> for the intrinsic</returns>
            <remarks>
            This intrinsic provides information when a user source variable is set to a new value.
            <note type="note">
            The call has no impact on the actual machine code generated, as it is removed or ignored for actual target instruction
            selection. Instead this provides a means to bind the LLVM Debug information metadata to a particular LLVM <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            that allows the transformation and optimization passes to track the debug information. Thus, even with optimized code
            the actual debug information is retained.
            </note>
            </remarks>
            <seealso href="xref:llvm_sourcelevel_debugging#lvm-dbg-value">LLVM: llvm.dbg.value</seealso>
            <seealso href="xref:llvm_sourcelevel_debugging#source-level-debugging-with-llvm">LLVM: Source Level Debugging with LLVM</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.InsertValue(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.DebugInfo.DILocalVariable,Ubiquity.NET.Llvm.DebugInfo.DIExpression,Ubiquity.NET.Llvm.DebugInfo.DILocation,Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Inserts a call to the llvm.dbg.value intrinsic at the end of a basic block</summary>
            <param name="value">New value</param>
            <param name="varInfo"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable"/> describing the variable</param>
            <param name="expression"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIExpression"/> for the variable</param>
            <param name="location"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocation"/>for the assignment</param>
            <param name="insertAtEnd">Block to append the intrinsic to the end of</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/> for the intrinsic</returns>
            <remarks>
            This intrinsic provides information when a user source variable is set to a new value.
            <note type="note">
            The call has no impact on the actual machine code generated, as it is removed or ignored for actual target instruction
            selection. Instead, this provides a means to bind the LLVM Debug information metadata to a particular LLVM <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            that allows the transformation and optimization passes to track the debug information. Thus, even with optimized code
            the actual debug information is retained.
            </note>
            </remarks>
            <seealso href="xref:llvm_sourcelevel_debugging#lvm-dbg-value">LLVM: llvm.dbg.value</seealso>
            <seealso href="xref:llvm_sourcelevel_debugging#source-level-debugging-with-llvm">LLVM: Source Level Debugging with LLVM</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateExpression(Ubiquity.NET.Llvm.DebugInfo.ExpressionOp[])">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIExpression"/> from the provided <see cref="T:Ubiquity.NET.Llvm.DebugInfo.ExpressionOp"/>s</summary>
            <param name="operations">Operation sequence for the expression</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIExpression"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateExpression(System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.ExpressionOp})">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIExpression"/> from the provided <see cref="T:Ubiquity.NET.Llvm.DebugInfo.ExpressionOp"/>s</summary>
            <param name="operations">Operation sequence for the expression</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIExpression"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateConstantValueExpression(System.Int64)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIExpression"/> for a constant value</summary>
            <param name="value">Value of the expression</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIExpression"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateReplaceableCompositeType(Ubiquity.NET.Llvm.DebugInfo.Tag,System.String,Ubiquity.NET.Llvm.DebugInfo.DIScope,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,System.UInt32,System.UInt64,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.String)">
            <summary>Creates a replaceable composite type</summary>
            <param name="tag">Debug information <see cref="T:Ubiquity.NET.Llvm.DebugInfo.Tag"/> for the composite type (only values for a composite type are allowed)</param>
            <param name="name">Name of the type (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <param name="scope">Scope of the type</param>
            <param name="file">Source file for the type</param>
            <param name="line">Source line for the type</param>
            <param name="lang">Source language the type is defined in</param>
            <param name="sizeInBits">size of the type in bits</param>
            <param name="alignBits">alignment of the type in bits</param>
            <param name="flags"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/> for the type</param>
            <param name="uniqueId">Unique identifier for the type</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/></returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo">
            <summary>Describes a member/field of a type for creating debug information</summary>
            <remarks>
            <para>This class is used with <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugStructType"/> to provide debug information for a type.</para>
            <para>In order to support explicit layout structures the members relating to layout are all nullable.
            When they are null then modules <see cref="P:Ubiquity.NET.Llvm.BitcodeModule.Layout"/> target specific layout information is used to determine
            layout details. Setting the layout members of this class to non-null will override that behavior to define explicit
            layout details.</para>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo.#ctor(System.UInt32,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType},Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,Ubiquity.NET.Llvm.DebugInfo.DebugMemberLayout)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo"/> class.</summary>
            <param name="index">Member index</param>
            <param name="name">Member name</param>
            <param name="file">File containing the declaration of the member</param>
            <param name="line">Line number containing the member</param>
            <param name="debugType">Debug type for the member</param>
            <param name="debugInfoFlags">Flags for the member</param>
            <param name="explicitLayout">Explicit layout information for this member, if any</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo.Index">
            <summary>Gets the LLVM structure element index this descriptor describes</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo.Name">
            <summary>Gets the name of the field</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo.File">
            <summary>Gets the file the field is declared in</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo.Line">
            <summary>Gets the source line the field is declared on</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo.DebugInfoFlags">
            <summary>Gets the flags for the field declaration</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo.DebugType">
            <summary>Gets the debug type information for this field</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo.ExplicitLayout">
            <summary>Gets the explicit layout information for this member</summary>
            <remarks>If this is <see langword="null"/> then <see href="xref:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.SetBody*">DebugStructType.SetBody</see>
            will default to using <see cref="P:Ubiquity.NET.Llvm.BitcodeModule.Layout"/> to determine the size using the module's target specific layout.
            <note type="Important">
            If this property is provided (e.g. is not <see langword="null"/>) for any member of a type, then
            it must be set for *all* members. In other words explicit layout must be defined for all members
            or none. Furthermore, for types using explicit layout, the LLVM type containing this member must
            include the "packed" modifier.
            </note>
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DebugMemberLayout">
            <summary>DebugMemberLayout is used to define custom layout information for structure members</summary>
            <remarks>
            Ordinarily layout information is handle automatically in
            <see href="xref:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.SetBody*">DebugStructType.SetBody</see>
            however in cases where explicitly controlled (or "packed") layout is required, instances of DebugMemberLayout are
            used to provide the information necessary to generate a proper type and debug information.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugMemberLayout.#ctor(System.UInt64,System.UInt32,System.UInt64)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugMemberLayout"/> class.</summary>
            <param name="bitSize">Size of the member in bits</param>
            <param name="bitAlignment">Alignment of the member in bits</param>
            <param name="bitOffset">Offset of the member in bits</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugMemberLayout.BitSize">
            <summary>Gets the bit size for the field</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugMemberLayout.BitAlignment">
            <summary>Gets the bit alignment for the field</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugMemberLayout.BitOffset">
            <summary>Gets the bit offset for the field in it's containing type</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DebugPointerType">
            <summary>Binding between a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIDerivedType"/> and an <see cref="T:Ubiquity.NET.Llvm.Types.IPointerType"/></summary>
            <seealso href="xref:llvm_langref#diderivedtype">LLVM DIDerivedType</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugPointerType.#ctor(Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType},Ubiquity.NET.Llvm.BitcodeModule,System.UInt32,System.String,System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugPointerType"/> class.</summary>
            <param name="debugElementType">Debug type of the pointee</param>
            <param name="module"><see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/> used for creating the pointer type and debug information</param>
            <param name="addressSpace">Target address space for the pointer [Default: 0]</param>
            <param name="name">Name of the type [Default: null]</param>
            <param name="alignment">Alignment on pointer</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugPointerType.#ctor(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.DebugInfo.DIType,System.UInt32,System.String,System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugPointerType"/> class.</summary>
            <param name="llvmElementType">Native type of the pointee</param>
            <param name="module"><see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/> used for creating the pointer type and debug information</param>
            <param name="elementType">Debug type of the pointee</param>
            <param name="addressSpace">Target address space for the pointer [Default: 0]</param>
            <param name="name">Name of the type [Default: null]</param>
            <param name="alignment">Alignment of pointer</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugPointerType.#ctor(Ubiquity.NET.Llvm.Types.IPointerType,Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.DebugInfo.DIType,System.String,System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugPointerType"/> class.</summary>
            <param name="llvmPtrType">Native type of the pointer</param>
            <param name="module"><see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/> used for creating the pointer type and debug information</param>
            <param name="elementType">Debug type of the pointee</param>
            <param name="name">Name of the type [Default: null]</param>
            <param name="alignment">Alignment for pointer type</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugPointerType.#ctor(Ubiquity.NET.Llvm.Types.IPointerType,Ubiquity.NET.Llvm.DebugInfo.DIDerivedType)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugPointerType"/> class.</summary>
            <param name="llvmPtrType">Native type of the pointer</param>
            <param name="debugType">Debug type for the pointer</param>
            <remarks>
            This constructor is typically used when building typedefs to a basic type
            to provide namespace scoping for the typedef for languages that support
            such a concept. This is needed because basic types don't have any namespace
            information in the LLVM Debug information (they are implicitly in the global
            namespace)
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugPointerType.AddressSpace">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugPointerType.ElementType">
            <inheritdoc/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DebugStructType">
            <summary>Debug information for a structure type</summary>
            <seealso href="xref:llvm_langref#dicompositetype">LLVM DICompositeType</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.#ctor(Ubiquity.NET.Llvm.BitcodeModule,System.String,Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo},Ubiquity.NET.Llvm.DebugInfo.DIType,System.Boolean,System.Nullable{System.UInt32},System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugStructType"/> class.</summary>
            <param name="module">Module to contain the debug meta data</param>
            <param name="nativeName">Name of the type in LLVM IR (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <param name="scope">Debug scope for the structure</param>
            <param name="sourceName">Source/debug name of the struct (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <param name="file">File containing the definition of this type</param>
            <param name="line">line number this type is defined at</param>
            <param name="debugFlags">debug flags for this type</param>
            <param name="members">Description of all the members of this structure</param>
            <param name="derivedFrom">Base type, if any for this type</param>
            <param name="packed">Indicates if this type is packed or not</param>
            <param name="bitSize">Total bit size for this type or <see langword="null"/> to use default for target</param>
            <param name="bitAlignment">Alignment of the type in bits, 0 indicates default for target</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.#ctor(Ubiquity.NET.Llvm.Types.IStructType,Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,Ubiquity.NET.Llvm.DebugInfo.DIType,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DIType},System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugStructType"/> class.</summary>
            <param name="llvmType">LLVM native type to build debug information for</param>
            <param name="module">Module to contain the debug meta data</param>
            <param name="scope">Debug scope for the structure</param>
            <param name="name">Source/debug name of the struct (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <param name="file">File containing the definition of this type</param>
            <param name="line">line number this type is defined at</param>
            <param name="debugFlags">debug flags for this type</param>
            <param name="elements">Debug type of all the members of this structure</param>
            <param name="derivedFrom">Base type, if any for this type</param>
            <param name="bitAlignment">Alignment of the type in bits, 0 indicates default for target</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.#ctor(Ubiquity.NET.Llvm.Types.IStructType,Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugStructType"/> class.</summary>
            <param name="llvmType">LLVM native type to build debug information for</param>
            <param name="module">Module to contain the debug meta data</param>
            <param name="scope">Debug scope for the structure</param>
            <param name="name">Source/debug name of the struct (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <param name="file">File containing the definition of this type</param>
            <param name="line">line number this type is defined at</param>
            <remarks>
            This constructor creates a replaceable type that is replaced later with a full
            definition of the type
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.#ctor(Ubiquity.NET.Llvm.BitcodeModule,System.String,Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugStructType"/> class.</summary>
            <param name="module">Module to contain the debug meta data</param>
            <param name="nativeName">Name of the type in LLVM IR</param>
            <param name="scope">Debug scope for the structure</param>
            <param name="name">Source/debug name of the struct (use <see cref="F:System.String.Empty"/> for anonymous types)</param>
            <param name="file">File containing the definition of this type</param>
            <param name="line">line number this type is defined at</param>
            <remarks>
            This constructor creates a replaceable type that is replaced later with a full
            definition of the type
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.IsOpaque">
            <summary>Gets a value indicating whether the type is Opaque (e.g. has no body)</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.IsPacked">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.Members">
            <summary>Gets the members of the type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.Name">
            <summary>Gets the name of the type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.SourceName">
            <summary>Gets the Source/Debug name</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.SetBody(System.Boolean,Ubiquity.NET.Llvm.Types.ITypeRef[])">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.SetBody(System.Boolean,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Types.ITypeRef})">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.SetBody(System.Boolean,Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.DebugInfo.DIScope,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo})">
            <summary>Set the body of a type</summary>
            <param name="packed">Flag to indicate if the body elements are packed (e.g. no padding)</param>
            <param name="module">Module to contain the debug metadata for the type</param>
            <param name="scope">Scope containing this type</param>
            <param name="file">File containing the type</param>
            <param name="line">Line in <paramref name="file"/> for this type</param>
            <param name="debugFlags">Debug flags for this type</param>
            <param name="debugElements">Descriptors for all the elements in the type</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.SetBody(System.Boolean,Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.DebugInfo.DIScope,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Types.ITypeRef},System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo},Ubiquity.NET.Llvm.DebugInfo.DIType,System.Nullable{System.UInt32},System.UInt32)">
            <summary>Set the body of a type</summary>
            <param name="packed">Flag to indicate if the body elements are packed (e.g. no padding)</param>
            <param name="module">Module to contain the debug metadata for the type</param>
            <param name="scope">Scope containing this type</param>
            <param name="file">File containing the type</param>
            <param name="line">Line in <paramref name="file"/> for this type</param>
            <param name="debugFlags">Debug flags for this type</param>
            <param name="nativeElements">LLVM type of each element</param>
            <param name="debugElements">Descriptors for each element in the type</param>
            <param name="derivedFrom">Base type, if any for this type</param>
            <param name="bitSize">Total bit size for this type or <see langword="null"/> to use default for target</param>
            <param name="bitAlignment">Alignment of the type in bits, 0 indicates default for target</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugStructType.DebugMembers">
            <summary>Gets a list of descriptors for each members</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.IDebugType`2">
            <summary>Provides pairing of a <see cref="T:Ubiquity.NET.Llvm.Types.ITypeRef"/> with a <see cref="P:Ubiquity.NET.Llvm.DebugInfo.IDebugType`2.DIType"/> for function signatures</summary>
            <typeparam name="TNative">Native LLVM type</typeparam>
            <typeparam name="TDebug">Debug type description for the type</typeparam>
            <remarks>
            <para>Primitive types and function signature types are all interned in LLVM, thus there won't be a
            strict one to one relationship between an LLVM type and corresponding language specific debug
            type. (e.g. unsigned char, char, byte and signed byte might all be 8 bit integer values as far
            as LLVM is concerned.) Also, when using the pointer+alloca+memcpy pattern to pass by value the
            actual source debug info type is different than the LLVM function signature. This interface and
            it's implementations are used to construct native type and debug info pairing to allow applications
            to maintain a link from their AST or IR types into the LLVM native type and debug information.
            </para>
            <note type="note">
            It is important to note that the relationship from the <see cref="P:Ubiquity.NET.Llvm.DebugInfo.IDebugType`2.DIType"/> to it's <see cref="P:Ubiquity.NET.Llvm.DebugInfo.IDebugType`2.NativeType"/>
            properties is strictly ***one way***. That is, there is no way to take an arbitrary <see cref="T:Ubiquity.NET.Llvm.Types.ITypeRef"/>
            and re-associate it with the DIType or an implementation of this interface as there may be many such
            mappings to choose from.
            </note>
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.IDebugType`2.NativeType">
            <summary>Gets the LLVM NativeType this interface is associating with debug info in <see cref="P:Ubiquity.NET.Llvm.DebugInfo.IDebugType`2.DIType"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.IDebugType`2.DIType">
            <summary>Gets the debug information type this interface is associating with <see cref="P:Ubiquity.NET.Llvm.DebugInfo.IDebugType`2.NativeType"/></summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.IDebugType`2.CreatePointerType(Ubiquity.NET.Llvm.BitcodeModule,System.UInt32)">
            <summary>Creates a pointer to this type for a given module and address space</summary>
            <param name="bitcodeModule">Module the debug type information belongs to</param>
            <param name="addressSpace">Address space for the pointer</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugPointerType"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.IDebugType`2.CreateArrayType(Ubiquity.NET.Llvm.BitcodeModule,System.UInt32,System.UInt32)">
            <summary>Creates a type defining an array of elements of this type</summary>
            <param name="bitcodeModule">Module the debug information belongs to</param>
            <param name="lowerBound">Lower bound of the array</param>
            <param name="count">Count of elements in the array</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugArrayType"/></returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DebugType`2">
            <summary>Base class for Debug types bound with an LLVM type</summary>
            <typeparam name="TNative">Native LLVM type</typeparam>
            <typeparam name="TDebug">Debug type</typeparam>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.DIType">
            <summary>Gets or sets the Debug information type for this binding</summary>
            <remarks>
            <para>Setting the debug type is only allowed when the debug type is null or <see cref="P:Ubiquity.NET.Llvm.MDNode.IsTemporary"/>
            is <see langword="true"/>. If the debug type node is a temporary setting the type will replace all uses
            of the temporary type automatically, via <see cref="M:Ubiquity.NET.Llvm.MDNode.ReplaceAllUsesWith(Ubiquity.NET.Llvm.LlvmMetadata)"/></para>
            <para>Since setting this property will replace all uses with (RAUW) the new value then setting this property
            with <see langword="null"/> is not allowed. However, until set this property will be <see  langword="null"/></para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The type is not <see langword="null"/> or not a temporary</exception>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.NativeType">
            <summary>Gets or sets the native LLVM type for this debug type binding</summary>
            <remarks>
            Once the native type is set, it cannot be reset. Attempts to change the native
            type when it isn't <see langword="null"/> will result in an exception.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The native type was already set</exception>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.Ubiquity#NET#Llvm#Types#ITypeHandleOwner#TypeHandle">
            <summary>Gets an intentionally undocumented value</summary>
            <remarks>internal use only</remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.IsSized">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.Kind">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.Context">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.IntegerBitWidth">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.IsInteger">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.IsFloat">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.IsDouble">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.IsVoid">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.IsStruct">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.IsPointer">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.IsSequence">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.IsFloatingPoint">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.IsPointerPointer">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.GetNullValue">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.CreateArrayType(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.CreatePointerType">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.CreatePointerType(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.CreatePointerType(Ubiquity.NET.Llvm.BitcodeModule,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.CreateArrayType(Ubiquity.NET.Llvm.BitcodeModule,System.UInt32,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.TryGetExtendedPropertyValue``1(System.String,``0@)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.AddExtendedPropertyValue(System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.op_Implicit(Ubiquity.NET.Llvm.DebugInfo.DebugType{`0,`1})~`1">
            <summary>Converts a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugType`2"/> to <typeparamref name="TDebug"/> by accessing the <see cref="P:Ubiquity.NET.Llvm.DebugInfo.DebugType`2.DIType"/> property</summary>
            <param name="self">The type to convert</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DebugType">
            <summary>Utility class to provide mix-in type extensions and support for Debug Types</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugType.Create``2(``0,``1)">
            <summary>Creates a new <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugType"/>instance inferring the generic arguments from the parameters</summary>
            <typeparam name="TNative">Type of the Native LLVM type for the association</typeparam>
            <typeparam name="TDebug">Type of the debug information type for the association</typeparam>
            <param name="nativeType"><typeparamref name="TNative"/> type instance for this association</param>
            <param name="debugType"><typeparamref name="TDebug"/> type instance for this association (use <see langword="null"/> for void)</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.DebugInfo.IDebugType`2"/> implementation for the specified association</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugType.HasDebugInfo(Ubiquity.NET.Llvm.DebugInfo.IDebugType{Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.DebugInfo.DIType})">
            <summary>Convenience extensions for determining if the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIType"/> property is valid</summary>
            <param name="debugType">Debug type to test for valid Debug information</param>
            <remarks>In LLVM Debug information a <see langword="null"/> <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIType"/> is
            used to represent the void type. Thus, looking only at the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIType"/> property is
            insufficient to distinguish between a type with no debug information and one representing the void
            type. This property is used to disambiguate the two possibilities.
            </remarks>
            <returns><see langword="true"/> if the type has debug information</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DebugUnionType">
            <summary>Debug representation of a union type</summary>
            <remarks>The underlying native LLVM type is a structure with a single member</remarks>
            <seealso href="xref:llvm_langref#dicompositetype">LLVM DICompositeType</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugUnionType.#ctor(Ubiquity.NET.Llvm.Types.IStructType,Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo})">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugUnionType"/> class.</summary>
            <param name="llvmType">Underlying native type this debug type describes</param>
            <param name="module">Module to contain the debug metadata for this type</param>
            <param name="scope">Scope containing this type</param>
            <param name="name">Debug/source name of the type</param>
            <param name="file">Source file containing this type</param>
            <param name="line">Line number for this type</param>
            <param name="debugFlags">Debug flags for this type</param>
            <param name="elements">Descriptors for the members of the type</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugUnionType.#ctor(Ubiquity.NET.Llvm.BitcodeModule,System.String,Ubiquity.NET.Llvm.DebugInfo.DIScope,System.String,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugUnionType"/> class.</summary>
            <param name="module">Module to contain the debug metadata for this type</param>
            <param name="nativeName">Native LLVM type name</param>
            <param name="scope">Scope containing this type</param>
            <param name="name">Debug/source name of the type</param>
            <param name="file">Source file containing this type</param>
            <param name="line">Line number for this type</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugUnionType.IsOpaque">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugUnionType.Members">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugUnionType.Name">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DebugUnionType.DebugMembers">
            <summary>Gets the description of each member of the type</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DebugUnionType.SetBody(Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.DebugInfo.DIScope,Ubiquity.NET.Llvm.DebugInfo.DIFile,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DebugMemberInfo})">
            <summary>Sets the body of the union type</summary>
            <param name="module">Module to contain the debug metadata</param>
            <param name="scope">Scope containing this type</param>
            <param name="file">File for the type</param>
            <param name="line">line number for the type</param>
            <param name="debugFlags">Flags for the type</param>
            <param name="debugElements">Descriptors for each element in the type</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIBasicType">
            <summary>Debug information for a basic type</summary>
            <seealso cref="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.CreateBasicType(System.String,System.UInt64,Ubiquity.NET.Llvm.DebugInfo.DiTypeKind,Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags)"/>
            <seealso href="xref:llvm_langref#dibasictype">LLVM DIBasicType</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIBasicType.Encoding">
            <summary>Gets the encoding for the type</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DIBasicType.#ctor(Ubiquity.NET.Llvm.Interop.LLVMMetadataRef)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIBasicType"/> class.</summary>
            <param name="handle"><see cref="T:Ubiquity.NET.Llvm.Interop.LLVMMetadataRef"/> for a  DIBasicType to wrap</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit">
            <summary>Debug Information Compile Unit, which acts as the containing parent for debug information in a module</summary>
            <seealso href="xref:llvm_langref#dicompileunit">LLVM DICompileUnit</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit.Producer">
            <summary>Gets the name of the producer of this unit</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit.Flags">
            <summary>Gets the compilation flags for this unit</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit.SplitDebugFileName">
            <summary>Gets the split debug file name for this unit</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit.EnumTypes">
            <summary>Gets the enum types in this unit</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit.RetainedTypes">
            <summary>Gets the retained types for this unit</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit.GlobalVariables">
            <summary>Gets the global variable expressions for this unit</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit.ImportedEntities">
            <summary>Gets the imported entities for this unit</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit.Macros">
            <summary>Gets the macro information for the compile unit</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit.#ctor(Ubiquity.NET.Llvm.Interop.LLVMMetadataRef)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit"/> class from a native <see cref="T:Ubiquity.NET.Llvm.Interop.LLVMMetadataRef"/></summary>
            <param name="handle">native reference to wrap</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType">
            <summary>Debug information for a composite type</summary>
            <seealso href="xref:llvm_langref#dicompositetype">LLVM DICompositeType</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompositeType.BaseType">
            <summary>Gets the base type for this type, if any</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompositeType.Elements">
            <summary>Gets the elements of this <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompositeType.VTableHolder">
            <summary>Gets the type that holds the VTable for this type, if any</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompositeType.TemplateParameters">
            <summary>Gets the template parameters for this type, if any</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompositeType.Identifier">
            <summary>Gets the identifier for this type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DICompositeType.Discriminator">
            <summary>Gets the Discriminator for the composite type</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DICompositeType.#ctor(Ubiquity.NET.Llvm.Interop.LLVMMetadataRef)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/> class from an LLVM-C API Metadata handle</summary>
            <param name="handle">LLVM handle to wrap</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeTypeArray">
            <summary>Array of <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompositeType"/> debug information nodes for use with <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/> methods</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIDerivedType">
            <summary>Derived type</summary>
            <remarks>
            Debug information for a type derived from an existing type
            </remarks>
            <seealso href="xref:llvm_langref#diderivedtype">LLVM DIDerivedType</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIDerivedType.BaseType">
            <summary>Gets the base type of this type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIDerivedType.ExtraData">
            <summary>Gets the extra data, if any, attached to this derived type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIDerivedType.ClassType">
            <summary>Gets the Class type extra data for a pointer to member type, if any</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIDerivedType.ObjCProperty">
            <summary>Gets the ObjCProperty extra data</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIDerivedType.StorageOffsetInBits">
            <summary>Gets the storage offset of the type in bits</summary>
            <remarks>This provides the bit offset for a bit field and is <see langword="null"/>
            if <see cref="F:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags.BitField"/> is not set in <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags"/>
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIDerivedType.Constant">
            <summary>Gets the constant for a static member</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DIDerivedType.#ctor(Ubiquity.NET.Llvm.Interop.LLVMMetadataRef)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIDerivedType"/> class from an <see cref="T:Ubiquity.NET.Llvm.Interop.LLVMMetadataRef"/></summary>
            <param name="handle">Handle to wrap</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIEnumerator">
            <summary>Debug Information for a name value par of an enumerated type</summary>
            <seealso href="xref:llvm_langref#dienumerator">LLVM DIEnumerator</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIEnumerator.Name">
            <summary>Gets the Name of the enumerated value</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DIEnumerator.#ctor(Ubiquity.NET.Llvm.Interop.LLVMMetadataRef)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIEnumerator"/> class from an LLVM handle</summary>
            <param name="handle">Native LLVM reference for an enumerator</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIExpression">
            <summary>Debug information expression</summary>
            <seealso href="xref:llvm_langref#diexpression">LLVM DIExpression</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIFile">
            <summary>Debug information for a source file</summary>
            <seealso href="xref:llvm_langref#difile">LLVM DIFile</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIFile.FileName">
            <summary>Gets the file name for this file</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIFile.Directory">
            <summary>Gets the Directory for this file</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIFile.Source">
            <summary>Gets the source of the file or an empty string if not available</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIFile.CheckSum">
            <summary>Gets the Checksum for this file</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIFile.Path">
            <summary>Gets the full path for this file</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariable">
            <summary>Debug information for a global variable</summary>
            <seealso href="xref:llvm_langref#diglobalvariable">LLVM DIGlobalVariable</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariable.DisplayName">
            <summary>Gets the display name for the variable</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariable.LinkageName">
            <summary>Gets the linkage name for the variable</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariable.StaticDataMemberDeclaration">
            <summary>Gets the static data member declaration for the variable</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariableExpression">
            <summary>Debug Global variable expression</summary>
            <remarks>This node binds a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariable"/> and a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIExpression"/></remarks>
            <seealso href="xref:llvm_langref#diglobalvariable">LLVM DIGlobalVariable</seealso>
            <seealso href="xref:llvm_langref#diexpression">LLVM DIExpression</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariableExpression.Variable">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariable"/> for this node</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariableExpression.Expression">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIExpression"/> for this node</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariableExpressionArray">
            <summary>Array of <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariableExpression"/> debug information nodes for use with <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/> methods</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIImportedEntity">
            <summary>Debug information from an imported entity</summary>
            <seealso href="xref:llvm_langref#diimportedentity">LLVM DIImportedEntity</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIImportedEntity.Scope">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIScope"/> for the imported entity</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIImportedEntity.Entity">
            <summary>Gets the entity imported</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIImportedEntity.Name">
            <summary>Gets the name of the node</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIImportedEntity.File">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIFile"/> for the imported entity</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIImportedEntityArray">
            <summary>Array of <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIImportedEntity"/> debug information nodes for use with <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/> methods</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DILexicalBlock">
            <summary>Debug information for a Lexical block</summary>
            <seealso href="xref:llvm_langref#dilexicalblock">LLVM DILexicalBlock</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DILexicalBlockBase">
            <summary>Base for lexical blocks</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DILexicalBlockFile">
            <summary>Debug information for a file lexical block</summary>
            <seealso href="xref:llvm_langref#dilexicalblockfile">LLVM DILexicalBlockBase</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DILocalScope">
            <summary>Legal scope for lexical blocks, local variables, and debug info locations</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DILocalScope.LocalScope">
            <summary>Gets the parent scope as a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalScope"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DILocalScope.SubProgram">
            <summary>Gets the DISubprogram for this scope</summary>
            <remarks>If this scope is a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/> then it is returned, otherwise
            the scope is walked up to find the subprogram that ultimately owns this scope</remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DILocalScope.FirstNonLexicalBlockFileScope">
            <summary>Gets the first non-<see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILexicalBlockFile"/> scope in the chain of parent scopes</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable">
            <summary>Debug information for a local variable</summary>
            <seealso href="xref:llvm_langref#dilocalvariable">LLVM DILocalVariable</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable.Scope">
            <summary>Gets the local scope containing this variable</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariableArray">
            <summary>Array of <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalVariable"/> nodes for use with see <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/> methods</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DILocation">
            <summary>Debug source location information</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DILocation.#ctor(Ubiquity.NET.Llvm.Context,System.UInt32,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DILocalScope)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocation"/> class.</summary>
            <param name="context">Context that owns this location</param>
            <param name="line">line number for the location</param>
            <param name="column">Column number for the location</param>
            <param name="scope">Containing scope for the location</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DILocation.#ctor(Ubiquity.NET.Llvm.Context,System.UInt32,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DILocalScope,Ubiquity.NET.Llvm.DebugInfo.DILocation)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocation"/> class.</summary>
            <param name="context">Context that owns this location</param>
            <param name="line">line number for the location</param>
            <param name="column">Column number for the location</param>
            <param name="scope">Containing scope for the location</param>
            <param name="inlinedAt">Scope where this scope is inlined at/into</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DILocation.Scope">
            <summary>Gets the scope for this location</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DILocation.Line">
            <summary>Gets the line for this location</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DILocation.Column">
            <summary>Gets the column for this location</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DILocation.InlinedAt">
            <summary>Gets the location this location is inlined at</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DILocation.InlinedAtScope">
            <summary>Gets the scope where this is inlined.</summary>
            <remarks>
            This walks through the <see cref="P:Ubiquity.NET.Llvm.DebugInfo.DILocation.InlinedAt"/> properties to return
            a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalScope"/> from the deepest location.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DILocation.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIMacro">
            <summary>Pre-Processor macro</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIMacro.Name">
            <summary>Gets the name of the macro</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIMacro.Value">
            <summary>Gets the value of the property</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIMacroFile">
            <summary>Macro file included by a unit</summary>
            <remarks>
            A macro file is collection of macros and the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIFile"/>
            that they are all defined in. Essentially this is used to establish
            a many to one relation mapping between the macros and the DIFile that
            they are used in.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIMacroFile.File">
            <summary>Gets the file information for this macro file</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIMacroFile.Elements">
            <summary>Gets the elements of this macro file</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIMacroNode">
            <summary>Base class for macro related nodes in the debug hierarchy</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIMacroNodeArray">
            <summary>Array of <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIMacroNode"/> debug information nodes for use with <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/> methods</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIModule">
            <summary>A source module that is imported by a compile unit</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIModule.Scope">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIModule.Name">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIModule.ConfigurationMacros">
            <summary>Gets the configuration macros for the module</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIModule.IncludePath">
            <summary>Gets the include path for the module</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIModule.SysRoot">
            <summary>Gets the ISysRoot for the module</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DINamespace">
            <summary>Debug information namespace scope</summary>
            <seealso href="xref:llvm_langref#dinamespace"/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DINamespace.Scope">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DINamespace.Name">
            <inheritdoc/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DINode">
            <summary>Root of the object hierarchy for Debug information metadata nodes</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DINode.Tag">
            <summary>Gets the Dwarf tag for the node</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DINodeArray">
            <summary>Array of <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DINode"/> debug information nodes for use with <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/> methods</summary>
            <seealso cref="M:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder.GetOrCreateArray(System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.DebugInfo.DINode})"/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIObjCProperty">
            <summary>Objective-C Property</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIObjCProperty.File">
            <summary>Gets the Debug information for the file containing this property</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIObjCProperty.Name">
            <summary>Gets the name of the property</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIObjCProperty.GetterName">
            <summary>Gets the name of the getter method for the property</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIObjCProperty.SetterName">
            <summary>Gets the name of the setter method for the property</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIObjCProperty.Type">
            <summary>Gets the type of the property</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIScope">
            <summary>Base class for all Debug information scopes</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIScope.File">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIFile"/> describing the file this scope belongs to</summary>
            <remarks>If this scope is a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIFile"/> then this returns <see langword="this"/></remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIScope.Scope">
            <summary>Gets the parent scope for this scope or <see langword="null"/> if no parent scope exists</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIScope.Name">
            <summary>Gets the name of the scope or an empty string if the scope doesn't have a name</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIScopeArray">
            <summary>Array of <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIScope"/> debug information nodes for use with <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/> methods</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram">
            <summary>Debug information for a SubProgram</summary>
            <seealso href="xref:llvm_langref#disubprogram"/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubProgram.Line">
            <summary>Gets the source line associated with this <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubProgram.Name">
            <summary>Gets the name of this <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubProgram.LinkageName">
            <summary>Gets the linkage name of this <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubProgram.Signature">
            <summary>Gets the signature of this <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubProgram.CompileUnit">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit"/> that contains this <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubProgram.Declaration">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/> that declares this <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubProgram.Variables">
            <summary>Gets the variables of this <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubProgram.ContainingType">
            <summary>Gets the type that contains this <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/>, if any</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubProgram.TemplateParams">
            <summary>Gets the template parameters of this <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/>, if any</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubProgram.ThrownTypes">
            <summary>Gets the exception types this <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/> can throw</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DISubProgram.Describes(Ubiquity.NET.Llvm.Values.IrFunction)">
            <summary>Determines if this instance describes a given <see cref="T:Ubiquity.NET.Llvm.Values.IrFunction"/></summary>
            <param name="function"><see cref="T:Ubiquity.NET.Llvm.Values.IrFunction"/> to test</param>
            <returns><see langword="true"/> if this <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DISubProgram"/> describes <paramref name="function"/> </returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DISubRange">
            <summary>Sub range</summary>
            <seealso href="xref:llvm_langref#disubrange">LLVM DISubRange</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubRange.LowerBound">
            <summary>Gets a value for the lower bound of the range</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubRange.ConstantCount">
            <summary>Gets a, potentially null, constant value for the count of the subrange</summary>
            <remarks>
            Count (length) of a DISubrange is either a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/>
            wrapped in a <see cref="T:Ubiquity.NET.Llvm.ConstantAsMetadata"/> or it is a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIVariable"/>. This property
            extracts the count as a constant integral value (if present). If this is <see langword="null"/>
            then <see cref="P:Ubiquity.NET.Llvm.DebugInfo.DISubRange.VariableCount"/> is not. (and vice versa)
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubRange.VariableCount">
            <summary>Gets a, potentially null, <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIVariable"/> for the count of the subrange</summary>
            <remarks>
            Count (length) of a DISubrange is either a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantInt"/>
            wrapped in a <see cref="T:Ubiquity.NET.Llvm.ConstantAsMetadata"/> or it is a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIVariable"/>. This property
            extracts the count as a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIVariable"/> value (if present). If this is <see langword="null"/>
            then <see cref="P:Ubiquity.NET.Llvm.DebugInfo.DISubRange.ConstantCount"/> is not. (and vice versa)
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DISubroutineType">
            <summary>Debug information for a function signature</summary>
            <seealso href="xref:llvm_langref#disubroutinetype"/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DISubroutineType.TypeArray">
            <summary>Gets the types for the sub routine</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DITemplateParameter">
            <summary>Base class for template parameter information</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.DebugInfo.DITemplateTypeParameter"/>
            <seealso cref="T:Ubiquity.NET.Llvm.DebugInfo.DITemplateValueParameter"/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DITemplateParameter.Name">
            <summary>Gets the name of the template parameter</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DITemplateParameter.Type">
            <summary>Gets the type of the template parameter</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DITemplateParameterArray">
            <summary>Array of <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DITemplateParameter"/> nodes for use with see <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/> methods</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DITemplateTypeParameter">
            <summary>Template type parameter</summary>
            <seealso href="xref:llvm_langref#ditemplatetypeparameter">LLVM DITemplateTypeParameter</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DITemplateValueParameter">
            <summary>Template Value parameter</summary>
            <seealso href="xref:llvm_langref#ditemplatevalueparameter">LLVM DITemplateValueParameter</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.DITemplateValueParameter.GetValue``1">
            <summary>Gets the value of the parameter as Metadata</summary>
            <typeparam name="T">Metadata type of the value to get</typeparam>
            <returns>Value or <see langword="null"/> if the value is not convertible to <typeparamref name="T"/></returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIType">
            <summary>Base class for Debug info types</summary>
            <seealso href="xref:llvm_langref#ditype">LLVM DIType</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIType.Scope">
            <summary>Gets the containing scope for the type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIType.Name">
            <summary>Gets the name of the type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIType.Line">
            <summary>Gets the source line for the type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIType.BitSize">
            <summary>Gets the size of the type in bits</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIType.BitAlignment">
            <summary>Gets the alignment of the type in bits</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIType.BitOffset">
            <summary>Gets the offset of the type in bits</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIType.DebugInfoFlags">
            <summary>Gets the flags that describe the behaviors for</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DITypeArray">
            <summary>Array of <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIType"/> nodes for use with see <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoBuilder"/> methods</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DIVariable">
            <summary>Debug information for a variable</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIVariable.Line">
            <summary>Gets the line for the variable</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIVariable.Scope">
            <summary>Gets the Debug information scope for this variable</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIVariable.Name">
            <summary>Gets the Debug information name for this variable</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIVariable.File">
            <summary>Gets the Debug information file for this variable</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.DIVariable.DIType">
            <summary>Gets the Debug information type for this variable</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.SourceLanguage">
            <summary>DWARF Debug information language</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DebugInfo.SourceLanguage.Invalid">
            <summary>Invalid language</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DebugInfo.SourceLanguage.UserMin">
            <summary>Base value for unofficial languages ids</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DebugInfo.SourceLanguage.CSharp">
            <summary>[Ubiquity.NET.Llvm] C# Language</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DebugInfo.SourceLanguage.ILAsm">
            <summary>[Ubiquity.NET.Llvm] .NET IL Assembly language (ILAsm)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DebugInfo.SourceLanguage.UserMax">
            <summary>Max Value for unofficial language ids</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.Tag">
            <summary>Tag kind for the debug information discriminated union nodes</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.QualifiedTypeTag">
            <summary>Tags for qualified types</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DiTypeKind">
            <summary>Primitive type supported by the debug information</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.DebugInfoFlags">
            <summary>Debug information flags</summary>
            <remarks>
            The three accessibility flags are mutually exclusive and rolled together
            in the first two bits.
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.ExpressionOp">
            <summary>Debug information expression operator</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.GenericDINode">
            <summary>Generic tagged DWARF-like Metadata node</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.GenericDINode.Header">
            <summary>Gets the header for this node</summary>
            <remarks>
            The header is a, possibly empty, null separated string
            header that contains arbitrary fields.
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DebugInfo.TupleTypedArrayWrapper`1">
            <summary>Generic wrapper to treat an MDTuple as an array of elements of specific type</summary>
            <typeparam name="T">Type of elements</typeparam>
            <remarks>
            This implements a facade pattern that presents an <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> for the
            operands of an <see cref="T:Ubiquity.NET.Llvm.MDTuple"/>. This allows treating the tuple like an array of nodes of a
            particular type.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.TupleTypedArrayWrapper`1.Tuple">
            <summary>Gets the underlying tuple for this wrapper</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.TupleTypedArrayWrapper`1.Count">
            <summary>Gets the count of operands in the <see cref="T:Ubiquity.NET.Llvm.MDTuple"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.DebugInfo.TupleTypedArrayWrapper`1.Item(System.Int32)">
            <summary>Gets an item from the tuple</summary>
            <param name="index">Index of the item to retrieve</param>
            <returns>The element at <paramref name="index"/> in the tuple</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.TupleTypedArrayWrapper`1.GetEnumerator">
            <summary>Gets an enumerator for the items in the <see cref="T:Ubiquity.NET.Llvm.MDTuple"/></summary>
            <returns>Enumerator</returns>
            <remarks>If the underlying tuple is empty this is an empty enumeration</remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.DebugInfo.TupleTypedArrayWrapper`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets an enumerator for the items in the <see cref="T:Ubiquity.NET.Llvm.MDTuple"/></summary>
            <returns>Enumerator</returns>
            <remarks>If the underlying tuple is empty this is an empty enumeration</remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.DisassemblerOptions">
            <summary>Options flags for the disassembler</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DisassemblerOptions.None">
            <summary>No options</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DisassemblerOptions.UseMarkup">
            <summary>Produce marked up assembly</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DisassemblerOptions.ImmediatesAsHex">
            <summary>Print immediate as HEX</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DisassemblerOptions.AsmPrinterVariant">
            <summary>Use the alternate assembly printer variant</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DisassemblerOptions.InstructionComments">
            <summary>Set comments on instructions</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.DisassemblerOptions.PrintLatency">
            <summary>Print latency information alongside instructions</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Disassembler">
            <summary>Dis-assembler</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Disassembler.#ctor(Ubiquity.NET.Llvm.Triple,System.IntPtr,System.Int32,Ubiquity.NET.Llvm.Interop.LLVMOpInfoCallback,Ubiquity.NET.Llvm.Interop.LLVMSymbolLookupCallback)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.Disassembler"/> class.</summary>
            <param name="triple">Triple for the instruction set to disassemble</param>
            <param name="disInfo">Context value passed to <paramref name="infoCallBack"/></param>
            <param name="tagType">TODO:Explain this...</param>
            <param name="infoCallBack">Op info callback</param>
            <param name="symbolLookup">Symbol lookup delegate</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Disassembler.#ctor(Ubiquity.NET.Llvm.Triple,System.String,System.IntPtr,System.Int32,Ubiquity.NET.Llvm.Interop.LLVMOpInfoCallback,Ubiquity.NET.Llvm.Interop.LLVMSymbolLookupCallback)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.Disassembler"/> class.</summary>
            <param name="triple">Triple for the instruction set to disassemble</param>
            <param name="cpu">CPU string for the instruction set</param>
            <param name="disInfo">Context value passed to <paramref name="infoCallBack"/></param>
            <param name="tagType">TODO:Explain this...</param>
            <param name="infoCallBack">Op info callback</param>
            <param name="symbolLookup">Symbol lookup delegate</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Disassembler.#ctor(Ubiquity.NET.Llvm.Triple,System.String,System.String,System.IntPtr,System.Int32,Ubiquity.NET.Llvm.Interop.LLVMOpInfoCallback,Ubiquity.NET.Llvm.Interop.LLVMSymbolLookupCallback)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.Disassembler"/> class.</summary>
            <param name="triple">Triple for the instruction set to disassemble</param>
            <param name="cpu">CPU string for the instruction set</param>
            <param name="features">CPU features for disassembling the instruction set</param>
            <param name="disInfo">Context value passed to <paramref name="infoCallBack"/></param>
            <param name="tagType">TODO:Explain this...</param>
            <param name="infoCallBack">Op info callback</param>
            <param name="symbolLookup">Symbol lookup delegate</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Disassembler.SetOptions(Ubiquity.NET.Llvm.DisassemblerOptions)">
            <summary>Set the options for the disassembly</summary>
            <param name="options">Options</param>
            <returns><see langword="true"/> if the options are all supported</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Disassembler.Disassemble(System.ReadOnlySpan{System.Byte},System.UInt64,System.Int32)">
            <summary>Disassembles an instruction</summary>
            <param name="instruction">Start of instruction stream</param>
            <param name="pc">Program counter address to assume for the instruction disassembly</param>
            <param name="stringBufferSize">Size of string buffer to use for the disassembly (default=1024)</param>
            <returns>Disassembly string and count of bytes in the instruction as a tuple</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.EnumerableExtensions">
            <summary>This is an internal duplicate of Extensions added to CoreFx.</summary>
            <remarks>
            This is duped here to enable use in down-level run-times. Furthermore, it uses a different
            name and is marked internal to prevent conflicts with the official implementation when
            built for run-times supporting that. (See: https://github.com/dotnet/corefx/pull/5947)
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ExtensiblePropertyContainer">
            <summary>Common implementation of <see cref="T:Ubiquity.NET.Llvm.IExtensiblePropertyContainer"/></summary>
            <remarks>
            This class implements <see cref="T:Ubiquity.NET.Llvm.IExtensiblePropertyContainer"/> through an
            internal <see cref="T:System.Collections.Generic.Dictionary`2"/>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ExtensiblePropertyContainer.AddExtendedPropertyValue(System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ExtensiblePropertyContainer.TryGetExtendedPropertyValue``1(System.String,``0@)">
            <inheritdoc/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ExtensiblePropertyDescriptor`1">
            <summary>Provides consistent accessors for an extended property</summary>
            <typeparam name="T">Type of values stored in the property</typeparam>
            <remarks>
            This class is used to describe a property stored in a class implementing
            <see cref="T:Ubiquity.NET.Llvm.IExtensiblePropertyContainer"/>. Using a single, typically
            <see langword="static"/>, instance of this class to describe and access
            an extended property helps to encapsulate the type casting and property
            ID into a single place. Making calling code easier to comprehend and
            less prone to typographical errors that a compiler can't catch ahead of
            time.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ExtensiblePropertyDescriptor`1.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.ExtensiblePropertyDescriptor`1"/> class.</summary>
            <param name="name">Name of the extended property</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ExtensiblePropertyDescriptor`1.GetValueFrom(Ubiquity.NET.Llvm.IExtensiblePropertyContainer)">
            <summary>Gets a value for the property from the container</summary>
            <param name="container">container</param>
            <returns>Value retrieved from the property or the default value of type <typeparamref name="T"/></returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ExtensiblePropertyDescriptor`1.LazyDefaultFactory">
            <summary>Default value factory for a property in the container</summary>
            <returns>Default value for the property, <see langword="null"/> is allowed as the return for nullable types</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ExtensiblePropertyDescriptor`1.GetValueFrom(Ubiquity.NET.Llvm.IExtensiblePropertyContainer,`0)">
            <summary>Gets a value for the property from the container</summary>
            <param name="container">container</param>
            <param name="defaultValue">default value if the value is not yet present as an extended property</param>
            <returns>Value retrieved from the property or <paramref name="defaultValue"/> if it wasn't found</returns>
            <remarks>If the value didn't exist a new value with <paramref name="defaultValue"/> is added to the container</remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ExtensiblePropertyDescriptor`1.GetValueFrom(Ubiquity.NET.Llvm.IExtensiblePropertyContainer,Ubiquity.NET.Llvm.ExtensiblePropertyDescriptor{`0}.LazyDefaultFactory)">
            <summary>Gets a value for the property from the container</summary>
            <param name="container">container</param>
            <param name="lazyDefaultFactory">default value factory delegate to create the default value if the value is not yet present as an extended property</param>
            <returns>Value retrieved from the property or default value created by <paramref name="lazyDefaultFactory"/> if it wasn't found</returns>
            <remarks>If the value didn't exist a new value created by calling with <paramref name="lazyDefaultFactory"/> is added to the container</remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ExtensiblePropertyDescriptor`1.SetValueIn(Ubiquity.NET.Llvm.IExtensiblePropertyContainer,`0)">
            <summary>Sets the value of an extended property in a container</summary>
            <param name="container">Container to set the value in</param>
            <param name="value">value of the property</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ExtensiblePropertyDescriptor`1.Name">
            <summary>Gets the name of the property</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.IBitcodeModuleFactory">
            <summary>Interface for a <see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/> factory</summary>
            <remarks>
            Modules are owned by the context and thus not created freestanding.
            This interface provides factory methods for constructing modules. It
            is implemented by the <see cref="T:Ubiquity.NET.Llvm.Context"/> and also internally by
            the handle caches that ultimately call the underlying LLVM module
            creation APIs.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.IBitcodeModuleFactory.CreateBitcodeModule">
            <summary>Creates a new instance of the <see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/> class in this context</summary>
            <returns><see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.IBitcodeModuleFactory.CreateBitcodeModule(System.String)">
            <summary>Creates a new instance of the <see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/> class in a given context</summary>
            <param name="moduleId">Module's ID</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.IBitcodeModuleFactory.CreateBitcodeModule(System.String,Ubiquity.NET.Llvm.DebugInfo.SourceLanguage,System.String,System.String,System.Boolean,System.String,System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/> class with a root <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DICompileUnit"/> to contain debugging information</summary>
            <param name="moduleId">Module name</param>
            <param name="language">Language to store in the debugging information</param>
            <param name="srcFilePath">path of source file to set for the compilation unit</param>
            <param name="producer">Name of the application producing this module</param>
            <param name="optimized">Flag to indicate if the module is optimized</param>
            <param name="compilationFlags">Additional flags (use <see cref="F:System.String.Empty"/> if none are needed)</param>
            <param name="runtimeVersion">Runtime version if any (use 0 if the runtime version has no meaning)</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/></returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.IExtensiblePropertyContainer">
            <summary>Interface to allow adding arbitrary named data items to an object</summary>
            <remarks>
            It is sometimes useful for code generation applications to attach some tool specific
            data to the LLVM objects created but that don't need representation as LLVM Metadata
            nodes. This interface provides such a facility.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.IExtensiblePropertyContainer.TryGetExtendedPropertyValue``1(System.String,``0@)">
            <summary>Try to get a value from the container</summary>
            <typeparam name="T">Type of value to retrieve</typeparam>
            <param name="id">id of the value to retrieve</param>
            <param name="value">value retrieved if present (or default value of type <typeparamref name="T"/> otherwise)</param>
            <returns>
            true if the item was found and it's type matches <typeparamref name="T"/> false otherwise.
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.IExtensiblePropertyContainer.AddExtendedPropertyValue(System.String,System.Object)">
            <summary>Adds a value to the container</summary>
            <param name="id">Id of the value</param>
            <param name="value">value to add</param>
            <remarks>
            Adds the value with the specified id. If a value with the same id
            already exists and its type is the same as <paramref name="value"/>
            it is replaced. If the existing value is of a different type, then
            an ArgumentException is thrown.
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.AddressSpaceCast">
            <summary>Address space cast instruction</summary>
            <seealso href="xref:llvm_langref#addrspaceast-to-instruction">LLVM addrspacecast .. to</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Alloca">
            <summary>Alloca instruction for allocating stack space</summary>
            <remarks>
            LLVM Mem2Reg pass will convert alloca locations to register for the
            entry block to the maximum extent possible.
            </remarks>
            <seealso href="xref:llvm_langref#alloca-instruction">LLVM alloca</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Alloca.ElementType">
            <summary>Gets the type of the alloca element</summary>
            <remarks>
            The <see cref="P:Ubiquity.NET.Llvm.Values.Value.NativeType"/> of an <see cref="T:Ubiquity.NET.Llvm.Instructions.Alloca"/>
            is always a pointer type, this provides the ElementType (e.g. the pointee type)
            for the alloca.
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.AtomicCmpXchg">
            <summary>Atomic Compare and Exchange instruction</summary>
            <seealso href="xref:llvm_langref#cmpxchg-instruction">LLVM cmpxchg instruction</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.AtomicCmpXchg.IsWeak">
            <summary>Gets or sets a value indicating whether this instruction is weak or not</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp">
            <summary>Atomic Read-Modify-Write operation</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp.Xchg">
            <summary>Exchange operation</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp.Add">
            <summary>Integer addition operation</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp.Sub">
            <summary>Integer subtraction</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp.And">
            <summary>Bitwise AND</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp.Nand">
            <summary>Bitwise NAND</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp.Or">
            <summary>Bitwise OR</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp.Xor">
            <summary>Bitwise XOR</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp.Max">
            <summary>Max</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp.Min">
            <summary>Min</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp.UMax">
            <summary>Unsigned Max</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp.UMin">
            <summary>Unsigned Min</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp.FAdd">
            <summary>Floating point addition</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.AtomicRMWBinOp.FSub">
            <summary>Floating point subtraction</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW">
            <summary>Atomic Read-Modify-Write instruction</summary>
            <seealso href="xref:llvm_langref#atomicrmw-instruction">LLVM atomicrmw instruction</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.AtomicRMW.Kind">
            <summary>Gets or sets the kind of atomic operation for this instruction</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator">
            <summary>Base class for a binary operator</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.BitCast">
            <summary>This class represents a no-op cast from one type to another</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Branch">
            <summary>Branch instruction</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Branch.IsConditional">
            <summary>Gets a value indicating whether this branch is conditional</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Branch.Condition">
            <summary>Gets the condition for the branch, if any</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.CallBr">
            <summary>CallBr instruction</summary>
            <seealso href="xref:llvm_langref#i-callbr"/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CallBr.TargetFunction">
            <summary>Gets the target function of the call</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CallBr.Attributes">
            <summary>Gets the attributes for this call site</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallBr.AddAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeValue)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallBr.GetAttributeCountAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallBr.GetAttributesAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallBr.GetAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeKind)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallBr.GetAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallBr.RemoveAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeKind)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallBr.RemoveAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.CallInstruction">
            <summary>Call instruction</summary>
            <seealso href="xref:llvm_langref#call-instruction"/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CallInstruction.TargetFunction">
            <summary>Gets the target function of the call</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CallInstruction.IsTailCall">
            <summary>Gets or sets a value indicating whether the call is a tail call</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CallInstruction.Attributes">
            <summary>Gets the attributes for this call site</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallInstruction.AddAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeValue)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallInstruction.GetAttributeCountAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallInstruction.GetAttributesAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallInstruction.GetAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeKind)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallInstruction.GetAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallInstruction.RemoveAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeKind)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.CallInstruction.RemoveAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Cast">
            <summary>Base class for cast instructions</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Cast.FromType">
            <summary>Gets the source type of the cast</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Cast.ToType">
            <summary>Gets the destination type of the cast</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.CatchPad">
            <summary>Marks a <see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> as a catch handler</summary>
            <remarks>
            Like the <see cref="T:Ubiquity.NET.Llvm.Instructions.LandingPad"/>, instruction this must be the first non-phi instruction
            in the block.
            </remarks>
            <seealso href="xref:llvm_langref#catchpad-instruction">LLVM catchpad Instruction</seealso>
            <seealso href="xref:llvm_exception_handling#exception-handling-in-llvm">Exception Handling in LLVM</seealso>
            <seealso href="xref:llvm_exception_handling#wineh">Exception Handling using the Windows Runtime</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CatchPad.CatchSwitch">
            <summary>Gets or sets the <seealso cref="T:Ubiquity.NET.Llvm.Instructions.CatchSwitch"/> for this pad</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.CatchReturn">
            <summary>Catch return instruction</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CatchReturn.CatchPad">
            <summary>Gets the <see cref="P:Ubiquity.NET.Llvm.Instructions.CatchReturn.CatchPad"/> instruction associated with this <see cref="T:Ubiquity.NET.Llvm.Instructions.CatchReturn"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CatchReturn.CatchSwitchParentPad">
            <summary>Gets the <see cref="P:Ubiquity.NET.Llvm.Instructions.CatchSwitch.ParentPad"/> property from the <see cref="P:Ubiquity.NET.Llvm.Instructions.CatchPad.CatchSwitch"/>
            of the <see cref="P:Ubiquity.NET.Llvm.Instructions.CatchReturn.CatchPad"/> property</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.CatchSwitch">
            <summary>Describes the set of possible catch handlers that may be executed by an
            <see href="xref:llvm_langref#personalityfn">EH personality routine</see></summary>
            <seealso href="xref:llvm_langref#i-catchswitch">LLVM catchswitch instruction</seealso>
            <seealso href="xref:llvm_exception_handling#exception-handling-in-llvm">Exception Handling in LLVM</seealso>
            <seealso href="xref:llvm_exception_handling#wineh">Exception Handling using the Windows Runtime</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CatchSwitch.ParentPad">
            <summary>Gets or sets the Parent pad for this <see cref="T:Ubiquity.NET.Llvm.Instructions.CatchSwitch"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CatchSwitch.HasUnwindDestination">
            <summary>Gets a value indicating whether this <see cref="T:Ubiquity.NET.Llvm.Instructions.CatchSwitch"/> has an unwind destination</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CatchSwitch.UnwindsToCaller">
            <summary>Gets a value indicating whether this <see cref="T:Ubiquity.NET.Llvm.Instructions.CatchSwitch"/> unwinds to the caller</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CatchSwitch.UnwindDestination">
            <summary>Gets or sets the Unwind destination for this <see cref="T:Ubiquity.NET.Llvm.Instructions.CatchSwitch"/></summary>
            <remarks>
            While retrieving the destination may return null, setting with null will generate
            an exception. In particular if <see cref="P:Ubiquity.NET.Llvm.Instructions.CatchSwitch.HasUnwindDestination"/> is <see langword="false"/>
            then the UnwindDestination is <see langword="null"/>.
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.CleanupPad">
            <summary>Specifies that a <see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> is a cleanup block</summary>
            <seealso href="xref:llvm_langref#i-cleanuppad">LLVM cleanuppad instruction</seealso>
            <seealso href="xref:llvm_exception_handling#exception-handling-in-llvm">Exception Handling in LLVM</seealso>
            <seealso href="xref:llvm_exception_handling#wineh">Exception Handling using the Windows Runtime</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.CleanupReturn">
            <summary>Instruction that indicates to the personality function that one <see cref="P:Ubiquity.NET.Llvm.Instructions.CleanupReturn.CleanupPad"/> it transferred control to has ended</summary>
            <seealso href="xref:llvm_langref#cleanupret-instruction">LLVM cleanupret instruction</seealso>
            <seealso href="xref:llvm_exception_handling#exception-handling-in-llvm">Exception Handling in LLVM</seealso>
            <seealso href="xref:llvm_exception_handling#wineh">Exception Handling using the Windows Runtime</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CleanupReturn.CleanupPad">
            <summary>Gets or sets the <see cref="P:Ubiquity.NET.Llvm.Instructions.CleanupReturn.CleanupPad"/> for this instruction</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CleanupReturn.HasUnwindDestination">
            <summary>Gets a value indicating whether this <see cref="T:Ubiquity.NET.Llvm.Instructions.CatchSwitch"/> has an unwind destination</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CleanupReturn.UnwindsToCaller">
            <summary>Gets a value indicating whether this <see cref="T:Ubiquity.NET.Llvm.Instructions.CatchSwitch"/> unwinds to the caller</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.CleanupReturn.UnwindDestination">
            <summary>Gets or sets the Unwind destination for this <see cref="T:Ubiquity.NET.Llvm.Instructions.CatchSwitch"/></summary>
            <remarks>
            While retrieving the destination may return null, setting with null will generate
            an exception. In particular if <see cref="P:Ubiquity.NET.Llvm.Instructions.CleanupReturn.HasUnwindDestination"/> is <see langword="false"/>
            then the UnwindDestination is <see langword="null"/>.
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Cmp">
            <summary>Base class for compare instructions</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Cmp.Predicate">
            <summary>Gets the predicate for the comparison</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.DebugDeclare">
            <summary>Intrinsic LLVM IR instruction to declare Debug information for a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></summary>
            <seealso href="xref:llvm_sourcelevel_debugging#llvm-dbg-declare">llvm.dbg.declare</seealso>
            <seealso href="xref:llvm_sourcelevel_debugging">LLVM Source Level Debugging</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.DebugInfoIntrinsic">
            <summary>Base class for debug information intrinsic functions in LLVM IR</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.ExtractElement">
            <summary>Instruction to extract a single scalar element from a vector at a specified index.</summary>
            <seealso href="xref:llvm_langref#extractelement-instruction">LLVM extractelement Instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.ExtractValue">
            <summary>Instruction to extract the value of a member field from an aggregate value</summary>
            <seealso href="xref:llvm_langref#extractvalue-instruction">LLVM extractvalue Instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.FCmp">
            <summary>Instruction to perform comparison of floating point values</summary>
            <seealso href="xref:llvm_langref#fcmp-instruction">LLVM fcmp Instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Fence">
            <summary>Synchronization instruction to introduce "happens-before" edges between operations</summary>
            <seealso href="xref:llvm_langref#fence-instruction">LLVM fence Instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.FPExt">
            <summary>Extends a floating point value to a larger floating point value</summary>
            <seealso href="xref:llvm_langref#fpext-to-instruction">LLVM fpext .. to instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.FPToSI">
            <summary>Instruction to convert a floating point value to a signed integer type</summary>
            <seealso href="xref:llvm_langref#fptosi-to-instruction">LLVM fptosi .. to Instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.FPToUI">
            <summary>Instruction to convert a floating point value to an unsigned integer type</summary>
            <seealso href="xref:llvm_langref#fptoui-to-instruction">LLVM fptoui .. to Instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.FPTrunc">
            <summary>Instruction to truncate a floating point value to another floating point type</summary>
            <seealso href="xref:llvm_langref#fptruncto-to-instruction">LLVM fptruncto .. to Instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Freeze">
            <summary>Freeze a poison or undef value</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Freeze.Value">
            <summary>Gets the value this instruction freezes</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.FuncletPad">
            <summary>Funclet pad for exception handling</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.FuncletPad.ParentPad">
            <summary>Gets the outer EH-pad this funclet is nested withing</summary>
            <remarks>
            <note type="note">This returns the associated <see cref="T:Ubiquity.NET.Llvm.Instructions.CatchSwitch"/> if this
            <see cref="T:Ubiquity.NET.Llvm.Instructions.FuncletPad"/> is a <see cref="T:Ubiquity.NET.Llvm.Instructions.CleanupPad"/> instruction.</note>
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.FuncletPad.ArgOperands">
            <summary>Gets the argument operands for this <see cref="T:Ubiquity.NET.Llvm.Instructions.FuncletPad"/>.</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.GetElementPtr">
            <summary>Instruction to compute the address of a sub element of an aggregate data type</summary>
            <seealso href="xref:llvm_langref#getelementptr-instruction">LLVM getelementptr Instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.IndirectBranch">
            <summary>Instruction to perform an indirect branch to a block within the current function</summary>
            <remarks>The address of the branch must come from a <see cref="T:Ubiquity.NET.Llvm.Values.BlockAddress"/> constant</remarks>
            <seealso href="xref:llvm_langref#indirectbr-instruction">LLVM indirectbr Instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.InsertElement">
            <summary>Instruction to insert an element into a vector type</summary>
            <seealso href="xref:llvm_langref#insertelement-instruction">LLVM insertelement Instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.InsertValue">
            <summary>Instruction to insert a value into a member field in an aggregate value</summary>
            <seealso href="xref:llvm_langref#insertvalue-instruction">LLVM insertvalue Instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.OpCode">
            <summary>LLVM Instruction opcodes</summary>
            <remarks>
            These are based on the "C" API and therefore more stable as changes in the underlying instruction ids are remapped in the C API layer
            </remarks>
            <seealso href="xref:llvm_langref#instruction-reference">LLVM instruction Reference</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Invalid">
            <summary>Invalid or unknown instruction</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Return">
            <summary>Return instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.ReturnInstruction"/>
            <seealso href="xref:llvm_langref#ret-instruction">LLVM ret Instruction</seealso>
            <seealso href="xref:llvm_langref#terminator-instructions">LLVM Terminator Instructions</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Branch">
            <summary>Branch instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.Branch"/>
            <seealso href="xref:llvm_langref#br-instruction">LLVM br Instruction</seealso>
            <seealso href="xref:llvm_langref#terminator-instructions">LLVM Terminator Instructions</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Switch">
            <summary>Switch instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.Switch"/>
            <seealso href="xref:llvm_langref#switch-instruction">LLVM switch instruction</seealso>
            <seealso href="xref:llvm_langref#terminator-instructions">LLVM Terminator Instructions</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.IndirectBranch">
            <summary>Indirect branch instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.IndirectBranch"/>
            <seealso href="xref:llvm_langref#indirectbr-instruction">LLVM indirectbr instruction</seealso>
            <seealso href="xref:llvm_langref#terminator-instructions">LLVM Terminator Instructions</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Invoke">
            <summary>Invoke instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.Invoke"/>
            <seealso href="xref:llvm_langref#invoke-instruction">LLVM invoke instruction</seealso>
            <seealso href="xref:llvm_langref#terminator-instructions">LLVM Terminator Instructions</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Unreachable">
            <summary>Unreachable instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.Unreachable"/>
            <seealso href="xref:llvm_langref#unreachable-instruction">LLVM unreachable instruction</seealso>
            <seealso href="xref:llvm_langref#terminator-instructions">LLVM Terminator Instructions</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Add">
            <summary>Add instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#add-instruction">LLVM add instruction</seealso>
            <seealso href="xref:llvm_langref#binary-operations">LLVM Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.FAdd">
            <summary>FAdd instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#fadd-instruction">LLVM FAdd instruction</seealso>
            <seealso href="xref:llvm_langref#binary-operations">LLVM Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Sub">
            <summary>Sub instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#binary-operations">LLVM Binary Operations</seealso>
            <seealso href="xref:llvm_langref#sub-instruction">LLVM sub instruction</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.FSub">
            <summary>FSub instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#fsub-instruction">LLVM fsub instruction</seealso>
            <seealso href="xref:llvm_langref#binary-operations">LLVM Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Mul">
            <summary>Mul instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#mul-instruction">LLVM mul instruction</seealso>
            <seealso href="xref:llvm_langref#binary-operations">LLVM Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.FMul">
            <summary>FMul instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#fmul-instruction">LLVM fmul instruction</seealso>
            <seealso href="xref:llvm_langref#binary-operations">LLVM Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.UDiv">
            <summary>UDiv instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#udiv-instruction">LLVM udiv instruction</seealso>
            <seealso href="xref:llvm_langref#binary-operations">LLVM Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.SDiv">
            <summary>SDiv instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#sdiv-instruction">LLVM sdiv instruction</seealso>
            <seealso href="xref:llvm_langref#binary-operations">LLVM Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.FDiv">
            <summary>FDiv instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#fdiv-instruction">LLVM fdiv instruction</seealso>
            <seealso href="xref:llvm_langref#binary-operations">LLVM Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.URem">
            <summary>URem instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#urem-instruction">LLVM urem instruction</seealso>
            <seealso href="xref:llvm_langref#binary-operations">LLVM Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.SRem">
            <summary>SRem instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#srem-instruction">LLVM srem instruction</seealso>
            <seealso href="xref:llvm_langref#binary-operations">LLVM Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.FRem">
            <summary>FRem instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#frem-instruction">LLVM frem instruction</seealso>
            <seealso href="xref:llvm_langref#binary-operations">LLVM Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Shl">
            <summary>Shift Left instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#shl-instruction">LLVM shl instruction</seealso>
            <seealso href="xref:llvm_langref#bitwise-binary-operations">LLVM Bitwise Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.LShr">
            <summary>Logical Shift Right instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#lshr-instruction">LLVM lshr instruction</seealso>
            <seealso href="xref:llvm_langref#bitwise-binary-operations">LLVM Bitwise Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.AShr">
            <summary>Arithmetic Shift Right instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#ashr-instruction">LLVM ashr instruction</seealso>
            <seealso href="xref:llvm_langref#bitwise-binary-operations">LLVM Bitwise Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.And">
            <summary>Bitwise And instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#an-instruction">LLVM and instruction</seealso>
            <seealso href="xref:llvm_langref#bitwise-binary-operations">LLVM Bitwise Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Or">
            <summary>Bitwise Or instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#or-instruction">LLVM or instruction</seealso>
            <seealso href="xref:llvm_langref#bitwise-binary-operations">LLVM Bitwise Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Xor">
            <summary>Bitwise Xor instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BinaryOperator"/>
            <seealso href="xref:llvm_langref#xor-instruction">LLVM xor instruction</seealso>
            <seealso href="xref:llvm_langref#bitwise-binary-operations">LLVM Bitwise Binary Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Alloca">
            <summary>xxx instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.Alloca"/>
            <seealso href="xref:llvm_langref#alloca-instruction">LLVM alloca instruction</seealso>
            <seealso href="xref:llvm_langref#memory-access-and-addressing-operations">LLVM Memory Access and Addressing Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Load">
            <summary>Load instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.Load"/>
            <seealso href="xref:llvm_langref#load-instruction">LLVM load instruction</seealso>
            <seealso href="xref:llvm_langref#memory-access-and-addressing-operations">LLVM Memory Access and Addressing Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Store">
            <summary>Store instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.Store"/>
            <seealso href="xref:llvm_langref#store-instruction">LLVM store instruction</seealso>
            <seealso href="xref:llvm_langref#memory-access-and-addressing-operations">LLVM Memory Access and Addressing Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Fence">
            <summary>Fence instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.Fence"/>
            <seealso href="xref:llvm_langref#fence-instruction">LLVM fence instruction</seealso>
            <seealso href="xref:llvm_langref#memory-access-and-addressing-operations">LLVM Memory Access and Addressing Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.AtomicCmpXchg">
            <summary>CmpXchg instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.AtomicCmpXchg"/>
            <seealso href="xref:llvm_langref#cmpxchg-instruction">LLVM cmpxchg instruction</seealso>
            <seealso href="xref:llvm_langref#memory-access-and-addressing-operations">LLVM Memory Access and Addressing Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.AtomicRMW">
            <summary>atomicrmw instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/>
            <seealso href="xref:llvm_langref#atomicrmw-instruction">LLVM atomicrmw instruction</seealso>
            <seealso href="xref:llvm_langref#memory-access-and-addressing-operations">LLVM Memory Access and Addressing Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.GetElementPtr">
            <summary>getelementptr instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.GetElementPtr"/>
            <seealso href="xref:llvm_langref#getelementptr-instruction">LLVM getelementptr instruction</seealso>
            <seealso href="xref:llvm_langref#memory-access-and-addressing-operations">LLVM Memory Access and Addressing Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Trunc">
            <summary>trunc .. to instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.Trunc"/>
            <seealso href="xref:llvm_langref#trunc-to-instruction">LLVM trunc .. to instruction</seealso>
            <seealso href="xref:llvm_langref#conversion-operations">LLVM Conversion Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.ZeroExtend">
            <summary>zext .. to instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.ZeroExtend"/>
            <seealso href="xref:llvm_langref#zext-to-instruction">LLVM zext .. to instruction</seealso>
            <seealso href="xref:llvm_langref#conversion-operations">LLVM Conversion Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.SignExtend">
            <summary>sext .. to instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.SignExtend"/>
            <seealso href="xref:llvm_langref#sext-to-instruction">LLVM sext .. to instruction</seealso>
            <seealso href="xref:llvm_langref#conversion-operations">LLVM Conversion Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.FPToUI">
            <summary>fptoui .. to instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.FPToUI"/>
            <seealso href="xref:llvm_langref#fptoui-to-instruction">LLVM fptoui .. to instruction</seealso>
            <seealso href="xref:llvm_langref#conversion-operations">LLVM Conversion Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.FPToSI">
            <summary>fptosi .. to instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.FPToSI"/>
            <seealso href="xref:llvm_langref#fptosi-to-instruction">LLVM fptosi .. to instruction</seealso>
            <seealso href="xref:llvm_langref#conversion-operations">LLVM Conversion Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.UIToFP">
            <summary>uitofp .. to instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.UIToFP"/>
            <seealso href="xref:llvm_langref#uitofp-to-instruction">LLVM uitofp .. to instruction</seealso>
            <seealso href="xref:llvm_langref#conversion-operations">LLVM Conversion Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.SIToFP">
            <summary>sitofp .. to instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.SIToFP"/>
            <seealso href="xref:llvm_langref#sitofp-to-instruction">LLVM sitofp .. to instruction</seealso>
            <seealso href="xref:llvm_langref#conversion-operations">LLVM Conversion Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.FPTrunc">
            <summary>fptrunc .. to instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.FPTrunc"/>
            <seealso href="xref:llvm_langref#fptrunct-to-instruction">LLVM fptrunc .. to instruction</seealso>
            <seealso href="xref:llvm_langref#conversion-operations">LLVM Conversion Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.FPExt">
            <summary>fpext .. to instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.FPExt"/>
            <seealso href="xref:llvm_langref#fpext-to-instruction">LLVM fpext .. to instruction</seealso>
            <seealso href="xref:llvm_langref#conversion-operations">LLVM Conversion Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.PtrToInt">
            <summary>ptrtoint .. to instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.PointerToInt"/>
            <seealso href="xref:llvm_langref#ptrtoint-to-instruction">LLVM ptrtoint .. to instruction</seealso>
            <seealso href="xref:llvm_langref#conversion-operations">LLVM Conversion Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.IntToPtr">
            <summary>inttoptr .. to instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.IntToPointer"/>
            <seealso href="xref:llvm_langref#inttoptr-to-instruction">LLVM inttoptr .. to instruction</seealso>
            <seealso href="xref:llvm_langref#conversion-operations">LLVM Conversion Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.BitCast">
            <summary>bitcast .. to instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.BitCast"/>
            <seealso href="xref:llvm_langref#bitcast-to-instruction">LLVM bitcast .. to instruction</seealso>
            <seealso href="xref:llvm_langref#conversion-operations">LLVM Conversion Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.AddrSpaceCast">
            <summary>addressspacecast .. to instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.AddressSpaceCast"/>
            <seealso href="xref:llvm_langref#addressspacecast-to-instruction">LLVM addressspacecast .. to instruction</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.ICmp">
            <summary>icmp instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.IntCmp"/>
            <seealso href="xref:llvm_langref#icmp-instruction">LLVM icmp instruction</seealso>
            <seealso href="xref:llvm_langref#other-operations">LLVM Other Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.FCmp">
            <summary>fcmp instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.FCmp"/>
            <seealso href="xref:llvm_langref#fcmp-instruction">LLVM fcmp instruction</seealso>
            <seealso href="xref:llvm_langref#other-operations">LLVM Other Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Phi">
            <summary>phi instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.PhiNode"/>
            <seealso href="xref:llvm_langref#phi-instruction">LLVM phi instruction</seealso>
            <seealso href="xref:llvm_langref#other-operations">LLVM Other Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Call">
            <summary>call instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/>
            <seealso href="xref:llvm_langref#call-instruction">LLVM call instruction</seealso>
            <seealso href="xref:llvm_langref#other-operations">LLVM Other Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Select">
            <summary>select instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.SelectInstruction"/>
            <seealso href="xref:llvm_langref#select-instruction">LLVM select instruction</seealso>
            <seealso href="xref:llvm_langref#other-operations">LLVM Other Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.UserOp1">
            <summary>Custom user operator1 instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.UserOp1"/>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.UserOp2">
            <summary>Custom user operator2 instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.UserOp2"/>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.VaArg">
            <summary>va_arg instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.VaArg"/>
            <seealso href="xref:llvm_langref#va-arg-instruction">LLVM va_arg instruction</seealso>
            <seealso href="xref:llvm_langref#other-operations">LLVM Other Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.ExtractElement">
            <summary>extractelement instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.ExtractElement"/>
            <seealso href="xref:llvm_langref#extractelement-instruction">LLVM extractelement instruction</seealso>
            <seealso href="xref:llvm_langref#vector-operations">LLVM Vector Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.InsertElement">
            <summary>insert instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.InsertElement"/>
            <seealso href="xref:llvm_langref#insert-instruction">LLVM insert instruction</seealso>
            <seealso href="xref:llvm_langref#vector-operations">LLVM Vector Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.ShuffleVector">
            <summary>shufflevector instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.ShuffleVector"/>
            <seealso href="xref:llvm_langref#shufflevector-instruction">LLVM shufflevector instruction</seealso>
            <seealso href="xref:llvm_langref#vector-operations">LLVM Vector Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.ExtractValue">
            <summary>extractvalue instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.ExtractValue"/>
            <seealso href="xref:llvm_langref#extractvalue-instruction">LLVM extractvalue instruction</seealso>
            <seealso href="xref:llvm_langref#aggregate-operations">LLVM Vector Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.InsertValue">
            <summary>insertvalue instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.InsertValue"/>
            <seealso href="xref:llvm_langref#xxx-instruction">LLVM insertvalue instruction</seealso>
            <seealso href="xref:llvm_langref#aggregate-operations">LLVM Aggregate Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Resume">
            <summary>resume instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.ResumeInstruction"/>
            <seealso href="xref:llvm_langref#xxx-instruction">LLVM resume instruction</seealso>
            <seealso href="xref:llvm_langref#terminator-instructions">LLVM Terminator Instructions</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.LandingPad">
            <summary>landingpad instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.LandingPad"/>
            <seealso href="xref:llvm_langref#landingpad-instruction">LLVM landingpad instruction</seealso>
            <seealso href="xref:llvm_langref#other-operations">LLVM Other Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.CleanupRet">
            <summary>cleanupret instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.CleanupReturn"/>
            <seealso href="xref:llvm_langref#cleanupret-instruction">LLVM cleanupret instruction</seealso>
            <seealso href="xref:llvm_langref#terminator-instructions">LLVM Terminator Instructions</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.CatchRet">
            <summary>catchret instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.CatchReturn"/>
            <seealso href="xref:llvm_langref#catchret-instruction">LLVM catchret instruction</seealso>
            <seealso href="xref:llvm_langref#terminator-instructions">LLVM Terminator Instructions</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.CatchPad">
            <summary>catchpad instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.CatchPad"/>
            <seealso href="xref:llvm_langref#catchpad-instruction">LLVM catchpad instruction</seealso>
            <seealso href="xref:llvm_langref#other-operations">LLVM Other Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.CleanupPad">
            <summary>cleanuppad instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.CleanupPad"/>
            <seealso href="xref:llvm_langref#cleanuppad-instruction">LLVM cleanuppad instruction</seealso>
            <seealso href="xref:llvm_langref#other-operations">LLVM Other Operations</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.CatchSwitch">
            <summary>catchswitch instruction</summary>
            <seealso cref="T:Ubiquity.NET.Llvm.Instructions.CatchSwitch"/>
            <seealso href="xref:llvm_langref#catchswitch-instruction">LLVM catchswitch instruction</seealso>
            <seealso href="xref:llvm_langref#terminator-instructions">LLVM Terminator Instructions</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.CallBr">
            <summary>callbr instruction</summary>
            <seealso href="xref::llvm_langref#i-callbr"/>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.OpCode.Freeze">
            <summary>Freeze instruction</summary>
            <seealso href="xref:llvm_langref#i-freeze"/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Instruction">
            <summary>Exposes an LLVM Instruction</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Instruction.ContainingBlock">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> that contains this instruction</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Instruction.Opcode">
            <summary>Gets the LLVM opcode for the instruction</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Instruction.Location">
            <summary>Gets or sets the <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocation"/> for this instruction</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Instruction.IsMemoryAccess">
            <summary>Gets a value indicating whether the opcode is for a memory access (<see cref="T:Ubiquity.NET.Llvm.Instructions.Alloca"/>, <see cref="T:Ubiquity.NET.Llvm.Instructions.Load"/>, <see cref="T:Ubiquity.NET.Llvm.Instructions.Store"/>)</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Instruction.HasMetadata">
            <summary>Gets a value indicating whether this instruction has metadata</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Instruction.Item(Ubiquity.NET.Llvm.MetadataKind)">
            <summary>Gets or sets Metadata (as a value) for this instruction</summary>
            <param name="kindKey">Metadata kind to get</param>
            <returns>Metadata for the kind or <see langword="null"/> if not present</returns>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Instruction.NonDebugLocMetadata">
            <summary>Gets a snap-shot collection of the metadata for this instruction, filtering out all the debug location nodes</summary>
            <returns>Enumerable of the metadata nodes for the instruction</returns>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Instruction.Alignment">
            <summary>Gets or sets the alignment for the instruction</summary>
            <remarks>
            The alignment is always 0 for instructions other than <see cref="T:Ubiquity.NET.Llvm.Instructions.Alloca"/>,
            <see cref="T:Ubiquity.NET.Llvm.Instructions.Load"/>, <see cref="T:Ubiquity.NET.Llvm.Instructions.Store"/> that deal with memory accesses.
            Setting the alignment for other instructions results in an
            <see cref="T:System.InvalidOperationException"/>
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Instruction.Successors">
            <summary>Gets a, potentially empty, collection of successor blocks for this instruction</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.InstructionBuilder">
            <summary>LLVM Instruction builder allowing managed code to generate IR instructions</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.#ctor(Ubiquity.NET.Llvm.Context)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.Instructions.InstructionBuilder"/> class for a given <see cref="T:Ubiquity.NET.Llvm.Context"/></summary>
            <param name="context">Context used for creating instructions</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.#ctor(Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.Instructions.InstructionBuilder"/> class for a <see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/></summary>
            <param name="block">Block this builder is initially attached to</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Context">
            <summary>Gets the context this builder is creating instructions for</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.CurrentDebugLocation">
            <summary>Gets or sets the current Debug Location for this <see cref="T:Ubiquity.NET.Llvm.Instructions.InstructionBuilder"/></summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation(System.UInt32,System.UInt32,Ubiquity.NET.Llvm.DebugInfo.DILocalScope,Ubiquity.NET.Llvm.DebugInfo.DILocation)">
            <summary>Set the current debug location for this <see cref="T:Ubiquity.NET.Llvm.Instructions.InstructionBuilder"/></summary>
            <param name="line">Source line</param>
            <param name="col">Source column</param>
            <param name="scope"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocalScope"/> for the location</param>
            <param name="inlinedAt"><see cref="T:Ubiquity.NET.Llvm.DebugInfo.DILocation"/>the location is inlined into</param>
            <returns>This builder for fluent API usage</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SetDebugLocation(Ubiquity.NET.Llvm.DebugInfo.DILocation)">
            <summary>Set the current debug location for this <see cref="T:Ubiquity.NET.Llvm.Instructions.InstructionBuilder"/></summary>
            <param name="location">Location to set</param>
            <returns>This builder for fluent API usage</returns>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> this builder is building instructions for</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertFunction">
            <summary>Gets the function this builder currently inserts into</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionAtEnd(Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Positions the builder at the end of a given <see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/></summary>
            <param name="basicBlock">Block to set the position of</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PositionBefore(Ubiquity.NET.Llvm.Instructions.Instruction)">
            <summary>Positions the builder before the given instruction</summary>
            <param name="instr">Instruction to position the builder before</param>
            <remarks>This method will position the builder to add new instructions
            immediately before the specified instruction.
            <note type="note">It is important to keep in mind that this can change the
            block this builder is targeting. That is, <paramref name="instr"/>
            is not required to come from the same block the instruction builder is
            currently referencing.</note>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AppendBasicBlock(Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Appends a basic block after the <see cref="P:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock"/> of this <see cref="T:Ubiquity.NET.Llvm.Instructions.InstructionBuilder"/></summary>
            <param name="block">Block to insert</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FNeg(Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates a floating point negation operator</summary>
            <param name="value">value to negate</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FAdd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates a floating point add operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates a floating point subtraction operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FMul(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates a floating point multiple operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates a floating point division operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FRem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates a floating point remainder operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Neg(Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer negation operator</summary>
            <param name="value">operand to negate</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Not(Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer logical not operator</summary>
            <param name="value">operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
            <remarks>LLVM IR doesn't actually have a logical not instruction so this is implemented as value XOR {one} </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Add(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer add operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.And(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer bitwise and operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Sub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer subtraction operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Mul(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer multiplication operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ShiftLeft(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer shift left operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ArithmeticShiftRight(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer arithmetic shift right operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LogicalShiftRight(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer logical shift right operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer unsigned division operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SDiv(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer signed division operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.URem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer unsigned remainder operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SRem(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer signed remainder operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Xor(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer bitwise exclusive or operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Or(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an integer bitwise or operator</summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates an alloca instruction</summary>
            <param name="typeRef">Type of the value to allocate</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.Alloca"/> instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Alloca(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.ConstantInt)">
            <summary>Creates an alloca instruction</summary>
            <param name="typeRef">Type of the value to allocate</param>
            <param name="elements">Number of elements to allocate</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.Alloca"/> instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return">
            <summary>Creates a return instruction for a function that has no return value</summary>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.ReturnInstruction"/></returns>
            <exception cref="T:System.ArgumentException"> the function has a non-void return type</exception>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Return(Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates a return instruction with the return value for a function</summary>
            <param name="value"><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> to return</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.ReturnInstruction"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])">
            <summary>Creates a call function</summary>
            <param name="func">Function to call</param>
            <param name="args">Arguments to pass to the function</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Call(Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value})">
            <summary>Creates a call function</summary>
            <param name="func">Function to call</param>
            <param name="args">Arguments to pass to the function</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Invoke(Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IReadOnlyList{Ubiquity.NET.Llvm.Values.Value},Ubiquity.NET.Llvm.Values.BasicBlock,Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Creates an <see cref="T:Ubiquity.NET.Llvm.Instructions.Invoke"/> instruction</summary>
            <param name="func">Function to invoke</param>
            <param name="args">arguments to pass to the function</param>
            <param name="then">Successful continuation block</param>
            <param name="catchBlock">Exception handling block</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.Invoke"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.LandingPad(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Instructions.LandingPad"/> instruction</summary>
            <param name="resultType">Result type for the pad</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.LandingPad"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Freeze(Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Instructions.Freeze"/> instruction</summary>
            <param name="value">Value to freeze</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.Freeze"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Resume(Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Instructions.ResumeInstruction"/></summary>
            <param name="exception">Exception value</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.ResumeInstruction"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Store(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Builds an LLVM Store instruction</summary>
            <param name="value">Value to store in destination</param>
            <param name="destination">value for the destination</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.Store"/> instruction</returns>
            <remarks>
            Since store targets memory the type of <paramref name="destination"/>
            must be an <see cref="T:Ubiquity.NET.Llvm.Types.IPointerType"/>. Furthermore, the element type of
            the pointer must match the type of <paramref name="value"/>. Otherwise,
            an <see cref="T:System.ArgumentException"/> is thrown.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Load(Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Instructions.Load"/> instruction</summary>
            <param name="sourcePtr">Pointer to the value to load</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.Load"/></returns>
            <remarks>The <paramref name="sourcePtr"/> must not be an opaque pointer type</remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Load(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates a load instruction</summary>
            <param name="type">Type of the value to load</param>
            <param name="sourcePtr">pointer to load the value from</param>
            <returns>Load instruction</returns>
            <remarks>
            The <paramref name="type"/> of the value must be a sized type (e.g. not Opaque with a non-zero size ).
            if <paramref name="sourcePtr"/> is a non-opaque pointer then its ElementType must be the same as <paramref name="type"/>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXchg(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic exchange (Read, Modify, Write) instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="val">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAdd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic add instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="val">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic subtraction instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="val">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicAnd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic AND instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="val">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicNand(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic NAND instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="val">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicOr(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic or instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="val">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicXor(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic XOR instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="val">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMax(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic ADD instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="val">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicMin(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic MIN instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="val">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMax(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic UMax instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="val">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicUMin(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic UMin instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="val">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFadd(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic FAdd instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="val">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicFSub(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic FSub instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="val">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AtomicCmpXchg(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Creates an atomic Compare exchange instruction</summary>
            <param name="ptr">Pointer to the value to update (e.g. destination and the left hand operand)</param>
            <param name="cmp">Comparand for the operation</param>
            <param name="value">Right hand side operand</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.AtomicRMW"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer(Ubiquity.NET.Llvm.Values.Value,System.UInt32)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> that accesses an element (field) of a structure</summary>
            <param name="pointer">pointer to the structure to get an element from</param>
            <param name="index">element index</param>
            <returns>
            <para><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the member access. This is a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            as LLVM may optimize the expression to a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/>
            or <see cref="T:Ubiquity.NET.Llvm.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetStructElementPointer(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.UInt32)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> that accesses an element (field) of a structure</summary>
            <param name="type">Type of the pointer</param>
            <param name="pointer">OPaque pointer to the structure to get an element from</param>
            <param name="index">element index</param>
            <returns>
            <para><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the member access. This is a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            as LLVM may optimize the expression to a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/>
            or <see cref="T:Ubiquity.NET.Llvm.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> that accesses an element of a type referenced by a pointer</summary>
            <param name="type">Type of array,vector or structure to get the element pointer from</param>
            <param name="pointer">opaque pointer to get an element from</param>
            <param name="args">additional indices for computing the resulting pointer</param>
            <returns>
            <para><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the member access. This is a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            as LLVM may optimize the expression to a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/>
            or <see cref="T:Ubiquity.NET.Llvm.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
            <remarks>
            For details on GetElementPointer (GEP) see
            <see href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</see>.
            The basic gist is that the GEP instruction does not access memory, it only computes a pointer
            offset from a base. A common confusion is around the first index and what it means. For C
            and C++ programmers an expression like pFoo->bar seems to only have a single offset or
            index. However, that is only syntactic sugar where the compiler implicitly hides the first
            index. That is, there is no difference between pFoo[0].bar and pFoo->bar except that the
            former makes the first index explicit. LLVM requires an explicit first index, even if it is
            zero, in order to properly compute the offset for a given element in an aggregate type.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> that accesses an element of a type referenced by a pointer</summary>
            <param name="pointer">pointer to get an element from</param>
            <param name="args">additional indices for computing the resulting pointer</param>
            <returns>
            <para><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the member access. This is a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            as LLVM may optimize the expression to a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/>
            or <see cref="T:Ubiquity.NET.Llvm.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
            <remarks>
            For details on GetElementPointer (GEP) see
            <see href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</see>.
            The basic gist is that the GEP instruction does not access memory, it only computes a pointer
            offset from a base. A common confusion is around the first index and what it means. For C
            and C++ programmers an expression like pFoo->bar seems to only have a single offset or
            index. However, that is only syntactic sugar where the compiler implicitly hides the first
            index. That is, there is no difference between pFoo[0].bar and pFoo->bar except that the
            former makes the first index explicit. LLVM requires an explicit first index, even if it is
            zero, in order to properly compute the offset for a given element in an aggregate type.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtr(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> that accesses an element of a type referenced by a pointer</summary>
            <param name="pointer">pointer to get an element from</param>
            <param name="args">additional indices for computing the resulting pointer</param>
            <returns>
            <para><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the member access. This is a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            as LLVM may optimize the expression to a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/>
            or <see cref="T:Ubiquity.NET.Llvm.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
            <remarks>
            For details on GetElementPointer (GEP) see
            <see href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</see>.
            The basic gist is that the GEP instruction does not access memory, it only computes a pointer
            offset from a base. A common confusion is around the first index and what it means. For C
            and C++ programmers an expression like pFoo->bar seems to only have a single offset or
            index. However, that is only syntactic sugar where the compiler implicitly hides the first
            index. That is, there is no difference between pFoo[0].bar and pFoo->bar except that the
            former makes the first index explicit. LLVM requires an explicit first index, even if it is
            zero, in order to properly compute the offset for a given element in an aggregate type.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> that accesses an element of a type referenced by a pointer</summary>
            <param name="pointer">pointer to get an element from</param>
            <param name="args">additional indices for computing the resulting pointer</param>
            <returns>
            <para><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the member access. This is a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            as LLVM may optimize the expression to a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/>
            or <see cref="T:Ubiquity.NET.Llvm.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
            <remarks>
            For details on GetElementPointer (GEP) see
            <see href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</see>.
            The basic gist is that the GEP instruction does not access memory, it only computes a pointer
            offset from a base. A common confusion is around the first index and what it means. For C
            and C++ programmers an expression like pFoo->bar seems to only have a single offset or
            index. However, that is only syntactic sugar where the compiler implicitly hides the first
            index. That is, there is no difference between pFoo[0].bar and pFoo->bar except that the
            former makes the first index explicit. LLVM requires an explicit first index, even if it is
            zero, in order to properly compute the offset for a given element in an aggregate type.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Value})">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> that accesses an element of a type referenced by a pointer</summary>
            <param name="type">Base pointer type</param>
            <param name="pointer">opaque pointer to get an element from</param>
            <param name="args">additional indices for computing the resulting pointer</param>
            <returns>
            <para><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the member access. This is a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            as LLVM may optimize the expression to a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/>
            or <see cref="T:Ubiquity.NET.Llvm.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
            <remarks>
            For details on GetElementPointer (GEP) see
            <see href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</see>.
            The basic gist is that the GEP instruction does not access memory, it only computes a pointer
            offset from a base. A common confusion is around the first index and what it means. For C
            and C++ programmers an expression like pFoo->bar seems to only have a single offset or
            index. However, that is only syntactic sugar where the compiler implicitly hides the first
            index. That is, there is no difference between pFoo[0].bar and pFoo->bar except that the
            former makes the first index explicit. LLVM requires an explicit first index, even if it is
            zero, in order to properly compute the offset for a given element in an aggregate type.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> that accesses an element of a type referenced by a pointer</summary>
            <param name="pointer">pointer to get an element from</param>
            <param name="args">additional indices for computing the resulting pointer</param>
            <returns>
            <para><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the member access. This is a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            as LLVM may optimize the expression to a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/>
            or <see cref="T:Ubiquity.NET.Llvm.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
            <remarks>
            For details on GetElementPointer (GEP) see
            <see href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</see>.
            The basic gist is that the GEP instruction does not access memory, it only computes a pointer
            offset from a base. A common confusion is around the first index and what it means. For C
            and C++ programmers an expression like pFoo->bar seems to only have a single offset or
            index. However that is only syntactic sugar where the compiler implicitly hides the first
            index. That is, there is no difference between pFoo[0].bar and pFoo->bar except that the
            former makes the first index explicit. LLVM requires an explicit first index, even if it is
            zero, in order to properly compute the offset for a given element in an aggregate type.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.GetElementPtrInBounds(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> that accesses an element of a type referenced by a pointer</summary>
            <param name="type">Base pointer type</param>
            <param name="pointer">opaque pointer to get an element from</param>
            <param name="args">additional indices for computing the resulting pointer</param>
            <returns>
            <para><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the member access. This is a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            as LLVM may optimize the expression to a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/>
            or <see cref="T:Ubiquity.NET.Llvm.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
            <remarks>
            For details on GetElementPointer (GEP) see
            <see href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</see>.
            The basic gist is that the GEP instruction does not access memory, it only computes a pointer
            offset from a base. A common confusion is around the first index and what it means. For C
            and C++ programmers an expression like pFoo->bar seems to only have a single offset or
            index. However that is only syntactic sugar where the compiler implicitly hides the first
            index. That is, there is no difference between pFoo[0].bar and pFoo->bar except that the
            former makes the first index explicit. LLVM requires an explicit first index, even if it is
            zero, in order to properly compute the offset for a given element in an aggregate type.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ConstGetElementPtrInBounds(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value[])">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> that accesses an element of a type referenced by a pointer</summary>
            <param name="pointer">pointer to get an element from</param>
            <param name="args">additional indices for computing the resulting pointer</param>
            <returns>
            <para><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> for the member access. This is a User as LLVM may
            optimize the expression to a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/>
            or <see cref="T:Ubiquity.NET.Llvm.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
            <remarks>
            For details on GetElementPointer (GEP) see
            <see href="xref:llvm_misunderstood_gep">The Often Misunderstood GEP Instruction</see>.
            The basic gist is that the GEP instruction does not access memory, it only computes a pointer
            offset from a base. A common confusion is around the first index and what it means. For C
            and C++ programmers an expression like pFoo->bar seems to only have a single offset or
            index. However that is only syntactic sugar where the compiler implicitly hides the first
            index. That is, there is no difference between pFoo[0].bar and pFoo->bar except that the
            former makes the first index explicit. LLVM requires an explicit first index, even if it is
            zero, in order to properly compute the offset for a given element in an aggregate type.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntToPointer(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.IPointerType)">
            <summary>Builds a cast from an integer to a pointer</summary>
            <param name="intValue">Integer value to cast</param>
            <param name="ptrType">pointer type to return</param>
            <returns>Resulting value from the cast</returns>
            <remarks>
            The actual type of value returned depends on <paramref name="intValue"/>
            and is either a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/> or an <see cref="T:Ubiquity.NET.Llvm.Instructions.IntToPointer"/>
            instruction. Conversion to a constant expression is performed whenever possible.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PointerToInt(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Builds a cast from a pointer to an integer type</summary>
            <param name="ptrValue">Pointer value to cast</param>
            <param name="intType">Integer type to return</param>
            <returns>Resulting value from the cast</returns>
            <remarks>
            The actual type of value returned depends on <paramref name="ptrValue"/>
            and is either a <see cref="T:Ubiquity.NET.Llvm.Values.ConstantExpression"/> or a <see cref="T:Ubiquity.NET.Llvm.Instructions.PointerToInt"/>
            instruction. Conversion to a constant expression is performed whenever possible.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch(Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Create an unconditional branch</summary>
            <param name="target">Target block for the branch</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.Branch"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Branch(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock,Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Creates a conditional branch instruction</summary>
            <param name="ifCondition">Condition for the branch</param>
            <param name="thenTarget">Target block for the branch when <paramref name="ifCondition"/> evaluates to a non-zero value</param>
            <param name="elseTarget">Target block for the branch when <paramref name="ifCondition"/> evaluates to a zero value</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.Branch"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Unreachable">
            <summary>Creates an <see cref="T:Ubiquity.NET.Llvm.Instructions.Unreachable"/> instruction</summary>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.Unreachable"/> </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.IntPredicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Builds an Integer compare instruction</summary>
            <param name="predicate">Integer predicate for the comparison</param>
            <param name="lhs">Left hand side of the comparison</param>
            <param name="rhs">Right hand side of the comparison</param>
            <returns>Comparison instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.RealPredicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Builds a Floating point compare instruction</summary>
            <param name="predicate">predicate for the comparison</param>
            <param name="lhs">Left hand side of the comparison</param>
            <param name="rhs">Right hand side of the comparison</param>
            <returns>Comparison instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Compare(Ubiquity.NET.Llvm.Instructions.Predicate,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Builds a compare instruction</summary>
            <param name="predicate">predicate for the comparison</param>
            <param name="lhs">Left hand side of the comparison</param>
            <param name="rhs">Right hand side of the comparison</param>
            <returns>Comparison instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtendOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a zero extend or bit cast instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtendOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a sign extend or bit cast instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.TruncOrBitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a trunc or bit cast instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ZeroExtend(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a Zero Extend instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SignExtend(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a Sign Extend instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.BitCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a bitcast instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.IntCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef,System.Boolean)">
            <summary>Creates an integer cast instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <param name="isSigned">Flag to indicate if the cast is signed or unsigned</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trunc(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a trunc instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SIToFPCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a signed integer to floating point cast instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.UIToFPCast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates an unsigned integer to floating point cast instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToUICast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a Floating point to unsigned integer cast instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPToSICast(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a floating point to signed integer cast instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPExt(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a floating point extend instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.FPTrunc(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a floating point truncate instruction</summary>
            <param name="valueRef">Operand for the instruction</param>
            <param name="targetType">Target type for the instruction</param>
            <returns>Result <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Select(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Builds a <see cref="T:Ubiquity.NET.Llvm.Instructions.SelectInstruction"/> instruction</summary>
            <param name="ifCondition">Value for the condition to select between the values</param>
            <param name="thenValue">Result value if <paramref name="ifCondition"/> evaluates to 1</param>
            <param name="elseValue">Result value if <paramref name="ifCondition"/> evaluates to 0</param>
            <returns>Selected value</returns>
            <remarks>
            If <paramref name="ifCondition"/> is a vector then both values must be a vector of the same
            size and the selection is performed element by element. The values must be the same type.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.PhiNode(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a Phi instruction</summary>
            <param name="resultType">Result type for the instruction</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.PhiNode"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.ExtractValue(Ubiquity.NET.Llvm.Values.Value,System.UInt32)">
            <summary>Creates an extractvalue instruction</summary>
            <param name="instance">Instance to extract a value from</param>
            <param name="index">index of the element to extract</param>
            <returns>Value for the instruction</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Switch(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock,System.UInt32)">
            <summary>Creates a switch instruction</summary>
            <param name="value">Value to switch on</param>
            <param name="defaultCase">default case if <paramref name="value"/> does match any case</param>
            <param name="numCases">Number of cases for the switch</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.Switch"/></returns>
            <remarks>
            Callers can use <see cref="M:Ubiquity.NET.Llvm.Instructions.Switch.AddCase(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock)"/> to add cases to the
            instruction.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DoNothing">
            <summary>Creates a call to the llvm.donothing intrinsic</summary>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/></returns>
            <exception cref="T:System.InvalidOperationException">
            <see cref="P:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertBlock"/> is <see langword="null"/> or it's <see cref="P:Ubiquity.NET.Llvm.Values.BasicBlock.ContainingFunction"/> is null or has a <see langword="null"/> <see cref="P:Ubiquity.NET.Llvm.Values.GlobalValue.ParentModule"/>
            </exception>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.DebugTrap">
            <summary>Creates a llvm.debugtrap call</summary>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.Trap">
            <summary>Creates a llvm.trap call</summary>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.CallInstruction"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemCpy(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)">
            <summary>Builds a memcpy intrinsic call</summary>
            <param name="destination">Destination pointer of the memcpy</param>
            <param name="source">Source pointer of the memcpy</param>
            <param name="len">length of the data to copy</param>
            <param name="isVolatile">Flag to indicate if the copy involves volatile data such as physical registers</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.Intrinsic"/> call for the memcpy</returns>
            <remarks>
            LLVM has many overloaded variants of the memcpy intrinsic, this implementation will deduce the types from
            the provided values and generate a more specific call without the need to provide overloaded forms of this
            method and otherwise complicating the calling code.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemMove(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)">
            <summary>Builds a memmove intrinsic call</summary>
            <param name="destination">Destination pointer of the memmove</param>
            <param name="source">Source pointer of the memmove</param>
            <param name="len">length of the data to copy</param>
            <param name="isVolatile">Flag to indicate if the copy involves volatile data such as physical registers</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.Intrinsic"/> call for the memmove</returns>
            <remarks>
            LLVM has many overloaded variants of the memmove intrinsic, this implementation will deduce the types from
            the provided values and generate a more specific call without the need to provide overloaded forms of this
            method and otherwise complicating the calling code.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MemSet(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)">
            <summary>Builds a memset intrinsic call</summary>
            <param name="destination">Destination pointer of the memset</param>
            <param name="value">fill value for the memset</param>
            <param name="len">length of the data to fill</param>
            <param name="isVolatile">Flag to indicate if the fill involves volatile data such as physical registers</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Instructions.Intrinsic"/> call for the memset</returns>
            <remarks>
            LLVM has many overloaded variants of the memset intrinsic, this implementation will deduce the types from
            the provided values and generate a more specific call without the need to provide overloaded forms of this
            method and otherwise complicating the calling code.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.InsertValue(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.UInt32)">
            <summary>Builds an <see cref="T:Ubiquity.NET.Llvm.Instructions.InsertValue"/> instruction </summary>
            <param name="aggValue">Aggregate value to insert <paramref name="elementValue"/> into</param>
            <param name="elementValue">Value to insert into <paramref name="aggValue"/></param>
            <param name="index">Index to insert the value into</param>
            <returns>Instruction as a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.AddWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)">
            <summary>Generates a call to the llvm.[s|u]add.with.overflow intrinsic</summary>
            <param name="lhs">Left hand side of the operation</param>
            <param name="rhs">Right hand side of the operation</param>
            <param name="signed">Flag to indicate if the operation is signed <see langword="true"/> or unsigned <see langword="false"/></param>
            <returns>Instruction as a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.SubWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)">
            <summary>Generates a call to the llvm.[s|u]sub.with.overflow intrinsic</summary>
            <param name="lhs">Left hand side of the operation</param>
            <param name="rhs">Right hand side of the operation</param>
            <param name="signed">Flag to indicate if the operation is signed <see langword="true"/> or unsigned <see langword="false"/></param>
            <returns>Instruction as a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionBuilder.MulWithOverflow(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.Value,System.Boolean)">
            <summary>Generates a call to the llvm.[s|u]mul.with.overflow intrinsic</summary>
            <param name="lhs">Left hand side of the operation</param>
            <param name="rhs">Right hand side of the operation</param>
            <param name="signed">Flag to indicate if the operation is signed <see langword="true"/> or unsigned <see langword="false"/></param>
            <returns>Instruction as a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.InstructionExtensions">
            <summary>Provides extension methods to <see cref="T:Ubiquity.NET.Llvm.Instructions.Instruction"/> that cannot be achieved as members of the class</summary>
            <remarks>
            Using generic static extension methods allows for fluent coding while retaining the type of the "this" parameter.
            If these were members of the <see cref="T:Ubiquity.NET.Llvm.Instructions.Instruction"/> class then the only return type could be <see cref="T:Ubiquity.NET.Llvm.Instructions.Instruction"/>
            thus losing the original type and requiring a cast to get back to it, thereby defeating the purpose of the fluent style.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionExtensions.Alignment``1(``0,System.UInt32)">
            <summary>Fluent style extension method to set the <see cref="P:Ubiquity.NET.Llvm.Instructions.Instruction.Alignment"/> for an instruction</summary>
            <typeparam name="T">Type of the instruction (usually implicitly inferred from usage)</typeparam>
            <param name="self">Instruction to set the <see cref="P:Ubiquity.NET.Llvm.Instructions.Instruction.Alignment"/> for</param>
            <param name="value">New alignment for the instruction</param>
            <returns>To allow fluent style coding this returns the <paramref name="self"/> parameter</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.InstructionExtensions.IsVolatile``1(``0,System.Boolean)">
            <summary>Fluent style extension method to set the Volatile property of a <see cref="T:Ubiquity.NET.Llvm.Instructions.Load"/> or <see cref="T:Ubiquity.NET.Llvm.Instructions.Store"/> instruction</summary>
            <typeparam name="T">Type of the instruction (usually implicitly inferred from usage)</typeparam>
            <param name="self">Instruction to set the Volatile property for</param>
            <param name="value">Flag to indicate if the instruction's operation is volatile</param>
            <returns>To allow fluent style coding this returns the <paramref name="self"/> parameter</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.IntCmp">
            <summary>Instruction to perform an integer compare</summary>
            <seealso href="xref:llvm_langref#intcmp-instruction">LLVM intcmp Instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Intrinsic">
            <summary>base class for calls to LLVM intrinsic functions</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.Intrinsic.LookupId(System.String)">
            <summary>Looks up the LLVM intrinsic ID from it's name</summary>
            <param name="name">Name of the intrinsic</param>
            <returns>Intrinsic ID or 0 if the name does not correspond with an intrinsic function</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.IntToPointer">
            <summary>Instruction to convert an integer to a pointer type</summary>
            <seealso href="xref:llvm_langref#inttoptr-to-instruction">LLVM inttoptr .. to Instruction</seealso>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Invoke">
            <summary>Instruction to invoke (call) a function with exception handling</summary>
            <seealso href="xref:llvm_langref#i-invoke">LLVM invoke Instruction</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Invoke.TargetFunction">
            <summary>Gets the target function of the invocation</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Invoke.NormalDestination">
            <summary>Gets or sets the normal destination for the invoke</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Invoke.Attributes">
            <summary>Gets the attributes for this call site</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.Invoke.AddAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeValue)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.Invoke.GetAttributeCountAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.Invoke.GetAttributesAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.Invoke.GetAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeKind)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.Invoke.GetAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.Invoke.RemoveAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeKind)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.Invoke.RemoveAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.LandingPad">
            <summary>Marks a <see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> as a catch handler</summary>
            <remarks>
            Like the <see cref="T:Ubiquity.NET.Llvm.Instructions.CatchPad"/>, instruction this must be the first non-phi instruction
            in the block.
            </remarks>
            <seealso href="xref:llvm_langref#i-landingpad">LLVM landing Instruction</seealso>
            <seealso href="xref:llvm_exception_handling#exception-handling-in-llvm">Exception Handling in LLVM</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.LandingPad.IsCleanup">
            <summary>Gets or sets a value indicating whether this <see cref="T:Ubiquity.NET.Llvm.Instructions.LandingPad"/> is a cleanup pad</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.LandingPad.Clauses">
            <summary>Gets the collection of clauses for this landing pad</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Load">
            <summary>Instruction to read from memory</summary>
            <seealso href="xref:llvm_langref#load-instruction">LLVM load Instruction</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Load.IsVolatile">
            <summary>Gets or sets a value indicating whether this load is volatile</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.MemCpy">
            <summary>Instruction for the LLVM intrinsic llvm.memcpy instruction</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.MemIntrinsic">
            <summary>Base class for memory intrinsic instructions</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.MemMove">
            <summary>Intrinsic call to target optimized memmove</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.MemSet">
            <summary>Instruction for the LLVM intrinsic memset function</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.PhiNode">
            <summary>PHI node instruction</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.PhiNode.AddIncoming(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Adds an incoming value and block to this <see cref="T:Ubiquity.NET.Llvm.Instructions.PhiNode"/></summary>
            <param name="value">Value from <paramref name="srcBlock"/></param>
            <param name="srcBlock">Incoming block</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.PhiNode.AddIncoming(System.ValueTuple{Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock},System.ValueTuple{Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock}[])">
            <summary>Adds incoming blocks and values to this <see cref="T:Ubiquity.NET.Llvm.Instructions.PhiNode"/></summary>
            <param name="firstIncoming">first incoming value and block</param>
            <param name="additionalIncoming">additional values and blocks</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.PointerToInt">
            <summary>Instruction to cast a pointer to an integer value</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Predicate">
            <summary>Unified predicate enumeration</summary>
            <remarks>
            For floating point predicates "Ordered" means that neither operand is a QNAN
            while unordered means that either operand may be a QNAN.
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.False">
            <summary>No comparison, always returns floating point false</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.OrderedAndEqual">
            <summary>Ordered and equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.OrderedAndGreaterThan">
            <summary>Ordered and greater than floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.OrderedAndGreaterThanOrEqual">
            <summary>Ordered and greater than or equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.OrderedAndLessThan">
            <summary>Ordered and less than floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.OrderedAndLessThanOrEqual">
            <summary>Ordered and less than or equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.OrderedAndNotEqual">
            <summary>Ordered and not equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.Ordered">
            <summary>Ordered floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.Unordered">
            <summary>Unordered floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.UnorderedAndEqual">
            <summary>Unordered and equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.UnorderedOrGreaterThan">
            <summary>Unordered or greater than floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.UnorderedOrGreaterThanOrEqual">
            <summary>Unordered or greater than or Equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.UnorderedOrLessThan">
            <summary>Unordered or Less than floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.UnorderedOrLessThanOrEqual">
            <summary>Unordered or Less than or Equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.UnorderedOrNotEqual">
            <summary>Unordered or not equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.True">
            <summary>No comparison, always returns true </summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.FirstFcmpPredicate">
            <summary>Tag for the first floating point compare predicate, all floating point predicates are greater than or equal to this value</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.LastFcmpPredicate">
            <summary>Tag for the last floating point compare predicate, all floating point predicates are less than or equal to this value</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.BadFcmpPredicate">
            <summary>Any value greater than or equal to this is not valid for Fcmp operations</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.Equal">
            <summary>Integer equality comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.NotEqual">
            <summary>Integer not equal comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.UnsignedGreaterThan">
            <summary>Integer unsigned greater than comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.UnsignedGreaterThanOrEqual">
            <summary>Integer unsigned greater than or equal comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.UnsignedLessThan">
            <summary>Integer unsigned less than comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.UnsignedLessThanOrEqual">
            <summary>Integer unsigned less than or equal comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.SignedGreaterThan">
            <summary>Integer signed greater than comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.SignedGreaterThanOrEqual">
            <summary>Integer signed greater than or equal comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.SignedLessThan">
            <summary>Integer signed less than comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.SignedLessThanOrEqual">
            <summary>Integer signed less than or equal comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.FirstIcmpPredicate">
            <summary>Tag for the first integer compare predicate, all integer predicates are greater than or equal to this value</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.LastIcmpPredicate">
            <summary>Tag for the last integer compare predicate, all integer predicates are less than or equal to this value</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.Predicate.BadIcmpPredicate">
            <summary>Any value Greater than or equal to this is not valid for cmp operations</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.IntPredicate">
            <summary>Predicate enumeration for integer comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.IntPredicate.None">
            <summary>No predicate, this is an invalid value for integer predicates</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.IntPredicate.Equal">
            <summary>Integer equality comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.IntPredicate.NotEqual">
            <summary>Integer not equal comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.IntPredicate.UnsignedGreaterThan">
            <summary>Integer unsigned greater than comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.IntPredicate.UnsignedGreaterOrEqual">
            <summary>Integer unsigned greater than or equal comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.IntPredicate.UnsignedLessThan">
            <summary>Integer unsigned less than comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.IntPredicate.UnsignedLessThanOrEqual">
            <summary>Integer unsigned less than or equal comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.IntPredicate.SignedGreaterThan">
            <summary>Integer signed greater than comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.IntPredicate.SignedGreaterThanOrEqual">
            <summary>Integer signed greater than or equal comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.IntPredicate.SignedLessThan">
            <summary>Integer signed less than comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.IntPredicate.SignedLessThanOrEqual">
            <summary>Integer signed less than or equal comparison</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.RealPredicate">
            <summary>Predicate enumeration for floating point comparison</summary>
            <remarks>
            Floating point predicates "Ordered" means that neither operand is a QNAN
            while unordered means that either operand may be a QNAN.
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.False">
            <summary>No comparison, always returns floating point false</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.OrderedAndEqual">
            <summary>Ordered and equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.OrderedAndGreaterThan">
            <summary>Ordered and greater than floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.OrderedAndGreaterThanOrEqual">
            <summary>Ordered and greater than or equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.OrderedAndLessThan">
            <summary>Ordered and less than floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.OrderedAndLessThanOrEqual">
            <summary>Ordered and less than or equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.OrderedAndNotEqual">
            <summary>Ordered and not equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.Ordered">
            <summary>Ordered floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.Unordered">
            <summary>Unordered floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.UnorderedAndEqual">
            <summary>Unordered and equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.UnorderedOrGreaterThan">
            <summary>Unordered or greater than floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.UnorderedOrGreaterThanOrEqual">
            <summary>Unordered or greater than or Equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.UnorderedOrLessThan">
            <summary>Unordered or Less than floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.UnorderedOrLessThanOrEqual">
            <summary>Unordered or Less than or Equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.UnorderedOrNotEqual">
            <summary>Unordered or not equal floating point comparison</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Instructions.RealPredicate.True">
            <summary>No comparison, always returns true </summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.ResumeInstruction">
            <summary>Resume instruction</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.ReturnInstruction">
            <summary>Return instruction</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.SelectInstruction">
            <summary>Select instruction</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.ShuffleVector">
            <summary>Instruction to shuffle the elements of a vector</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.SignExtend">
            <summary>Sign extension instruction</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.SIToFP">
            <summary>Instruction for converting a signed integer value into a floating point value</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Store">
            <summary>Instruction to store a value to memory</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Store.IsVolatile">
            <summary>Gets or sets a value indicating whether the store is volatile</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.SuccessorBlockCollection">
            <summary>Support class to provide read/update semantics for the successor blocks of an instruction</summary>
            <remarks>
            This class is used to implement Operand lists of elements including sub lists based on an offset.
            The latter case is useful for types that expose some fixed set of operands as properties and some
            arbitrary number of additional items as operands.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.SuccessorBlockCollection.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.SuccessorBlockCollection.Count">
            <summary>Gets the count of elements in this collection</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.SuccessorBlockCollection.GetEnumerator">
            <summary>Gets an enumerator for the <see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/>s in this collection</summary>
            <returns>Enumerator for the collection</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.SuccessorBlockCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets an enumerator for the <see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/>s in this collection</summary>
            <returns>Enumerator for the collection</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.SuccessorBlockCollection.Contains(Ubiquity.NET.Llvm.Values.BasicBlock)">
            <inheritdoc/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Switch">
            <summary>Switch instruction</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Instructions.Switch.Default">
            <summary>Gets the default <see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> for the switch</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Instructions.Switch.AddCase(Ubiquity.NET.Llvm.Values.Value,Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Adds a new case to the <see cref="T:Ubiquity.NET.Llvm.Instructions.Switch"/> instruction</summary>
            <param name="onVal">Value for the case to match</param>
            <param name="destination">Destination <see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> if the case matches</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Terminator">
            <summary>Base class for all terminator instructions</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Trunc">
            <summary>Integer truncate instruction</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.UIToFP">
            <summary>Instruction to cast an unsigned integer to a float</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.UnaryInstruction">
            <summary>Base class for unary operator instructions</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.UnaryOperator">
            <summary>Base class for a unary operator</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.Unreachable">
            <summary>Instruction to indicate an unreachable location</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.UserOp1">
            <summary>Custom operator that can be used in LLVM transform passes but should be removed before target instruction selection</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.UserOp2">
            <summary>Custom operator that can be used in LLVM transform passes but should be removed before target instruction selection</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.VaArg">
            <summary>Instruction to load an argument of a specified type from a variadic argument list</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Instructions.ZeroExtend">
            <summary>Instruction to zero extend a value</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.InternalCodeGeneratorException">
            <summary>Exception generated when the internal state of the code generation cannot proceed due to an internal error</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.InternalCodeGeneratorException.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.InternalCodeGeneratorException"/> class.</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.InternalCodeGeneratorException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.InternalCodeGeneratorException"/> class.</summary>
            <param name="message">Message for the exception</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.InternalCodeGeneratorException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.InternalCodeGeneratorException"/> class.</summary>
            <param name="message">Message for the exception</param>
            <param name="inner">Inner exception</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.InternalCodeGeneratorException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.InternalCodeGeneratorException"/> class from serialization</summary>
            <param name="serializationInfo">Serialization Info for construction</param>
            <param name="streamingContext">Context for construction</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.IOperandCollection`1">
            <summary>Interface for a fixed shape collection of operands</summary>
            <typeparam name="T">Type of elements in the container</typeparam>
            <remarks>
            This interface describes a subset of the behavior of <see cref="T:System.Collections.Generic.ICollection`1"/>
            and <see cref="T:System.Collections.Generic.IList`1"/> along with an extension of the behavior of <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.
            The semantics are a collection where the size/shape is not mutable, however the
            individual members are. That is the container does not support adding or removing
            elements, but does allow replacing existing elements.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.IOperandCollection`1.Item(System.Int32)">
            <summary>Gets or sets the specified element in the collection</summary>
            <param name="index">index of the element in the collection</param>
            <returns>The element in the collection</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.IOperandCollection`1.Contains(`0)">
            <summary>Gets a value indicating whether the collection contains the specified item or not</summary>
            <param name="item">Item to look for</param>
            <returns><see langword="true"/> if the item is found</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.IOperandCollectionExtension">
            <summary>Extensions to allow slicing of IOperandCollection</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.IOperandCollectionExtension.Slice``1(Ubiquity.NET.Llvm.IOperandCollection{``0},System.Int32,System.Int32)">
            <summary>Creates a slice of the collection</summary>
            <param name="self">Extension this</param>
            <param name="start">Inclusive start index for the slice</param>
            <param name="end">Exclusive end index for the slice</param>
            <typeparam name="T">Type of elements in the container</typeparam>
            <returns>Slice of the collection</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.JIT.GenericValue">
            <summary>LLVM JIT discriminated union for a generic primitive value</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.GenericValue.#ctor(Ubiquity.NET.Llvm.Types.ITypeRef,System.UInt64,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.JIT.GenericValue"/> class with an integer value</summary>
            <param name="t">LLVM type describing the integer bit width</param>
            <param name="value">integer value</param>
            <param name="isSigned">Indicates if the value is signed</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.GenericValue.#ctor(Ubiquity.NET.Llvm.Types.ITypeRef,System.Double)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.JIT.GenericValue"/> class with a floating point value</summary>
            <param name="t">LLVM type describing the floating point format</param>
            <param name="value">floating point value</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.JIT.GenericValue.IntegerBitWidth">
            <summary>Gets the bit width of the integer value</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.JIT.GenericValue.ToInt32">
            <summary>Gets the value as an <see cref="T:System.Int32"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.JIT.GenericValue.ToUInt32">
            <summary>Gets the value as an <see cref="T:System.UInt32"/></summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.GenericValue.ToFloat(Ubiquity.NET.Llvm.Context)">
            <summary>Gets the value as a <see cref="T:System.Single"/></summary>
            <param name="ctx">Context to use for the LLVM float type definition</param>
            <returns>Floating point value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.GenericValue.ToDouble(Ubiquity.NET.Llvm.Context)">
            <summary>Gets the value as a <see cref="T:System.Double"/></summary>
            <param name="ctx">Context to use for the LLVM double type definition</param>
            <returns>Floating point value</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.JIT.IExecutionEngine">
            <summary>Common interface for an Execution engine</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.JIT.IExecutionEngine.TargetMachine">
            <summary>Gets the Target machine for this engine</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.IExecutionEngine.AddEagerlyCompiledModule(Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.Interop.LLVMOrcSymbolResolverFn)">
            <summary>Add a module to the engine</summary>
            <param name="bitcodeModule">The module to add to the engine</param>
            <param name="resolver">Symbol resolver delegate</param>
            <returns>Handle for the module in the engine</returns>
            <remarks>
            <note type="warning">
            Ownership of the <paramref name="bitcodeModule"/> is transfered to the JIT engine and therefore,
            after successful completion of this call the module reports as disposed.
            </note>
            <note type="important">
            The <paramref name="resolver"/> must not throw an exception as the native LLVM JIT engine
            won't understand it and would leave the engine and LLVM in an inconsistent state. If the
            symbol isn't found LLVM generates an error message in debug builds and in all builds, terminates
            the application.
            </note>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.IExecutionEngine.RemoveModule(System.UInt64)">
            <summary>Removes a module from the engine</summary>
            <param name="handle">handle to remove</param>
            <remarks>
            This effectively transfers ownership of the module back to the caller.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.IExecutionEngine.GetFunctionDelegate``1(System.String)">
            <summary>Gets a delegate for the native compiled function in the engine</summary>
            <typeparam name="T">Type of the delegate to retrieve</typeparam>
            <param name="name">Name of the function to get the delegate for</param>
            <returns>Callable delegate for the function or <see langword="null"/> if not found</returns>
            <remarks>
            The type <typeparamref name="T"/> must be a delegate that matches the signature of the actual
            function. The delegate should also have the <see cref="T:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute"/> to indicate the
            calling convention and other marshaling behavior for the function.
            <note type="warning">
            Neither the signature nor the presence of the <see cref="T:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute"/> is
            validated by this method. It is up to the caller to provide an appropriate delegate for the function
            defined in the engine. Incorrect delegates could lead to instabilities and application crashes.
            </note>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.IExecutionEngine.DefaultSymbolResolver(System.String,System.IntPtr)">
            <summary>Implementation of a default symbol resolver</summary>
            <param name="name">Symbol name to resolve</param>
            <param name="ctx">Resolver context</param>
            <returns>Address of the symbol</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.JIT.LazyFunctionCompiler">
            <summary>Delegate for a lazy JIT function generator</summary>
            <returns>Name of the function implementation and the <see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/> it was generated into</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.JIT.ILazyCompileExecutionEngine">
            <summary>Interface for lazy compilation JIT support</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.ILazyCompileExecutionEngine.AddLazyCompiledModule(Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.Interop.LLVMOrcSymbolResolverFn)">
            <summary>Adds a module for lazy compilation</summary>
            <param name="bitcodeModule">The module to add to the engine</param>
            <param name="resolver">Symbol resolver delegate</param>
            <returns>Handle for the module in the engine</returns>
            <remarks>
            <note type="warning">
            <para>For the JIT engine the input <paramref name="bitcodeModule"/> is disconnected from
            the underlying LLVM module as the module is considered fully owned by the engine.</para>
            </note>
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.JIT.LazyCompilationExecutionEngineExtensions">
            <summary>Extension class to add common default behavior for implementations of ILazyCompileExecutionEngine</summary>
            <remarks>
            Once C# supports default interface methods, these can move directly to the interface definition
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.LazyCompilationExecutionEngineExtensions.AddEagerlyCompiledModule(Ubiquity.NET.Llvm.JIT.IExecutionEngine,Ubiquity.NET.Llvm.BitcodeModule)">
            <summary>Adds a module to the JIT for lazy compilation using the engine's default symbol resolver</summary>
            <param name="jit">JIT engine to add the module to</param>
            <param name="module">module to add</param>
            <returns>Handle for the module in the engine</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.LazyCompilationExecutionEngineExtensions.AddLazyCompiledModule(Ubiquity.NET.Llvm.JIT.ILazyCompileExecutionEngine,Ubiquity.NET.Llvm.BitcodeModule)">
            <summary>Adds a module to the JIT for lazy compilation using the engine's default symbol resolver</summary>
            <param name="jit">JIT engine to add the module to</param>
            <param name="module">module to add</param>
            <returns>Handle for the module in the engine</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.JIT.OrcJit">
            <summary>LLVM On Request Compilation (ORC) Just-In-Time (JIT) Engine</summary>
            <remarks>
            The LLVM OrcJIT supports lazy compilation and better resource management for
            clients. For more details on the implementation see the LLVM Documentation.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.OrcJit.#ctor(Ubiquity.NET.Llvm.TargetMachine)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.JIT.OrcJit"/> class for a given target machine.</summary>
            <param name="machine">Target machine for the JIT</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.JIT.OrcJit.TargetMachine">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.OrcJit.AddEagerlyCompiledModule(Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.Interop.LLVMOrcSymbolResolverFn)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.OrcJit.AddLazyCompiledModule(Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.Interop.LLVMOrcSymbolResolverFn)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.OrcJit.RemoveModule(System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.OrcJit.DefaultSymbolResolver(System.String,System.IntPtr)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.OrcJit.GetFunctionDelegate``1(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.OrcJit.AddInteropCallback``1(System.String,``0)">
            <summary>Adds or replaces an interop callback for a global symbol</summary>
            <typeparam name="T">Delegate type for the callback</typeparam>
            <param name="symbolName">Symbol name of the global</param>
            <param name="delegate">Delegate for the callback</param>
            <remarks>
            <note type="warning">
            The delegate is made available to native code as a callback, and therefore it
            must have a lifetime that is at least as long as the callback is registered or
            the lifetime of the JIT engine itself. The direct delegate and any instance
            it may be a member of are handled automatically in the internal implementation
            of this function. However, any data the delegate may rely on is not. (e.g. if
            the object the delegate is a method on a class implementing IDisposable and the
            Dispose method was called on that instance, then the callback could end up operating
            on a disposed object)
            </note>
            <note type="warning">
            The callback **MUST NOT** throw any exceptions out of the callback, as the
            JIT engine doesn't know how to handle them and neither does the JIT'd code.
            </note>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.JIT.OrcJit.Dispose(System.Boolean)">
            <summary>Releases unmanaged resources for this instance</summary>
            <param name="disposing">Indicates if this is from a Dispose (<see langword="true"/>) or a finalizer</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.MemoryBuffer">
            <summary>LLVM MemoryBuffer</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MemoryBuffer.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.MemoryBuffer"/> class from a file</summary>
            <param name="path">Path of the file to load</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MemoryBuffer.#ctor(System.Byte[],System.String)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.MemoryBuffer"/> class from a byte array</summary>
            <param name="data">Array of bytes to copy into the memory buffer</param>
            <param name="name">Name of the buffer (for diagnostics)</param>
            <remarks>
            This constructor makes a copy of the data array as a <see cref="T:Ubiquity.NET.Llvm.MemoryBuffer"/> the memory in the buffer
            is unmanaged memory usable by the LLVM native code. It is released in the Dispose method
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.MemoryBuffer.Size">
            <summary>Gets the size of the buffer</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MemoryBuffer.ToArray">
            <summary>Gets an array of bytes from the buffer</summary>
            <returns>Array of bytes copied from the buffer</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MemoryBuffer.op_Implicit(Ubiquity.NET.Llvm.MemoryBuffer)~System.ReadOnlySpan{System.Byte}">
            <summary>Implicit convert to a <see cref="T:System.ReadOnlySpan`1"/></summary>
            <param name="buffer">Buffer to convert</param>
            <remarks>This is a simple wrapper around calling <see cref="M:Ubiquity.NET.Llvm.MemoryBuffer.Slice(System.Int32,System.Int32)"/> with default parameters</remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MemoryBuffer.Slice(System.Int32,System.Int32)">
            <summary>Create a <see cref="T:System.ReadOnlySpan`1"/> for a slice of the buffer</summary>
            <param name="start">Starting index for the slice [default = 0]</param>
            <param name="length">Length of the slice or -1 to include up to the end of the buffer [default = -1]</param>
            <returns>New Span</returns>
            <remarks>Creates an efficient means of accessing the raw data of a buffer</remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MemoryBuffer.Detach">
            <summary>Detaches the underlying buffer from automatic management</summary>
            <remarks>
            This is used when passing the memory buffer to an LLVM object (like <see cref="T:Ubiquity.NET.Llvm.ObjectFile.TargetBinary"/>
            that takes ownership of the underlying buffer. Any use of the buffer after this point results in
            an <see cref="T:System.InvalidOperationException"/>.
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ConstantAsMetadata">
            <summary>Constant <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> as metadata</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ConstantAsMetadata.Constant">
            <summary>Gets the <see cref="P:Ubiquity.NET.Llvm.ConstantAsMetadata.Constant"/> this node wraps</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.MetadataKind">
            <summary>Enumeration to define metadata type kind</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.MDString">
            <summary>Metadata string</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.ConstantAsMetadata">
            <summary>Constant Value as metadata</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.LocalAsMetadata">
            <summary>Local value as metadata</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DistinctMDOperandPlaceholder">
            <summary>Distinct metadata place holder</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.MDTuple">
            <summary>Metadata tuple</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DILocation">
            <summary>Debug info location</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DIExpression">
            <summary>Debug info expression</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DIGlobalVariableExpression">
            <summary>Debug info global variable expression</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.GenericDINode">
            <summary>Generic Debug info node</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DISubrange">
            <summary>Debug info sub range</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DIEnumerator">
            <summary>Debug info enumerator</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DIBasicType">
            <summary>Debug info basic type</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DIDerivedType">
            <summary>Debug info derived type</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DICompositeType">
            <summary>Debug info composite type</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DISubroutineType">
            <summary>Debug info subroutine type</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DIFile">
            <summary>Debug info file reference</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DICompileUnit">
            <summary>Debug info Compilation Unit</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DISubprogram">
            <summary>Debug info sub program</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DILexicalBlock">
            <summary>Debug info lexical block</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DILexicalBlockFile">
            <summary>Debug info lexical block file</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DINamespace">
            <summary>Debug info namespace</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DIModule">
            <summary>Debug info fro a module</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DITemplateTypeParameter">
            <summary>Debug info for a template type parameter</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DITemplateValueParameter">
            <summary>Debug info for a template value parameter</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DIGlobalVariable">
            <summary>Debug info for a global variable</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DILocalVariable">
            <summary>Debug info for a local variable</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DIObjCProperty">
            <summary>Debug info for an Objective C style property</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DIImportedEntity">
            <summary>Debug info for an imported entity</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DIMacro">
            <summary>Debug info for a macro</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.MetadataKind.DIMacroFile">
            <summary>Debug info for a macro file</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.LlvmMetadata">
            <summary>Root of the LLVM Metadata hierarchy</summary>
            <remarks>In LLVM this is just "Metadata" however that name has the potential
            to conflict with the .NET runtime namespace of the same name, so the name
            is changed in the .NET bindings to avoid the conflict.</remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.LlvmMetadata.ReplaceAllUsesWith(Ubiquity.NET.Llvm.LlvmMetadata)">
            <summary>Replace all uses of this descriptor with another</summary>
            <param name="other">New descriptor to replace this one with</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.LlvmMetadata.ToString">
            <summary>Formats the metadata as a string</summary>
            <returns>Metadata as a string</returns>
        </member>
        <member name="P:Ubiquity.NET.Llvm.LlvmMetadata.Kind">
            <summary>Gets a value indicating this metadata's kind</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.LocalAsMetadata">
            <summary>Contains a local Value as Metadata</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.MDNode">
            <summary>Metadata node for LLVM IR Bitcode modules</summary>
            <remarks>
            <para>Metadata nodes may be uniqued, or distinct. Temporary nodes with
            support for <see cref="M:Ubiquity.NET.Llvm.MDNode.ReplaceAllUsesWith(Ubiquity.NET.Llvm.LlvmMetadata)"/> may be used to
            defer uniqueing until the forward references are known.</para>
            <para>There is limited support for <see cref="M:Ubiquity.NET.Llvm.MDNode.ReplaceAllUsesWith(Ubiquity.NET.Llvm.LlvmMetadata)"/>
            at construction. At construction, if any operand is a temporary or otherwise unresolved
            uniqued node, the node itself is unresolved. As soon as all operands become resolved
            the node will no longer support <see cref="M:Ubiquity.NET.Llvm.MDNode.ReplaceAllUsesWith(Ubiquity.NET.Llvm.LlvmMetadata)"/></para>
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.MDNode.Context">
            <summary>Gets the <see cref="P:Ubiquity.NET.Llvm.MDNode.Context"/> this node belongs to</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.MDNode.IsDeleted">
            <summary>Gets a value indicating whether this node was deleted</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.MDNode.IsTemporary">
            <summary>Gets a value indicating whether this node is a temporary</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.MDNode.IsResolved">
             <summary>Gets a value indicating whether this node is resolved</summary>
             <remarks>
             <para>If <see cref="P:Ubiquity.NET.Llvm.MDNode.IsTemporary"/> is <see langword="true"/>, then this always
             returns <see langword="false"/>; if <see cref="P:Ubiquity.NET.Llvm.MDNode.IsDistinct"/> is <see langword="true"/>,
             this always returns <see langword="true"/>.</para>
            
             <para>If <see cref="P:Ubiquity.NET.Llvm.MDNode.IsUniqued"/> is <see langword="true"/> then this returns <see langword="true"/>
             if this node has already dropped RAUW support (because all operands are resolved).</para>
             </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.MDNode.IsUniqued">
            <summary>Gets a value indicating whether this node is uniqued</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.MDNode.IsDistinct">
            <summary>Gets a value indicating whether this node is distinct</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.MDNode.Operands">
            <summary>Gets the operands for this node, if any</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MDNode.ReplaceAllUsesWith(Ubiquity.NET.Llvm.LlvmMetadata)">
            <summary>Replace all uses of this node with a new node</summary>
            <param name="other">Node to replace this one with</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MDNode.GetOperand``1(System.Int32)">
            <summary>Gets an operand by index as a specific type</summary>
            <typeparam name="T">Type of the operand</typeparam>
            <param name="index">Index of the operand</param>
            <returns>Operand</returns>
            <exception cref="T:System.InvalidCastException">When the operand is not castable to <typeparamref name="T"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">When the index is out of range for the operands of this node</exception>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MDNode.GetOperandString(System.Int32)">
            <summary>Gets a string operand by index</summary>
            <param name="index">Index of the operand</param>
            <returns>String value of the operand</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.MDString">
            <summary>Stores a string in Metadata</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MDString.ToString">
            <summary>Gets the string from the metadata node</summary>
            <returns>String this node wraps</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.MDTuple">
            <summary>Tuple of Metadata nodes</summary>
            <remarks>
            This acts as a container of nodes in the metadata hierarchy
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.MetadataAsValue">
            <summary>Wraps metadata as a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.MetadataAsValue.Operands">
            <summary>Gets a list of the operands for the Metadata</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.MetadataOperandCollection">
            <summary>Support class to provide read/update semantics to the operands of a container element</summary>
            <remarks>
            This class is used to implement Operand lists of elements including sub lists based on an offset.
            The latter case is useful for types that expose some fixed set of operands as properties and some
            arbitrary number of additional items as operands.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.MetadataOperandCollection.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.MetadataOperandCollection.Count">
            <summary>Gets the count of operands in this collection</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MetadataOperandCollection.GetEnumerator">
            <summary>Gets an enumerator for the operands in this collection</summary>
            <returns>Enumerator of operands</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MetadataOperandCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets an enumerator for the operands in this collection</summary>
            <returns>Enumerator of operands</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MetadataOperandCollection.Contains(Ubiquity.NET.Llvm.LlvmMetadata)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.MetadataOperandCollection.GetOperand``1(System.Index)">
            <summary>Specialized indexer to get the element as a specific derived type</summary>
            <typeparam name="TItem">Type of the element (must be derived from <see cref="T:Ubiquity.NET.Llvm.LlvmMetadata"/></typeparam>
            <param name="i">index for the item</param>
            <returns>Item at the specified index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is out of range for the collection</exception>
            <exception cref="T:System.InvalidCastException">If the element at the index is not castable to <typeparamref name="TItem"/></exception>
            <remarks>This provides a common (and likely internally optimized) means of getting an element as a specific type</remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ModuleFlag">
            <summary>Module Flags Tuple for a module</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ModuleFlag.#ctor(Ubiquity.NET.Llvm.ModuleFlagBehavior,System.String,Ubiquity.NET.Llvm.LlvmMetadata)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.ModuleFlag"/> class.</summary>
            <param name="behavior">Behavior for the flag</param>
            <param name="name">Name of the flag</param>
            <param name="metadata">Metadata for the flag</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ModuleFlag.Behavior">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.ModuleFlagBehavior"/> options for this module flag</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ModuleFlag.Name">
            <summary>Gets the name of flag</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ModuleFlag.Metadata">
            <summary>Gets the Metadata for this flag</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.NamedMDNode">
            <summary>Wraps an LLVM NamedMDNode</summary>
            <remarks>Despite its name a NamedMDNode is not itself an MDNode. It is owned directly by a
            a <see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/> and contains a list of <see cref="T:Ubiquity.NET.Llvm.MDNode"/> operands.</remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.NamedMDNode.Name">
            <summary>Gets the name of the node</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.NamedMDNode.Operands">
            <summary>Gets the operands for the node</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.NamedMDNode.ParentModule">
            <summary>Gets the module that owns this node</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.NamedMDNode.EraseFromParent">
            <summary>Erases this node from its parent</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.OperandBundleNames">
            <summary>Static class to hold constant strings for well known operand bundle tag names</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.OperandBundleNames.DeOpt">
            <summary>Name of the well-known deopt operand bundle</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.OperandBundleNames.Funclet">
            <summary>Name of the well-known funclet operand bundle</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.OperandBundleNames.GcTransition">
            <summary>Name of the well-known gc-transition operand bundle</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ValueAsMetadata">
            <summary>Used to wrap an <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> in the Metadata hierarchy</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ValueAsMetadata.Value">
            <summary>Gets the <see cref="P:Ubiquity.NET.Llvm.ValueAsMetadata.Value"/> this node wraps</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ValueAsMetadata.Type">
            <summary>Gets the type of <see cref="P:Ubiquity.NET.Llvm.ValueAsMetadata.Value"/> this node wraps</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ValueAsMetadata.Context">
            <summary>Gets the <see cref="P:Ubiquity.NET.Llvm.ValueAsMetadata.Context"/> for the <see cref="P:Ubiquity.NET.Llvm.ValueAsMetadata.Value"/> this node wraps</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ValueAsMetadata.op_Implicit(Ubiquity.NET.Llvm.ValueAsMetadata)~Ubiquity.NET.Llvm.Values.Value">
            <summary>Implicit conversion to <see cref="P:Ubiquity.NET.Llvm.ValueAsMetadata.Value"/></summary>
            <param name="md"><see cref="T:Ubiquity.NET.Llvm.ValueAsMetadata"/> to get the value for</param>
            <remarks>This is a simple wrapper around the <see cref="P:Ubiquity.NET.Llvm.ValueAsMetadata.Value"/> property</remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ObjectFile.Relocation">
            <summary>Relocation entry in an <see cref="N:Ubiquity.NET.Llvm.ObjectFile"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Relocation.Offset">
            <summary>Gets the offset for this relocation</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Relocation.Symbol">
            <summary>Gets the symbol associated with this relocation</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Relocation.Description">
            <summary>Gets the kind of relocation as a string for display purposes</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Relocation.Value">
            <summary>Gets the relocation value as a string</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Relocation.Kind">
            <summary>Gets the relocation type for this relocation</summary>
            <remarks>The meaning of the values are target obj file format specific, there is no standard</remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Relocation.Section">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.ObjectFile.Section"/> this relocation belongs to</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Relocation.Equals(System.Object)">
            <summary>Performs equality checks against an <see cref="T:System.Object"/></summary>
            <param name="obj">object to test for equality with this instance</param>
            <returns><see langword="true"/> if <paramref name="obj"/> is equal to this instance</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Relocation.GetHashCode">
            <summary>Gets a hash code for this <see cref="T:Ubiquity.NET.Llvm.ObjectFile.Relocation"/></summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Relocation.op_Equality(Ubiquity.NET.Llvm.ObjectFile.Relocation,Ubiquity.NET.Llvm.ObjectFile.Relocation)">
            <summary>Equality comparison</summary>
            <param name="left">left side of comparison</param>
            <param name="right">right side of comparison</param>
            <returns>Result of equality test</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Relocation.op_Inequality(Ubiquity.NET.Llvm.ObjectFile.Relocation,Ubiquity.NET.Llvm.ObjectFile.Relocation)">
            <summary>Inequality comparison</summary>
            <param name="left">left side of comparison</param>
            <param name="right">right side of comparison</param>
            <returns>Result of inequality test</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Relocation.Equals(Ubiquity.NET.Llvm.ObjectFile.Relocation)">
            <summary>Performs equality checks against another <see cref="T:Ubiquity.NET.Llvm.ObjectFile.Relocation"/></summary>
            <param name="other">object to test for equality with this instance</param>
            <returns><see langword="true"/> if <paramref name="other"/> is equal to this instance</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ObjectFile.Section">
            <summary>Section in an <see cref="T:Ubiquity.NET.Llvm.ObjectFile.TargetBinary"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Section.Name">
            <summary>Gets the name of the section</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Section.ContainingBinary">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.ObjectFile.TargetBinary"/> this section belongs to</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Section.Relocations">
            <summary>Gets the Relocations in this <see cref="T:Ubiquity.NET.Llvm.ObjectFile.TargetBinary"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Section.Contents">
            <summary>Gets the contents of the section</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Section.ContainsSymbol(Ubiquity.NET.Llvm.ObjectFile.Symbol)">
            <summary>Tests whether the section contains a given symbol</summary>
            <param name="symbol">Symbol to test for</param>
            <returns><see langword="true" /> if the section contains <paramref name="symbol"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Section.MoveToContainingSection(Ubiquity.NET.Llvm.ObjectFile.Symbol)">
            <summary>Move the iterator to the section containing the provided symbol</summary>
            <param name="symbol">symbol to find the section for</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Section.Address">
            <summary>Gets the address of the section</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Section.Equals(System.Object)">
            <summary>Tests an <see cref="T:System.Object"/> for equality</summary>
            <param name="obj"><see cref="T:System.Object"/> to compare with this instance</param>
            <returns><see langword="true"/> if the </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Section.GetHashCode">
            <summary>Gets a hash code for this <see cref="T:Ubiquity.NET.Llvm.ObjectFile.Section"/></summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Section.op_Equality(Ubiquity.NET.Llvm.ObjectFile.Section,Ubiquity.NET.Llvm.ObjectFile.Section)">
            <summary>Equality comparison</summary>
            <param name="left">left side of comparison</param>
            <param name="right">right side of comparison</param>
            <returns>Result of equality test</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Section.op_Inequality(Ubiquity.NET.Llvm.ObjectFile.Section,Ubiquity.NET.Llvm.ObjectFile.Section)">
            <summary>Inequality comparison</summary>
            <param name="left">left side of comparison</param>
            <param name="right">right side of comparison</param>
            <returns>Result of inequality test</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Section.Equals(Ubiquity.NET.Llvm.ObjectFile.Section)">
            <summary>Tests an <see cref="T:Ubiquity.NET.Llvm.ObjectFile.Section"/> for equality</summary>
            <param name="other"><see cref="T:Ubiquity.NET.Llvm.ObjectFile.Section"/> to compare with this instance</param>
            <returns><see langword="true"/> if the </returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ObjectFile.Symbol">
            <summary>Symbol in an <see cref="T:Ubiquity.NET.Llvm.ObjectFile.TargetBinary"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Symbol.ContainingBinary">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.ObjectFile.TargetBinary"/> this symbol belongs to</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Symbol.Section">
            <summary>Gets the section this symbol belongs to</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Symbol.Name">
            <summary>Gets the name of the symbol</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Symbol.Address">
            <summary>Gets the address of the symbol</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.Symbol.Size">
            <summary>Gets the size of the symbol</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Symbol.Equals(System.Object)">
            <summary>Tests an <see cref="T:System.Object"/> for equality</summary>
            <param name="obj"><see cref="T:System.Object"/> to compare with this instance</param>
            <returns><see langword="true"/> if the </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Symbol.GetHashCode">
            <summary>Gets a hash code for this <see cref="P:Ubiquity.NET.Llvm.ObjectFile.Symbol.Section"/></summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Symbol.op_Equality(Ubiquity.NET.Llvm.ObjectFile.Symbol,Ubiquity.NET.Llvm.ObjectFile.Symbol)">
            <summary>Equality comparison</summary>
            <param name="left">left side of comparison</param>
            <param name="right">right side of comparison</param>
            <returns>Result of equality test</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Symbol.op_Inequality(Ubiquity.NET.Llvm.ObjectFile.Symbol,Ubiquity.NET.Llvm.ObjectFile.Symbol)">
            <summary>Inequality comparison</summary>
            <param name="left">left side of comparison</param>
            <param name="right">right side of comparison</param>
            <returns>Result of inequality test</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.Symbol.Equals(Ubiquity.NET.Llvm.ObjectFile.Symbol)">
            <summary>Tests an <see cref="T:Ubiquity.NET.Llvm.ObjectFile.Symbol"/> for equality</summary>
            <param name="other"><see cref="T:Ubiquity.NET.Llvm.ObjectFile.Symbol"/> to compare with this instance</param>
            <returns><see langword="true"/> if the </returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ObjectFile.BinaryKind">
            <summary>Enumeration for kinds of binary/object files</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.Archive">
            <summary>Archive File</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.MachOUniversalBinary">
            <summary>Mach-O Universal Binary file</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.CoffImportFile">
            <summary>COFF Import File</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.LlvmIR">
            <summary>LLVM IR</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.WinRes">
            <summary>Windows Resource (.res) file</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.Coff">
            <summary>COFF Object file</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.Elf32LittleEndian">
            <summary>ELF 32-bit, little endian</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.Elf32BigEndian">
            <summary>ELF 32-bit, big endian</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.Elf64LittleEndian">
            <summary>ELF 64-bit, little endian</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.Elf64BigEndian">
            <summary>ELF 64-bit, big endian</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.MachO32LittleEndian">
            <summary>Mach-O 32-bit, little endian</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.MachO32BigEndian">
            <summary>Mach-O 32-bit, big endian</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.MachO64LittleEndian">
            <summary>Mach-O 64-bit, little endian</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.MachO64BigEndian">
            <summary>Mach-O 64-bit, big endian</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.ObjectFile.BinaryKind.Wasm">
            <summary>Web Assembly</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ObjectFile.TargetBinary">
            <summary>Object file information</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.TargetBinary.Kind">
            <summary>Gets the kind of binary this instance contains</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.TargetBinary.Symbols">
            <summary>Gets the symbols in this <see cref="T:Ubiquity.NET.Llvm.ObjectFile.TargetBinary"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ObjectFile.TargetBinary.Sections">
            <summary>Gets the sections in this <see cref="T:Ubiquity.NET.Llvm.ObjectFile.TargetBinary"/></summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ObjectFile.TargetBinary.#ctor(Ubiquity.NET.Llvm.MemoryBuffer,Ubiquity.NET.Llvm.Context)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.ObjectFile.TargetBinary"/> class.</summary>
            <param name="buffer">Memory buffer containing the raw binary data of the object file</param>
            <param name="context">Context for the object file</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources._0_is_not_a_valid_option">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a valid option.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources._0_is_not_a_valid_value_for_a_compare_predicate">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a valid value for a compare predicate.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.A_pointer_to_a_function_is_required_for_an_indirect_call">
            <summary>
              Looks up a localized string similar to A pointer to a function is required for an indirect call.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Alignment_only_allowed_on_memory_instructions">
            <summary>
              Looks up a localized string similar to Alignment can only be set for instructions dealing with memory read/write (alloca, load, store).
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.APInt_exceeds_size_of_Int64">
            <summary>
              Looks up a localized string similar to Arbitrary precision integer exceeds size of System.Int64 integer.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.APInt_exceeds_size_of_UInt64">
            <summary>
              Looks up a localized string similar to Arbitrary precision integer exceeds size of System.UInt64 integer.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Argument_0_does_not_contain_debug_type_information">
            <summary>
              Looks up a localized string similar to 	Argument {0} does not contain debug type information.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Argument_0_is_null">
            <summary>
              Looks up a localized string similar to 	Argument {0} is null.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Array_type_reference_expected">
            <summary>
              Looks up a localized string similar to Array type reference expected.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Assert_Should_have_a_valid_non_temp_type_by_now">
            <summary>
              Looks up a localized string similar to Should have a valid non temp type by now.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Assert_Should_not_get_a_null_pointer_from_LLVM">
            <summary>
              Looks up a localized string similar to Should not get a null pointer from LLVM.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Assert_Unexpected_Debug_state">
            <summary>
              Looks up a localized string similar to Unexpected Debug state.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Attribute_0_does_not_support_a_value">
            <summary>
              Looks up a localized string similar to Attribute {0} does not support a value.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Attribute_0_does_not_support_an_argument">
            <summary>
              Looks up a localized string similar to Attribute &apos;{0}&apos; does not support an argument.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Attribute_0_requires_a_value">
            <summary>
              Looks up a localized string similar to Attribute {0} requires a value.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Attribute_not_allowed_on_function_parameter">
            <summary>
              Looks up a localized string similar to Attribute not allowed on function parameter.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Attribute_not_allowed_on_function_Return">
            <summary>
              Looks up a localized string similar to Attribute not allowed on function Return.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Attribute_not_allowed_on_functions">
            <summary>
              Looks up a localized string similar to Attribute not allowed on functions.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Block_already_exists_in_function">
            <summary>
              Looks up a localized string similar to Basic block already exists in the function.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Call_site_argument_type_mismatch_for_function_0_at_index_1_argType_equals_2_signatureType_equals_3">
            <summary>
              Looks up a localized string similar to Call site argument type mismatch for function {0} at index {1}; argType={2}; signatureType={3}.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_add_a_block_belonging_to_a_different_function">
            <summary>
              Looks up a localized string similar to Cannot add a block belonging to a different function.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_change_type_of_an_extended_property_once_set">
            <summary>
              Looks up a localized string similar to  Cannot change type of an extended property once set.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_create_named_constant_struct_with_type_from_another_context">
            <summary>
              Looks up a localized string similar to Cannot create named constant struct with type from another context.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_determine_layout_for_element__The_element_must_have_an_explicit_layout_or_the_module_has_a_layout_to_use">
            <summary>
              Looks up a localized string similar to Cannot determine layout for element; The element must have an explicit layout or the module has a layout to use.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_get_element_of_unsized_opaque_structures">
            <summary>
              Looks up a localized string similar to Cannot get element of unsized/opaque structures.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_get_null_for_labels_and_opaque_types">
            <summary>
              Looks up a localized string similar to Cannot get a Null value for labels, functions and opaque types.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_insert_when_no_block_module_is_available">
            <summary>
              Looks up a localized string similar to Cannot insert when no block/module is available.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_load_a_value_for_an_opaque_or_unsized_type">
            <summary>
              Looks up a localized string similar to Cannot load a value for an opaque or unsized type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_mix_types_from_different_contexts">
            <summary>
              Looks up a localized string similar to Cannot mix types from different contexts.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_replace_a_temporary_with_another_temporary">
            <summary>
              Looks up a localized string similar to Cannot replace a temporary with another temporary.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_Replace_all_uses_of_a_null_descriptor">
            <summary>
              Looks up a localized string similar to Cannot Replace all uses of a null descriptor.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_replace_non_temporary_DIType_with_a_new_Type">
            <summary>
              Looks up a localized string similar to Cannot replace non temporary DIType with a new Type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_replace_non_temporary_or_resolved_MDNode">
            <summary>
              Looks up a localized string similar to Cannot replace non temporary or resolved MDNode.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_Reset_Type_to_null">
            <summary>
              Looks up a localized string similar to Cannot reset the native DIType to null.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Cannot_set_unwindDestination_for_instruction_that_unwinds_to_caller">
            <summary>
              Looks up a localized string similar to Cannot set UnwindDestination for instruction that unwinds to caller.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Condition_value_must_be_an_i1_or_vector_of_i1">
            <summary>
              Looks up a localized string similar to Condition value must be an i1 or vector of i1.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Context_for_the_handle_provided_doesn_t_match_the_context_for_this_cache">
            <summary>
              Looks up a localized string similar to Context for the handle provided doesn&apos;t match the context for this cache.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Context_mismatch_cannot_cache_modules_from_multiple_contexts">
            <summary>
              Looks up a localized string similar to Context mismatch - cannot cache modules from multiple contexts.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Could_not_parse_bit_code_from_buffer">
            <summary>
              Looks up a localized string similar to Could not parse bit code from buffer.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.ElementType_doesn_t_match_array_element_type">
            <summary>
              Looks up a localized string similar to ElementType doesn&apos;t match array element type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Error_writing_bit_code_file_0">
            <summary>
              Looks up a localized string similar to Error writing bit-code file &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_a_32_bit_value_for_alignment">
            <summary>
              Looks up a localized string similar to Expected a 32 bit value for alignment.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_a_32_bit_value_for_stack_alignment">
            <summary>
              Looks up a localized string similar to Expected a 32 bit value for stack alignment.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_a_pointer_value">
            <summary>
              Looks up a localized string similar to Expected a pointer value.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_a_primitive_type">
            <summary>
              Looks up a localized string similar to Expected a primitive type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_a_sequence_type">
            <summary>
              Looks up a localized string similar to Expected a sequence type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_ConstantAsMetadata_for_first_operand">
            <summary>
              Looks up a localized string similar to Expected ConstantAsMetadata for first operand.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_ConstantInt_wrapped_in_first_operand">
            <summary>
              Looks up a localized string similar to Expected ConstantInt wrapped in first operand.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_MDString_as_second_operand">
            <summary>
              Looks up a localized string similar to Expected MDString as second operand.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_node_with_3_operands">
            <summary>
              Looks up a localized string similar to Expected node with 3 operands.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_pointer_to_function">
            <summary>
              Looks up a localized string similar to Expected pointer to function.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_pointer_to_integral_type">
            <summary>
              Looks up a localized string similar to Expected pointer to integral type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_pointer_type">
            <summary>
              Looks up a localized string similar to Expected pointer type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_pointer_value">
            <summary>
              Looks up a localized string similar to Expected pointer value.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_to_get_a_debug_function_that_describes_the_provided_function">
            <summary>
              Looks up a localized string similar to Expected to get a debug function that describes the provided function.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expected_to_get_a_module_bound_to_the_specified_context">
            <summary>
              Looks up a localized string similar to Expected to get a module bound to the specified context.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expecting_an_integer_or_pointer_type">
            <summary>
              Looks up a localized string similar to Expecting an integer or pointer type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Expecting_an_integer_type">
            <summary>
              Looks up a localized string similar to Expecting an integer type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Failed_to_remove_module_from_engine_0">
            <summary>
              Looks up a localized string similar to Failed to remove module from engine &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Function_0_not_found">
            <summary>
              Looks up a localized string similar to Function {0} not found.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.GEP_index_arguments_must_be_integers">
            <summary>
              Looks up a localized string similar to GEP index arguments must be integers.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Incompatible_types_destination_pointer_must_be_same_type_0_1">
             <summary>
               Looks up a localized string similar to Incompatible types: destination pointer must be of the same type as the value stored.
            Types are:
                Destination: {0}
                Value: {1}.
             </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Incorrect_context_for_module">
            <summary>
              Looks up a localized string similar to Incorrect context for module.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Index_exceeds_number_of_members_in_the_type">
            <summary>
              Looks up a localized string similar to Index exceeds number of members in the type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Index_for_parameters_must_be_the_actual_position_of_the_argument">
            <summary>
              Looks up a localized string similar to Index for parameters must be the actual position of the argument.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Instruction_is_from_a_different_block">
            <summary>
              Looks up a localized string similar to Instruction is from a different block.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Integer_bit_width_must_be_greater_than_0">
            <summary>
              Looks up a localized string similar to integer bit width must be greater than 0.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Integer_type_expected">
            <summary>
              Looks up a localized string similar to Integer type expected.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Integer_type_required">
            <summary>
              Looks up a localized string similar to Integer type required.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Intrinsic_0_is_not_overloaded_and_therefore_does_not_require_type_arguments">
            <summary>
              Looks up a localized string similar to intrinsic {0} is not overloaded and therefore does not require type arguments.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Invalid_EngineKind">
            <summary>
              Looks up a localized string similar to Invalid EngineKind.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Invalid_handle_provided">
            <summary>
              Looks up a localized string similar to Invalid handle provided.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Linking_modules_from_different_contexts_is_not_allowed">
            <summary>
              Looks up a localized string similar to Linking modules from different contexts is not allowed.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.LLVM_only_allows_one_DICompileUnit_per_module">
            <summary>
              Looks up a localized string similar to DICompileUnit already defined, LLVM only allows one DICompileUnit per module..
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Location_does_not_describe_the_function_containing_the_provided_instruction">
            <summary>
              Looks up a localized string similar to Location does not describe the function containing the provided instruction.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Location_does_not_describe_the_specified_block_s_containing_function">
            <summary>
              Looks up a localized string similar to Location does not describe the specified block&apos;s containing function.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Marshaling_of_Generic_delegate_types_to_a_native_callbacks_is_not_supported">
            <summary>
              Looks up a localized string similar to Marshaling of Generic delegate types to a native callbacks is not supported.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Marshalling_a_delegate_to_a_native_callback_requires_an_UnmanagedFunctionPointerAttribute_for_the_delegate_type">
            <summary>
              Looks up a localized string similar to Marshalling a delegate to a native callback requires an UnmanagedFunctionPointerAttribute for the delegate type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Mismatched_context">
            <summary>
              Looks up a localized string similar to Mismatched context.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Mismatched_modules_for_Comdat">
            <summary>
              Looks up a localized string similar to Mismatched modules for Comdat.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Mismatched_parameter_count_with_call_site">
            <summary>
              Looks up a localized string similar to Mismatched parameter count with call site.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Mismatched_scopes">
            <summary>
              Looks up a localized string similar to Mismatched scopes.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Mismatched_scopes_for_location_and_variable">
            <summary>
              Looks up a localized string similar to Mismatched scopes for location and variable.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.MismatchedType_0_member_type_equals_1_value_type_equals_2">
            <summary>
              Looks up a localized string similar to 	[{0}]: member type={1}; value type={2}.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Module_and_instruction_builder_must_come_from_the_same_context">
            <summary>
              Looks up a localized string similar to Module and instruction builder must come from the same context.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Module_link_error">
            <summary>
              Looks up a localized string similar to Module link error.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Module_needs_Layout_to_build_basic_types">
            <summary>
              Looks up a localized string similar to Module needs Layout to build basic types.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Module_was_explicitly_destroyed_or_ownership_transferred_to_native_library">
            <summary>
              Looks up a localized string similar to Module was explicitly destroyed or ownership transferred to native library.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Name_cannot_be_null_or_empty">
            <summary>
              Looks up a localized string similar to Name cannot be null or empty.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Non_pointer_type_expected">
            <summary>
              Looks up a localized string similar to Non-pointer type expected.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Number_of_values_provided_must_match_the_number_of_elements_in_the_specified_type">
            <summary>
              Looks up a localized string similar to Number of values provided must match the number of elements in the specified type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.One_or_more_parameter_types_are_not_valid">
             <summary>
               Looks up a localized string similar to One or more parameter types are not valid:
            .
             </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.One_or_more_values_provided_do_not_match_the_corresponding_member_type_">
            <summary>
              Looks up a localized string similar to One or more values provided do not match the corresponding member type:.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Pointer_to_a_structure_expected">
            <summary>
              Looks up a localized string similar to Pointer to a structure expected.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Pointer_type_doesn_t_match_the_value_type">
            <summary>
              Looks up a localized string similar to Pointer type doesn&apos;t match the value type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Pointer_type_expected">
            <summary>
              Looks up a localized string similar to Pointer type expected.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Pointer_type_reference_expected">
            <summary>
              Looks up a localized string similar to Pointer type reference expected.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Pointer_value_expected">
            <summary>
              Looks up a localized string similar to Pointer value expected.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Return_instruction_for_void_function_must_not_have_a_value">
            <summary>
              Looks up a localized string similar to Return instruction for void function must not have a value.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Return_type_does_not_have_debug_information">
            <summary>
              Looks up a localized string similar to Return type does not have debug information.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Scope_does_not_describe_the_function_containing_the_provided_instruction">
            <summary>
              Looks up a localized string similar to Scope does not describe the function containing the provided instruction.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Selected_values_must_have_the_same_type">
            <summary>
              Looks up a localized string similar to Selected values must have the same type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Signature_requires_debug_type_information">
            <summary>
              Looks up a localized string similar to Signature requires debug type information.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Source_and_destination_arguments_are_the_same_value">
            <summary>
              Looks up a localized string similar to Source and destination arguments are the same value.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Specified_bit_code_file_does_not_exist">
            <summary>
              Looks up a localized string similar to Specified bit-code file does not exist.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Specified_parameter_index_exceeds_the_number_of_parameters_in_the_function">
            <summary>
              Looks up a localized string similar to Specified parameter index exceeds the number of parameters in the function.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Stack_alignment_value_must_be_a_power_of_2">
            <summary>
              Looks up a localized string similar to Stack alignment value must be a power of 2.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.start_plus_length_exceeds_size_of_buffer">
            <summary>
              Looks up a localized string similar to start + length exceeds size of buffer.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Struct_type_used_as_basis_for_a_union_must_not_have_a_body">
            <summary>
              Looks up a localized string similar to Struct type used as basis for a union must not have a body.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.structure_must_have_at_least_one_element">
            <summary>
              Looks up a localized string similar to structure must have at least one element.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Temporaries_must_be_resolved_before_finalizing_debug_information">
            <summary>
              Looks up a localized string similar to Temporaries must be resolved before finalizing debug information:.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.There_must_be_at_least_one_index_argument">
            <summary>
              Looks up a localized string similar to There must be at least one index argument.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Triple_specified_for_the_module_doesn_t_match_target_machine">
            <summary>
              Looks up a localized string similar to Triple specified for the module doesn&apos;t match target machine.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Type_does_not_have_associated_Debug_type_from_which_to_construct_a_Member">
            <summary>
              Looks up a localized string similar to Type does not have associated Debug type from which to construct a Member.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Type_does_not_have_associated_Debug_type_from_which_to_construct_a_pointer_type">
            <summary>
              Looks up a localized string similar to Type does not have associated Debug type from which to construct a pointer type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Type_does_not_have_associated_Debug_type_from_which_to_construct_an_array_type">
            <summary>
              Looks up a localized string similar to Type does not have associated Debug type from which to construct an array type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Type_must_be_a_floating_point_data_type">
            <summary>
              Looks up a localized string similar to Type must be a floating point data type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Type_must_be_an_integral_data_type">
            <summary>
              Looks up a localized string similar to Type must be an integral data type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Type_must_be_sized_to_get_target_size_information">
            <summary>
              Looks up a localized string similar to Type must be sized to get target size information.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Types_of_binary_operators_must_be_identical">
            <summary>
              Looks up a localized string similar to Types of binary operators must be identical.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Unknown_handle_value">
            <summary>
              Looks up a localized string similar to Unknown handle value.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Unresolved_Debug_temporary_0">
            <summary>
              Looks up a localized string similar to 	{0}.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Unresolved_Symbol_0_1">
            <summary>
              Looks up a localized string similar to Unresolved Symbol: &apos;{0}&apos;; {1}.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Unsupported_Architecture">
            <summary>
              Looks up a localized string similar to Unsupported Architecture.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Value_already_set">
            <summary>
              Looks up a localized string similar to Value already set.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Value_for_return_must_match_the_function_signature_s_return_type">
            <summary>
              Looks up a localized string similar to Value for return must match the function signature&apos;s return type.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Value_not_set">
            <summary>
              Looks up a localized string similar to Value not set.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Vector_type_reference_expected">
            <summary>
              Looks up a localized string similar to Vector type reference expected.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.When_condition_is_a_vector__selected_values_must_be_a_vector_of_the_same_size">
            <summary>
              Looks up a localized string similar to When condition is a vector, selected values must be a vector of the same size.
            </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Properties.Resources.Wrapped_node_is_null">
            <summary>
              Looks up a localized string similar to Wrapped node is null.
            </summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.ScopeStack`1">
            <summary>Simple implementation of common Variable scoping</summary>
            <typeparam name="T">Type of the values to associate with the symbol name</typeparam>
            <remarks>
            <para>In essence, this is a stack of Dictionaries that is intended for use in code generation.
            Most languages have some sort of notion of symbol scopes and name lookups. This implements
            the common case of nested scopes where a new 'local scope' may override some of the symbols
            in a parent scope. Any values in any parent not overridden by the child are visible to the
            child scope.</para>
            <para>Usually, though not required, the type <typeparamref name="T"/> is <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>
            or <see cref="T:Ubiquity.NET.Llvm.Instructions.Alloca"/> to allow a code generator to track a value or mutable variable
            with the source name in multiple scope layers.</para>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ScopeStack`1.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.ScopeStack`1"/> class.</summary>
            <remarks>
            The stack is initialized with a "global" scope ready for use without additional
            initialization. Subsequent scopes for the stack are generated by calling the
            <see cref="M:Ubiquity.NET.Llvm.ScopeStack`1.EnterScope"/> method.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ScopeStack`1.Depth">
            <summary>Gets the depth of the stack</summary>
            <remarks>The depth starts as 1 since the stack starts at the global scope.</remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ScopeStack`1.EnterScope">
            <summary>Starts a new scope</summary>
            <returns><see cref="T:System.IDisposable"/> to enable automatic restore of the scope in RAII style patterns</returns>
            <remarks>
            A new scope is pushed on the stack and remains active until the <see cref="M:System.IDisposable.Dispose"/> method
            of the return is called. Normally, code generation does this with a language provided means of ensuring the
            Dispose method is called even when an exception occurs. (i.e. C# 'using' or try/finally)
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.ScopeStack`1.Item(System.String)">
            <summary>Gets or sets the value of a symbol in scope</summary>
            <param name="name">name of the symbol</param>
            <returns>Value for the symbol</returns>
            <remarks>
            Getting a symbol value searches all scopes, starting with the current scope.
            Setting a symbol value will only set the value in the current scope. (e.g.
            if the value does not exist in the current scope a new entry is made for it
            in the current scope, even if some outer scope has the same name.
            </remarks>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If the <paramref name="name"/> wasn't found in the active or parent scopes</exception>
        </member>
        <member name="M:Ubiquity.NET.Llvm.ScopeStack`1.TryGetValue(System.String,`0@)">
            <summary>Attempts to retrieve a value from the stack</summary>
            <param name="name">Name of the value</param>
            <param name="value">Value</param>
            <returns><see langword="true"/> if the symbol was found from a search of the scopes</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.CodeGenOpt">
            <summary>Optimization level for target code generation</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.CodeGenOpt.None">
            <summary>No optimization</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.CodeGenOpt.Less">
            <summary>Minimal optimization</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.CodeGenOpt.Default">
            <summary>Default optimization</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.CodeGenOpt.Aggressive">
            <summary>Aggressive optimizations</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.OptimizationSizeLevel">
            <summary>Optimization Size preference</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.OptimizationSizeLevel.None">
            <summary>Default optimization</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.OptimizationSizeLevel.Os">
            <summary>Equivalent to -Os</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.OptimizationSizeLevel.Oz">
            <summary>Equivalent to -Oz</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.RelocationMode">
            <summary>Relocation type for target code generation</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.RelocationMode.Default">
            <summary>Default relocation model for the target</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.RelocationMode.Static">
            <summary>Static relocation model</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.RelocationMode.PositionIndependent">
            <summary>Position independent relocation model</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.RelocationMode.Dynamic">
            <summary>Dynamic relocation model</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.CodeModel">
            <summary>Code model to use for target code generation</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.CodeModel.Default">
            <summary>Default code model for the target</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.CodeModel.JitDefault">
            <summary>Default code model for JIT to the target</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.CodeModel.Tiny">
            <summary>Tiny code model</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.CodeModel.Small">
            <summary>Small code model</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.CodeModel.Kernel">
            <summary>Kernel code model</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.CodeModel.Medium">
            <summary>Medium code model</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.CodeModel.Large">
            <summary>Large code model</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.CodeGenFileType">
            <summary>Output file type for target code generation</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.CodeGenFileType.AssemblySource">
            <summary>Generate assembly source file</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.CodeGenFileType.ObjectFile">
            <summary>Generate target object file</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Target">
            <summary>LLVM Target Instruction Set Architecture</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Target.Name">
            <summary>Gets the name of this target</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Target.Description">
            <summary>Gets the description of this target</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Target.HasJIT">
            <summary>Gets a value indicating whether this target has JIT support</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Target.HasTargetMachine">
            <summary>Gets a value indicating whether this target has a TargetMachine initialized</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Target.HasAsmBackEnd">
            <summary>Gets a value indicating whether this target has an Assembly code generating back end initialized</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Target.CreateTargetMachine(Ubiquity.NET.Llvm.Triple,System.String,System.String,Ubiquity.NET.Llvm.CodeGenOpt,Ubiquity.NET.Llvm.RelocationMode,Ubiquity.NET.Llvm.CodeModel)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.TargetMachine"/> for the target and specified parameters</summary>
            <param name="triple">Target triple for this machine (e.g. -mtriple)</param>
            <param name="cpu">CPU for this machine (e.g. -mcpu)</param>
            <param name="features">Features for this machine (e.g. -mattr...)</param>
            <param name="optLevel">Optimization level</param>
            <param name="relocationMode">Relocation mode for generated code</param>
            <param name="codeModel"><see cref="T:Ubiquity.NET.Llvm.CodeModel"/> to use for generated code</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.TargetMachine"/> based on the specified parameters</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Target.CreateTargetMachine(System.String,System.String,System.String,Ubiquity.NET.Llvm.CodeGenOpt,Ubiquity.NET.Llvm.RelocationMode,Ubiquity.NET.Llvm.CodeModel)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.TargetMachine"/> for the target and specified parameters</summary>
            <param name="triple">Target triple for this machine (e.g. -mtriple)</param>
            <param name="cpu">CPU for this machine (e.g. -mcpu)</param>
            <param name="features">Features for this machine (e.g. -mattr...)</param>
            <param name="optLevel">Optimization level</param>
            <param name="relocationMode">Relocation mode for generated code</param>
            <param name="codeModel"><see cref="T:Ubiquity.NET.Llvm.CodeModel"/> to use for generated code</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.TargetMachine"/> based on the specified parameters</returns>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Target.AvailableTargets">
            <summary>Gets an enumerable collection of the available targets built into this library</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Target.FromTriple(Ubiquity.NET.Llvm.Triple)">
            <summary>Gets the target for a given target "triple" value</summary>
            <param name="triple">Target <see cref="T:Ubiquity.NET.Llvm.Triple"/> describing the target</param>
            <returns>Target for the given triple</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Target.FromTriple(System.String)">
            <summary>Gets the target for a given target "triple" value</summary>
            <param name="targetTriple">Target triple string describing the target</param>
            <returns>Target for the given triple</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.TargetMachine">
            <summary>Target specific code generation information</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.TargetMachine.#ctor(Ubiquity.NET.Llvm.Triple,System.String,System.String,Ubiquity.NET.Llvm.CodeGenOpt,Ubiquity.NET.Llvm.RelocationMode,Ubiquity.NET.Llvm.CodeModel)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.TargetMachine"/> class.</summary>
            <param name="triple">Triple for the target machine</param>
            <param name="cpu">CPU options for the machine</param>
            <param name="features">CPU features for the machine</param>
            <param name="optLevel">General optimization level for machine code generation</param>
            <param name="relocationMode">Relocation mode for machine code generation</param>
            <param name="codeModel">Code model for machine code generation</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.TargetMachine.Target">
            <summary>Gets the target that owns this <see cref="T:Ubiquity.NET.Llvm.TargetMachine"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.TargetMachine.Triple">
            <summary>Gets the target triple describing this machine</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.TargetMachine.Cpu">
            <summary>Gets the CPU Type for this machine</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.TargetMachine.Features">
            <summary>Gets the CPU specific features for this machine</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.TargetMachine.TargetData">
            <summary>Gets Layout information for this machine</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.TargetMachine.EmitToFile(Ubiquity.NET.Llvm.BitcodeModule,System.String,Ubiquity.NET.Llvm.CodeGenFileType)">
            <summary>Generate code for the target machine from a module</summary>
            <param name="module"><see cref="T:Ubiquity.NET.Llvm.BitcodeModule"/> to generate the code from</param>
            <param name="path">Path to the output file</param>
            <param name="fileType">Type of file to emit</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.TargetMachine.EmitToBuffer(Ubiquity.NET.Llvm.BitcodeModule,Ubiquity.NET.Llvm.CodeGenFileType)">
            <summary>Emits the module for the target machine to a <see cref="T:Ubiquity.NET.Llvm.MemoryBuffer"/></summary>
            <param name="module">Module to emit to the buffer</param>
            <param name="fileType">Type of file to generate into the buffer</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.MemoryBuffer"/> containing the generated code</returns>
            <remarks>
            The <see cref="P:Ubiquity.NET.Llvm.BitcodeModule.TargetTriple"/> must match the <see cref="P:Ubiquity.NET.Llvm.TargetMachine.Triple"/> for this
            target.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.TargetMachine.FromTriple(Ubiquity.NET.Llvm.Triple,System.String,System.String,Ubiquity.NET.Llvm.CodeGenOpt,Ubiquity.NET.Llvm.RelocationMode,Ubiquity.NET.Llvm.CodeModel)">
            <summary>Creates a <see cref="T:Ubiquity.NET.Llvm.TargetMachine"/> for the triple and specified parameters</summary>
            <param name="triple">Target triple for this machine (e.g. -mtriple)</param>
            <param name="cpu">CPU for this machine (e.g. -mcpu)</param>
            <param name="features">Features for this machine (e.g. -mattr...)</param>
            <param name="optLevel">Optimization level</param>
            <param name="relocationMode">Relocation mode for generated code</param>
            <param name="codeModel"><see cref="T:Ubiquity.NET.Llvm.CodeModel"/> to use for generated code</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.TargetMachine"/> based on the specified parameters</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Transforms.FunctionPassManager">
            <summary>LLVM pass manager for functions</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.FunctionPassManager.#ctor(Ubiquity.NET.Llvm.BitcodeModule)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.Transforms.FunctionPassManager"/> class.</summary>
            <param name="module">Module that owns the functions this manager works on</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.FunctionPassManager.Initialize">
            <summary>Initializes the passes registered in the pass manager</summary>
            <returns><see langword="true"/>if any of the passes modified the module</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.FunctionPassManager.Run(Ubiquity.NET.Llvm.Values.IrFunction)">
            <summary>Runs the passes registered in the pass manager</summary>
            <param name="target">Function to run the passes on</param>
            <returns><see langword="true"/>if any of the passes modified the module</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.FunctionPassManager.Finish">
            <summary>Finalizes all of the function passes scheduled in the function pass manager.</summary>
            <returns><see langword="true"/>if any of the passes modified the module</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms">
            <summary>Utility class for adding the Inter-procedural transform passes to a <see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/></summary>
            <seealso href="xref:llvm_docs_passes">LLVM: Analysis and Transform Passes</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddArgumentPromotionPass``1(``0)">
            <summary>This pass promotes by reference arguments to be by value arguments.</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <seealso href="xref:llvm_docs_passes#argpromotion-promote-by-reference-arguments-to-scalars">LLVM: Promote by reference arguments to scalars</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddConstantMergePass``1(``0)">
            <summary>Merges duplicate global constants together into a single constant that is shared.</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <seealso href="xref:llvm_docs_passes#constmerge-merge-duplicate-global-constants">LLVM: Simple constant propagation</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddDeadArgEliminationPass``1(``0)">
            <summary>This pass deletes dead arguments from internal functions.</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <seealso href="xref:llvm_docs_passes#deadargelim-dead-argument-elimination">LLVM: Dead Argument Elimination</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddFunctionAttrsPass``1(``0)">
            <summary>A simple inter-procedural pass which walks the call-graph to apply attributes that are statically verifiable</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <seealso href="xref:llvm_docs_passes#functionattrs-deduce-function-attributes">LLVM: Deduce function attributes</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddFunctionInliningPass``1(``0)">
            <summary>Bottom-up inlining of functions into callees.</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <seealso href="xref:llvm_docs_passes#inline-function-integration-inlining">LLVM: Function Integration/Inlining</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddAlwaysInlinerPass``1(``0)">
            <summary>A custom inliner that handles only functions that are marked as always inline.</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <seealso href="xref:llvm_docs_passes#always-inline-inliner-for-always-inline-functions">LLVM: Inliner for always_inline functions</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddGlobalDCEPass``1(``0)">
            <summary>Adds a Global Dead Code Elimination pass</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <remarks>
            This transform is designed to eliminate unreachable internal globals from the program. It uses
            an aggressive algorithm, searching out globals that are known to be alive. After it finds all
            of the globals which are needed, it deletes whatever is left over. This allows it to delete
            recursive chunks of the program which are unreachable.
            </remarks>
            <seealso href="xref:llvm_docs_passes#globaldce-dead-global-elimination">LLVM: Global Dead Code Elimination pass</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddGlobalOptimizerPass``1(``0)">
            <summary>Adds a Global Variable Optimizer pass</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <remarks>
            This pass transforms simple global variables that never have their address taken.
            If obviously true, it marks read/write globals as constant, deletes variables only stored to, etc.
            </remarks>
            <seealso href="xref:llvm_docs_passes#globalopt-global-variable-optimizer">LLVM: Global Variable Optimizer pass</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddIPConstantPropagationPass``1(``0)">
            <summary>Adds an Inter-procedural constant propagation pass</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <remarks>
            This pass implements an extremely simple inter-procedural constant propagation pass. It could
            certainly be improved in many different ways, like using a worklist. This pass makes arguments
            dead, but does not remove them. The existing dead argument elimination pass should be run after
            this to clean up the mess.
            </remarks>
            <seealso href="xref:llvm_docs_passes#ipconstprop-interprocedural-constant-propagation">LLVM: Inter-procedural constant propagation pass</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddPruneEHPass``1(``0)">
            <summary>Adds a Prune unused exception handling info pass</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <remarks>
            This file implements a simple inter-procedural pass which walks the call-graph, turning invoke
            instructions into call instructions if and only if the callee cannot throw an exception. It
            implements this as a bottom-up traversal of the call-graph.
            </remarks>
            <seealso href="xref:llvm_docs_passes#prune-eh-remove-unused-exception-handling-info">LLVM: Prune unused exception handling info pass</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddIPSCCPPass``1(``0)">
            <summary>Adds an Inter-procedural Sparse Conditional Constant Propagation pass</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <seealso href="xref:llvm_docs_passes#Sparse Conditional Constant Propagation"/>
            <seealso cref="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddSCCPPass``1(``0)">LLVM: Inter-procedural Sparse Conditional Constant Propagation pass</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddInternalizePass``1(``0,System.Boolean)">
            <summary>Adds an Internalize Global Symbols pass</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <param name="allButMain">Flag to indicate if all globals except "main" are considered candidates for internalizing</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <remarks>
            This pass loops over all of the functions in the input module, looking for a main function. If a
            main function is found, all other functions and all global variables with initializers are marked as internal.
            </remarks>
            <seealso href="xref:llvm_docs_passes#internalize-internalize-global-symbols">LLVM: Internalize Global Symbols pass</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddStripDeadPrototypesPass``1(``0)">
            <summary>Adds a Strip Unused Function Prototypes pass</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <remarks>
            This pass loops over all of the functions in the input module, looking for dead declarations and
            removes them. Dead declarations are declarations of functions for which no implementation is
            available (i.e., declarations for unused library functions).
            </remarks>
            <seealso href="xref:llvm_docs_passes#strip-dead-prototypes-strip-unused-function-prototypes">LLVM: Strip Unused Function Prototypes pass</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddStripSymbolsPass``1(``0)">
            <summary>Adds a Strip symbols from module pass</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
            <remarks>
            Performs code stripping. This transformation can delete:
             * names for virtual registers
             * symbols for internal globals and functions
             * debug information
            <note type="note">This transformation makes code much less readable, so it should only be used in situations
            where the strip utility would be used, such as reducing code size or making it harder to reverse engineer code.
            </note>
            </remarks>
            <seealso href="xref:llvm_docs_passes#strip-strip-all-symbols-from-a-module">LLVM: Strip symbols from module pass</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.InterproceduralTransforms.AddInternalizePassWithMustPreservePredicate``1(``0,System.Predicate{Ubiquity.NET.Llvm.Values.Value})">
            <summary>Create and add the internalize pass to the given pass manager with the provided preservation callback.</summary>
            <typeparam name="T">Type of PassManager</typeparam>
            <param name="passManager">PassManager to add the pass to</param>
            <param name="predicate">predicate to callback on each invocation</param>
            <returns>The input <paramref name="passManager"/></returns>
            <remarks>
            <para>Any instance that <paramref name="predicate"/> is a member of (if not static) MUST outlive the
            lifetime of <paramref name="passManager"/> or unpredictable results will occur (usually a crash).
            This is especially important for disposable types as calling Dispose on them can invalidate the
            predicate function.</para>
            <para>Additionally, the predicate function MUST NOT throw, or allow any exceptions to bubble out
            of the function as it is called by native code that has no idea what to do with a managed code
            exception. (Again, likely resulting in a crash)</para>
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Transforms.ModulePassManager">
            <summary>Pass manager for running passes against an entire module</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ModulePassManager.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.Transforms.ModulePassManager"/> class.</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ModulePassManager.Run(Ubiquity.NET.Llvm.BitcodeModule)">
            <summary>Runs the passes added to this manager for the target module</summary>
            <param name="target">Module to run the passes on</param>
            <returns><see langword="true"/> if one of the passes modified the module</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Transforms.PassManager">
            <summary>Common base class for pass managers</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Transforms.Sanitizers">
            <summary>LLVM Sanitizer passes</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.Sanitizers.AddAddressSanitizerPass(Ubiquity.NET.Llvm.Transforms.FunctionPassManager)">
            <summary>Adds an Address Sanitizer Function pass</summary>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.Sanitizers.AddSanitizerPass(Ubiquity.NET.Llvm.Transforms.ModulePassManager)">
            <summary>Adds an Address Sanitizer Function pass</summary>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.Sanitizers.AddThreadSanitizerPass(Ubiquity.NET.Llvm.Transforms.FunctionPassManager)">
            <summary>Adds a Thread Sanitizer Function pass</summary>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.Sanitizers.AddMemorySanitizerPass(Ubiquity.NET.Llvm.Transforms.FunctionPassManager)">
            <summary>Adds a Memory Sanitizer Function pass</summary>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.Sanitizers.AddDataFlowSanitizerPass(Ubiquity.NET.Llvm.Transforms.ModulePassManager,System.String[])">
            <summary>Adds a DataFlow Sanitizer Module pass</summary>
            <param name="passManager">Pass manager to add the pass to</param>
            <param name="abiListFile">ABI List Files</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Transforms.ScalarTransforms">
            <summary>Utility class for Adding Scalar transform passes to a <see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/></summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddAggressiveDCEPass``1(``0)">
            <summary>Adds an Aggressive Dead Code Elimination (DCE) pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#adce-aggressive-dead-code-elimination">LLVM: Aggressive Dead Elimination</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddDCEPass``1(``0)">
            <summary>Add Dead Code Elimination pass</summary>
            <typeparam name="T">Type of pass manager</typeparam>
            <param name="passManager">PassManager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#dce-dead-code-elimination"/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddBitTrackingDCEPass``1(``0)">
            <summary>Adds an Bit tracking DCE pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddAlignmentFromAssumptionsPass``1(``0)">
            <summary>Adds an Alignment from assumptions pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddCFGSimplificationPass``1(``0)">
            <summary>Adds a Simplify CFG pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#passes-simplifycfg">LLVM: Simplify CFG</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddDeadStoreEliminationPass``1(``0)">
            <summary>Adds a Dead Store Elimination pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#dse-dead-store-elimination">LLVM: Dead Store Elimination</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddScalarizerPass``1(``0)">
            <summary>Adds a Scalarizer pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddMergedLoadStoreMotionPass``1(``0)">
            <summary>Adds a Merged Load Store Motion pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddGVNPass``1(``0)">
            <summary>Adds a Global Value Numbering pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#gvn-global-value-numbering">LLVM: Global Value Numbering</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddNewGVNPass``1(``0)">
            <summary>Adds the new GVN pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddIndVarSimplifyPass``1(``0)">
            <summary>Adds a Canonicalize Induction Variables pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#indvars-canonicalize-induction-variables">LLVM: Canonicalize Induction Variables</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddInstructionCombiningPass``1(``0)">
            <summary>Adds the Instruction Combining pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#instcombine-combine-redundant-instructions">LLVM: Combine redundant instructions</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddJumpThreadingPass``1(``0)">
            <summary>Adds a jump threading pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#jump-threading-jump-threading">LLVM: Jump Threading</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddLICMPass``1(``0)">
            <summary>Adds an Loop Invariant Code Motion pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#licm-loop-invariant-code-motion">LLVM: Loop Invariant Code Motion</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddLoopDeletionPass``1(``0)">
            <summary>Adds a Delete dead loops pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#loop-deletion-delete-dead-loops">LLVM: Delete dead loops</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddLoopIdiomPass``1(``0)">
            <summary>Adds a Loop Idiom pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddLoopRotatePass``1(``0)">
            <summary>Adds a Rotate Loops pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#loop-rotate-rotate-loops">LLVM: Rotate Loops</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddLoopRerollPass``1(``0)">
            <summary>Adds a Loop Reroll pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddLoopUnrollPass``1(``0)">
            <summary>Adds a Loop Unroll pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#loop-unroll-unroll-loops">LLVM: Unroll Loops</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddLoopUnrollAndJamPass``1(``0)">
            <summary>Adds a Loop Unroll and Jam pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#loop-unroll-unroll-loops">LLVM: Unroll Loops</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddLoopUnswitchPass``1(``0)">
            <summary>Adds a Loop Unswitch pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#loop-unswitch-unswitch-loops">LLVM: Unswitch loops</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddLowerAtomicPass``1(``0)">
            <summary>Adds a Lower Atomic pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#loweratomic-lower-atomic-intrinsics-to-non-atomic-form">LLVM: Lower atomic</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddMemCpyOptPass``1(``0)">
            <summary>Adds an MemCpy Optimization pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#memcpyopt-memcpy-optimization">LLVM: MemCpy Optimization</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddPartiallyInlineLibCallsPass``1(``0)">
            <summary>Adds a Partial Inliner pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#partial-inliner-partial-inliner">LLVM: Partial Inliner</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddLowerSwitchPass``1(``0)">
            <summary>Adds a Lower Switch pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#lowerswitch-lower-switchinsts-to-branches">LLVM: Lower SwitchInst to branches</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddPromoteMemoryToRegisterPass``1(``0)">
            <summary>Adds an Promote memory to Register pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#mem2reg-promote-memory-to-register">LLVM: Promote Memory to Register</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddReassociatePass``1(``0)">
            <summary>Adds a reassociate expressions pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#reassociate-reassociate-expressions">LLVM: Reassociate expressions</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddSCCPPass``1(``0)">
            <summary>Adds an  pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#sccp-sparse-conditional-constant-propagation">LLVM: Sparse Conditional Constant Propagation</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddScalarReplAggregatesPass``1(``0)">
            <summary>Adds a Scalar Replacement of Aggregates pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#sroa-scalar-replacement-of-aggregates">LLVM: Scalar Replacement of Aggregates</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddScalarReplAggregatesPassSSA``1(``0)">
            <summary>Adds a Scalar Replacement of Aggregates pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#sroa-scalar-replacement-of-aggregates">LLVM: Scalar Replacement of Aggregates</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddScalarReplAggregatesPassWithThreshold``1(``0,System.Int32)">
            <summary>Adds a Scalar Replacement of Aggregates pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <param name="threshold">Threshold for this pass</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#sroa-scalar-replacement-of-aggregates">LLVM: Scalar Replacement of Aggregates</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddSimplifyLibCallsPass``1(``0)">
            <summary>Adds a Simplify Lib Calls pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddTailCallEliminationPass``1(``0)">
            <summary>Adds a Tail Call Elimination pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#tailcallelim-tail-call-elimination">LLVM: Tail Call Elimination</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddConstantPropagationPass``1(``0)">
            <summary>Adds a Simple constant propagation pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#constprop-simple-constant-propagation">LLVM: Simple constant propagation</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddDemoteMemoryToRegisterPass``1(``0)">
            <summary>Adds a Reg2Mem pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#reg2mem-demote-all-values-to-stack-slots">LLVM: Demote all values to stack slots</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddVerifierPass``1(``0)">
            <summary>Adds a Module Verifier pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#verify-module-verifier">LLVM: Module Verifier</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddCorrelatedValuePropagationPass``1(``0)">
            <summary>Adds a Correlated Value Propagation pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddEarlyCSEPass``1(``0)">
            <summary>Adds an Early CSE pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddEarlyCSEMemSSAPass``1(``0)">
            <summary>Adds an Early CSE Mem SSA pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddLowerExpectIntrinsicPass``1(``0)">
            <summary>Adds an Lower Expect Instrinsic pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddTypeBasedAliasAnalysisPass``1(``0)">
            <summary>Adds a Type Based Alias Analysis pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddScopedNoAliasAAPass``1(``0)">
            <summary>Adds a Scoped No Alias AA pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddBasicAliasAnalysisPass``1(``0)">
            <summary>Adds a Basic Alias Analysis pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
            <seealso href="xref:llvm_docs_passes#basicaa-basic-alias-analysis-stateless-aa-impl">LLVM: Basic Alias Analysis</seealso>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddLowerConstantIntrinsicsPass``1(``0)">
            <summary>Adds a Lower Constant Intrinsics pass to the manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">THe pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.ScalarTransforms.AddAddDiscriminatorsPass``1(``0)">
            <summary>Adds an Add Discriminators Pass to the pass manager</summary>
            <typeparam name="T">Type of pass manager to add the pass to</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/>for fluent support</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Transforms.VectorTransforms">
            <summary>Extension methods for adding vector transform passes</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.VectorTransforms.AddLoopVectorizePass``1(``0)">
            <summary>Adds a loop vectorizer pass</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Transforms.VectorTransforms.AddSLPVectorizePass``1(``0)">
            <summary>Adds a bottom-up SLP vectorizer pass</summary>
            <typeparam name="T"><see cref="T:Ubiquity.NET.Llvm.Transforms.PassManager"/> type</typeparam>
            <param name="passManager">Pass manager to add the pass to</param>
            <returns><paramref name="passManager"/> for fluent style construction of a pass manager</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Triple">
            <summary>Triple to describe a target</summary>
            <remarks>
            <para>The term 'Triple' is a bit of a misnomer. At some point in the past it
            actually consisted of only three parts, but that has changed over the years
            without the name itself changing. The triple is normally represented as a
            string of 4 components delimited by '-'. Some of the components have
            sub components as part of the content. The canonical form of a triple is:
            <c>{Architecture}{SubArchitecture}-{Vendor}-{OS}-{Environment}{ObjectFormat}</c></para>
            <para>
            A few shorthand variations are allowed and converted to their full normalized form.
            In particular "cygwin" is a shorthand for the OS-Environment tuple "windows-cygnus"
            and "mingw" is a shorthand form of "windows-gnu".
            </para>
            <para>In addition to shorthand allowances, the OS component may optionally include
            a trailing version of the form Maj.Min.Micro. If any of the version number parts are
            not present, then they default to 0.</para>
            <para>
            For the environment "androideabi" is allowed and normalized to android (including
            an optional version number).
            </para>
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Triple.ArchType">
            <summary>Enumeration for the Architecture portion of a target triple</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.UnknownArch">
            <summary>Invalid or unknown architecture</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Arm">
            <summary>ARM (little endian): arm, armv.*, xscale</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Armeb">
            <summary>ARM (big endian): armeb</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Aarch64">
            <summary>AArch64 (little endian): aarch64</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Aarch64BE">
            <summary>AArch64 (big endian): aarch64_be</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Aarch64_32">
            <summary>AArch64 32 bit (Little endian) ILP32: aarch64_32</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Arc">
            <summary>Synopsis ARC</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Avr">
            <summary>AVR: Atmel AVR micro-controller</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.BPFel">
            <summary>eBPF or extended BPF or 64-bit BPF (little endian)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.BPFeb">
            <summary>eBPF or extended BPF or 64-bit BPF (big endian)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Hexagon">
            <summary>Hexagon processor</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.MIPS">
            <summary>MIPS: mips, mipsallegrex</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.MIPSel">
            <summary>MIPSEL: mipsel, mipsallegrexel</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.MIPS64">
            <summary>MIPS 64 bit</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.MIPS64el">
            <summary>MIPS 64-bit little endian</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.MSP430">
            <summary>MSP430</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.PPC">
            <summary>PowerPC</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.PPC64">
            <summary>PowerPC 64-bit</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.PPC64le">
            <summary>PowerPC 64-bit little endian</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.R600">
            <summary>R600 AMD GPUS HD2XXX-HD6XXX</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.AMDGCN">
            <summary>AMD GCN GPUs</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.RiscV32">
            <summary>RISC-V (32-bit)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.RiscV64">
            <summary>RISC-V (64-bit)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Sparc">
            <summary>Sparc</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Sparcv9">
            <summary>SPARC V9</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Sparcel">
            <summary>SPARC Little-Endian</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.SystemZ">
            <summary>SystemZ - s390x</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.TCE">
            <summary>TCE</summary>
            <seealso href="http://tce.cs.tut.fi"/>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.TCEle">
            <summary>TCE Little-Endian</summary>
            <seealso href="http://tce.cs.tut.fi"/>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Thumb">
            <summary>Thumb (little-endian)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Thumbeb">
            <summary>Thumb (big-endian)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.X86">
            <summary>x86 i[3-9]86</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Amd64">
            <summary>X86 64-bit (amd64)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Xcore">
            <summary>XCore</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Nvptx">
            <summary>NVidia PTX 32-bit</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Nvptx64">
            <summary>NVidia PTX 64-bit</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Le32">
            <summary>Generic little-endian 32-bit CPU (PNaCl)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Le64">
            <summary>Generic little-endian 64-bit CPU (PNaCl)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Amdil">
            <summary>AMD IL</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Amdil64">
            <summary>AMD IL 64-bit pointers</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Hsail">
            <summary>AMD HSAIL</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Hsail64">
            <summary>AMD HSAIL with 64-bit pointers</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Spir">
            <summary>Standard Portable IR for OpenCL 32-bit version</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Spir64">
            <summary>Standard Portable IR for OpenCL 64-bit version</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Kalimba">
            <summary>Generic Kalimba</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Shave">
            <summary>Movidius vector VLIW processors</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Lanai">
            <summary>Lanai 32-bit</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Wasm32">
            <summary>WebAssembly with 32-bit pointers</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Wasm64">
            <summary>WebAssembly with 64-bit pointers</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Renderscript32">
            <summary>Renderscript 32-bit</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Renderscript64">
            <summary>Renderscript 64-bit</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ArchType.Ve">
            <summary>NEC SX Aurora Vector Engine</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Triple.SubArchType">
            <summary>Processor sub architecture type</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.NoSubArch">
            <summary>No sub architecture</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v8_5a">
            <summary>ARM v8.5a</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v8_4a">
            <summary>ARM v8.4a</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v8_3a">
            <summary>ARM v8.3a</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v8_2a">
            <summary>ARM v8.2a</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v8_1a">
            <summary>ARM v8.1a</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v8">
            <summary>ARM v8</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v8r">
            <summary>ARM v8r</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v8m_baseline">
            <summary>ARM v8m baseline</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v8m_mainline">
            <summary>ARM v8m mainline</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v8_1m_mainline">
            <summary>ARM v8 1m mainline</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v7">
            <summary>ARM v7</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v7em">
            <summary>ARM v7em</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v7m">
            <summary>ARM v7m</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v7s">
            <summary>ARM v7s</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v7k">
            <summary>ARM v7k</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v7ve">
            <summary>ARM v7ve</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v6">
            <summary>ARM v6</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v6m">
            <summary>ARM v6m</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v6k">
            <summary>ARM v6k</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v6t2">
            <summary>ARM v6t2</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v5">
            <summary>ARM v5</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v5te">
            <summary>ARM v5te</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v4t">
            <summary>ARM v4t</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.KalimbaSubArch_v3">
            <summary>Kalimba v3</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.KalimbaSubArch_v4">
            <summary>Kalimba v4</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.KalimbaSubArch_v5">
            <summary>Kalimba v5</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.MipsSubArch_r6">
            <summary>MIPS R6</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.SubArchType.PowerPC_SE">
            <summary>PowerPC SPE</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Triple.VendorType">
            <summary>Vendor type for the triple</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.UnknownVendor">
            <summary>Unknown vendor</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.Apple">
            <summary>Apple</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.PC">
            <summary>Generic PC</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.SCEI">
            <summary>SCEI</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.BGP">
            <summary>BGP</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.BGQ">
            <summary>BGQ</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.Freescale">
            <summary>Freescale</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.IBM">
            <summary>IBM</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.ImaginationTechnologies">
            <summary>Imagination Technologies</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.MipsTechnologies">
            <summary>MIPS Technologies</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.NVIDIA">
            <summary>NVidia</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.CSR">
            <summary>CSR</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.Myriad">
            <summary>Myriad</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.AMD">
            <summary>AMD</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.Mesa">
            <summary>Mesa</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.SUSE">
            <summary>SUSE</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.VendorType.OpenEmebedded">
            <summary>OpenEmbedded</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Triple.OSType">
            <summary>OS type for the triple</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.UnknownOS">
            <summary>Unknown OS</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.Ananas">
            <summary>Ananas</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.CloudABI">
            <summary>CloudABI</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.Darwin">
            <summary>Darwin</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.DragonFly">
            <summary>DragonFly</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.FreeBSD">
            <summary>FreeBSD</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.Fuchsia">
            <summary>Fuchsia</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.IOS">
            <summary>iOS</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.KFreeBSD">
            <summary>KFreeBSD</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.Linux">
            <summary>Linux</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.Lv2">
            <summary>Lv2</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.MacOSX">
            <summary>Mac OSX</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.NetBSD">
            <summary>NetBSD</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.OpenBSD">
            <summary>OpenBSD</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.Solaris">
            <summary>Solaris</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.Win32">
            <summary>Windows WIN32</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.Haiku">
            <summary>Haiku</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.Minix">
            <summary>Minix</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.RTEMS">
            <summary>RTEMS</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.NaCl">
            <summary>NaCl</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.CNK">
            <summary>CNK</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.AIX">
            <summary>AIX</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.CUDA">
            <summary>CUDA</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.NVCL">
            <summary>NVCL</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.AMDHSA">
            <summary>AMD HSA</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.PS4">
            <summary>PS4</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.ELFIAMCU">
            <summary>ELFIAMCU</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.TvOS">
            <summary>TvOS</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.WatchOS">
            <summary>WatchOS</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.Mesa3D">
            <summary>Mesa3D</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.Contiki">
            <summary>Contiki</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.AmdPAL">
            <summary>AMD PAL Runtime</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.HermitCore">
            <summary>HermitCore Unikernel/Multikernel</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.Hurd">
            <summary>GNU/Hurd</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.WASI">
            <summary>WebAssembly OS</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.OSType.Emscripten">
            <summary>Emscripten</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Triple.EnvironmentType">
            <summary>Triple Environment type</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.UnknownEnvironment">
            <summary>Unknown environment</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.GNU">
            <summary>GNU</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.GNUABIN32">
            <summary>GNUABIN32</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.GNUABI64">
            <summary>GNU ABI 64-bit</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.GNUEABI">
            <summary>GNU EABI</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.GNUEABIHF">
            <summary>GNU EABI-HF</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.GNUX32">
            <summary>GNU X32</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.CODE16">
            <summary>CODE16</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.EABI">
            <summary>EABI</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.EABIHF">
            <summary>EABI-HF</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.Android">
            <summary>Android</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.Musl">
            <summary>MUSL</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.MuslEABI">
            <summary>MUSL EABI</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.MuslEABIHF">
            <summary>MUSL EABI-HF</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.MSVC">
            <summary>Microsoft Visual C</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.Itanium">
            <summary>Itanium</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.Cygnus">
            <summary>Cygnus</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.CoreCLR">
            <summary>CoreCLR</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.Simultator">
            <summary>Simulator</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.EnvironmentType.MacABI">
            <summary>Mac Catalyst variant of Apple's iOS deployment target</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Triple.ObjectFormatType">
            <summary>Object format type for a Triple</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ObjectFormatType.UnknownObjectFormat">
            <summary>Unknown format</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ObjectFormatType.COFF">
            <summary>COFF format</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ObjectFormatType.ELF">
            <summary>ELF format</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ObjectFormatType.MachO">
            <summary>MachO format</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ObjectFormatType.Wasm">
            <summary>Wasm format</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Triple.ObjectFormatType.XCOFF">
            <summary>SCOFF format</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.Triple"/> class from a triple string</summary>
            <param name="tripleTxt">Triple string to parse</param>
            <remarks>
            The <paramref name="tripleTxt"/> string is normalized before parsing to allow for
            common non-canonical forms of triples.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.ToString">
            <summary>Retrieves the final string form of the triple</summary>
            <returns>Normalized Triple string</returns>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Triple.ArchitectureType">
            <summary>Gets the Architecture of the triple</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Triple.SubArchitecture">
            <summary>Gets the Sub Architecture type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Triple.Vendor">
            <summary>Gets the Vendor component of the triple</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Triple.OS">
            <summary>Gets the OS Type for the triple</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Triple.Environment">
            <summary>Gets the environment type for the triple</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Triple.ObjectFormat">
            <summary>Gets the object format type for the triple</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Triple.EnvironmentVersion">
            <summary>Gets the version number of the environment</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.GetCanonicalName(Ubiquity.NET.Llvm.Triple.ArchType)">
            <summary>Retrieves the canonical name for an architecture type</summary>
            <param name="archType">Architecture type</param>
            <returns>String name for the architecture</returns>
            <overloads>
            Many parts of a triple can take a variety of literal string
            forms to allow for common real world triples when parsing.
            The GetCanonicalName methods provide the canonical form of
            such triple components used in a normalized triple.
            </overloads>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.GetCanonicalName(Ubiquity.NET.Llvm.Triple.SubArchType)">
            <summary>Retrieves the canonical name for an architecture sub type</summary>
            <param name="subArchType">Architecture sub type</param>
            <returns>String name for the architecture sub type</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.GetCanonicalName(Ubiquity.NET.Llvm.Triple.VendorType)">
            <summary>Retrieves the canonical name for the vendor component of a triple</summary>
            <param name="vendorType">Vendor type</param>
            <returns>String name for the vendor</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.GetCanonicalName(Ubiquity.NET.Llvm.Triple.OSType)">
            <summary>Retrieves the canonical name for the OS component of a triple</summary>
            <param name="osType">OS type</param>
            <returns>String name for the OS</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.GetCanonicalName(Ubiquity.NET.Llvm.Triple.EnvironmentType)">
            <summary>Retrieves the canonical name for the environment component of a triple</summary>
            <param name="envType">Environment type</param>
            <returns>String name for the environment component</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.GetCanonicalName(Ubiquity.NET.Llvm.Triple.ObjectFormatType)">
            <summary>Retrieves the canonical name for the object component of a triple</summary>
            <param name="objFormatType">Object type</param>
            <returns>String name for the object component</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.Equals(Ubiquity.NET.Llvm.Triple)">
            <summary>Equality test for a triple</summary>
            <param name="other">triple to compare this triple to</param>
            <returns><see langword="true"/> if the two triples are equivalent</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.Equals(System.Object)">
            <summary>Equality test for a triple</summary>
            <param name="obj">object to compare this triple to</param>
            <returns><see langword="true"/> if the two triples are equivalent</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.GetHashCode">
            <summary>Gets a hash code for this <see cref="T:Ubiquity.NET.Llvm.Triple"/></summary>
            <returns>Hashcode</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.Normalize(System.String)">
            <summary>Normalizes a triple string</summary>
            <param name="unNormalizedTriple">triple to normalize</param>
            <returns>Normalized string</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.GetDefaultObjectFormat(Ubiquity.NET.Llvm.Triple.ArchType,Ubiquity.NET.Llvm.Triple.OSType)">
            <summary>Gets the default <see cref="T:Ubiquity.NET.Llvm.Triple.ObjectFormatType"/> for a given <see cref="T:Ubiquity.NET.Llvm.Triple.ArchType"/> and <see cref="T:Ubiquity.NET.Llvm.Triple.OSType"/></summary>
            <param name="arch">Architecture type</param>
            <param name="os">Operating system type</param>
            <returns>Default object format</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.GetCanonicalArchForSubArch(Ubiquity.NET.Llvm.Triple.ArchType,Ubiquity.NET.Llvm.Triple.SubArchType)">
            <summary>Provides the canonical Architecture form for a given architecture sub architecture pair</summary>
            <param name="archType">Architecture type</param>
            <param name="subArch">Sub Architecture type</param>
            <returns>Canonical <see cref="T:Ubiquity.NET.Llvm.Triple.ArchType"/></returns>
            <remarks>
            Some architectures, particularly ARM variants, have multiple sub-architecture types that
            have a canonical form (i.e. Arch=<see cref="F:Ubiquity.NET.Llvm.Triple.ArchType.Arm"/>; SubArch=<see cref="F:Ubiquity.NET.Llvm.Triple.SubArchType.ARMSubArch_v7m"/>;
            has the Canonical Arch of <see cref="F:Ubiquity.NET.Llvm.Triple.ArchType.Thumb"/>). This method retrieves the canonical Arch
            for a given architecture,SubArchitecture pair.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Triple.HostTriple">
            <summary>Gets a triple for the host LLVM is built for</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Triple.op_Implicit(Ubiquity.NET.Llvm.Triple)~System.String">
            <summary>Implicitly converts a triple to a string</summary>
            <param name="triple"><see cref="T:Ubiquity.NET.Llvm.Triple"/> to convert</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.IArrayType">
            <summary>Interface for an LLVM array type </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.IArrayType.Length">
            <summary>Gets the length of the array</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.ArrayType">
            <summary>Array type definition</summary>
            <remarks>
            Array's in LLVM are fixed length sequences of elements
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ArrayType.Length">
            <inheritdoc/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.IFunctionType">
            <summary>Interface to represent the LLVM type of a function (e.g. a signature)</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.IFunctionType.IsVarArg">
            <summary>Gets a value indicating whether this signature is for a variadic function</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.IFunctionType.ReturnType">
            <summary>Gets the return type of the function</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.IFunctionType.ParameterTypes">
            <summary>Gets the types of the parameters for the function</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.FunctionType">
            <summary>Class to represent the LLVM type of a function (e.g. a signature)</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.FunctionType.IsVarArg">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.FunctionType.ReturnType">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.FunctionType.ParameterTypes">
            <inheritdoc/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.TypeKind">
            <summary>Basic kind of a type</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Void">
            <summary>Type with no size</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Float16">
            <summary>16 bit floating point type</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Float32">
            <summary>32 bit floating point type</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Float64">
            <summary>64 bit floating point type</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.X86Float80">
            <summary>80 bit floating point type (X87)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Float128m112">
            <summary>128 bit floating point type (112-bit mantissa)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Float128">
            <summary>128 bit floating point type (two 64-bits)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Label">
            <summary><see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> instruction label</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Integer">
            <summary>Arbitrary bit width integers</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Function">
            <summary><see cref="T:Ubiquity.NET.Llvm.Types.IFunctionType"/></summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Struct">
            <summary><see cref="T:Ubiquity.NET.Llvm.Types.IStructType"/></summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Array">
            <summary><see cref="T:Ubiquity.NET.Llvm.Types.IArrayType"/></summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Pointer">
            <summary><see cref="T:Ubiquity.NET.Llvm.Types.IPointerType"/></summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Vector">
            <summary>SIMD 'packed' format, or other <see cref="T:Ubiquity.NET.Llvm.Types.IVectorType"/> implementation</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Metadata">
            <summary><see cref="T:Ubiquity.NET.Llvm.LlvmMetadata"/></summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.X86MMX">
            <summary>x86 MMX data type</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Types.TypeKind.Token">
            <summary>Exception handler token</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.ITypeRef">
            <summary>Interface for a Type in LLVM</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeRef.IsSized">
            <summary>Gets a value indicating whether the type is sized</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeRef.Kind">
            <summary>Gets the LLVM Type kind for this type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeRef.IsInteger">
            <summary>Gets a value indicating whether this type is an integer</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeRef.IsFloat">
            <summary>Gets a value indicating whether the type is a 32-bit IEEE floating point type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeRef.IsDouble">
            <summary>Gets a value indicating whether the type is a 64-bit IEEE floating point type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeRef.IsVoid">
            <summary>Gets a value indicating whether this type represents the void type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeRef.IsStruct">
            <summary>Gets a value indicating whether this type is a structure type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeRef.IsPointer">
            <summary>Gets a value indicating whether this type is a pointer</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeRef.IsSequence">
            <summary>Gets a value indicating whether this type is a sequence type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeRef.IsFloatingPoint">
            <summary>Gets a value indicating whether this type is a floating point type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeRef.IsPointerPointer">
            <summary>Gets a value indicating whether this type is a pointer to a pointer</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeRef.Context">
            <summary>Gets the Context that owns this type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeRef.IntegerBitWidth">
            <summary>Gets the integer bit width of this type or 0 for non integer types</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Types.ITypeRef.GetNullValue">
            <summary>Gets a null value (e.g. all bits == 0 ) for the type</summary>
            <remarks>
            This is a getter function instead of a property as it can throw exceptions
            for types that don't support such a thing (i.e. void )
            </remarks>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.Constant"/> that represents a null (0) value of this type</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Types.ITypeRef.CreateArrayType(System.UInt32)">
            <summary>Array type factory for an array with elements of this type</summary>
            <param name="count">Number of elements in the array</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Types.IArrayType"/> for the array</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Types.ITypeRef.CreatePointerType">
            <summary>Get a <see cref="T:Ubiquity.NET.Llvm.Types.IPointerType"/> for a type that points to elements of this type in the default (0) address space</summary>
            <returns><see cref="T:Ubiquity.NET.Llvm.Types.IPointerType"/>corresponding to the type of a pointer that refers to elements of this type</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Types.ITypeRef.CreatePointerType(System.UInt32)">
            <summary>Get a <see cref="T:Ubiquity.NET.Llvm.Types.IPointerType"/> for a type that points to elements of this type in the specified address space</summary>
            <param name="addressSpace">Address space for the pointer</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Types.IPointerType"/>corresponding to the type of a pointer that refers to elements of this type</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.ITypeHandleOwner">
            <summary>Internal interface for getting access to the raw type handle internally</summary>
            <remarks>This is usually implemented as an explicit interface implementation so that it isn't exposed publicly</remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ITypeHandleOwner.TypeHandle">
            <summary>Gets the LibLLVM handle for the type</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.IPointerType">
            <summary>Interface for a pointer type in LLVM</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.IPointerType.AddressSpace">
            <summary>Gets the address space the pointer refers to</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.PointerType">
            <summary>LLVM pointer type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.PointerType.AddressSpace">
            <summary>Gets the address space the pointer refers to</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.ISequenceType">
            <summary>Interface for an LLVM sequence type</summary>
            <remarks>
            Sequence types represent a sequence of elements of the same type
            that are contiguous in memory. These include Vectors, Arrays, and
            pointers.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.ISequenceType.ElementType">
            <summary>Gets the types of the elements in the sequence</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.INamedStructuralType">
            <summary>Interface for a named type with members</summary>
            <remarks>This is a common interface for structures and unions</remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.INamedStructuralType.Name">
            <summary>Gets the name of the structure</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.INamedStructuralType.IsOpaque">
            <summary>Gets a value indicating whether the structure is opaque (e.g. has no body defined yet)</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.INamedStructuralType.Members">
            <summary>Gets a list of types for all member elements of the structure</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.IStructType">
            <summary>Interface for an LLVM structure type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.IStructType.IsPacked">
            <summary>Gets a value indicating whether the structure is packed (e.g. no automatic alignment padding between elements)</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Types.IStructType.SetBody(System.Boolean,Ubiquity.NET.Llvm.Types.ITypeRef[])">
            <summary>Sets the body of the structure</summary>
            <param name="packed">Flag to indicate if the body elements are packed (e.g. no padding)</param>
            <param name="elements">Types of each element (may be empty)</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Types.IStructType.SetBody(System.Boolean,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Types.ITypeRef})">
            <summary>Sets the body of the structure</summary>
            <param name="packed">Flag to indicate if the body elements are packed (e.g. no padding)</param>
            <param name="elements">Types of each element (may be empty)</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.TypeRef">
            <summary>LLVM Type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.TypeHandle">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.IsSized">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.Kind">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.IsInteger">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.IsFloat">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.IsDouble">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.IsVoid">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.IsStruct">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.IsPointer">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.IsSequence">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.IsFloatingPoint">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.IsPointerPointer">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.Context">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.TypeRef.IntegerBitWidth">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Types.TypeRef.GetNullValue">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Types.TypeRef.CreateArrayType(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Types.TypeRef.CreatePointerType">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Types.TypeRef.CreatePointerType(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Types.TypeRef.ToString">
            <summary>Builds a string representation for this type in LLVM assembly language form</summary>
            <returns>Formatted string for this type</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Types.IVectorType">
            <summary>Interface for an LLVM vector type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Types.IVectorType.Size">
            <summary>Gets the number of elements in the vector</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.Argument">
            <summary>An LLVM Value representing an Argument to a function</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Argument.ContainingFunction">
            <summary>Gets the function this argument belongs to</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Argument.Index">
            <summary>Gets the zero based index of the argument</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Argument.SetAlignment(System.UInt32)">
            <summary>Sets the alignment for the argument</summary>
            <param name="value">Alignment value for this argument</param>
            <returns><see langword="this"/> for Fluent access</returns>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Argument.Attributes">
            <summary>Gets the attributes for this argument</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Argument.AddAttributes(Ubiquity.NET.Llvm.Values.AttributeKind[])">
            <summary>Adds attributes to an <see cref="T:Ubiquity.NET.Llvm.Values.Argument"/></summary>
            <param name="values"><see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/>s to add</param>
            <returns>This Argument for Fluent use</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Argument.AddAttribute(Ubiquity.NET.Llvm.Values.AttributeKind)">
            <summary>Adds an attribute to an <see cref="T:Ubiquity.NET.Llvm.Values.Argument"/></summary>
            <param name="kind"><see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> to add</param>
            <returns>
            This Argument for Fluent access
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Argument.AddAttributes(Ubiquity.NET.Llvm.Values.AttributeValue[])">
            <summary>Adds <see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/>s to an <see cref="T:Ubiquity.NET.Llvm.Values.Argument"/></summary>
            <param name="attributes"><see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/>s to add</param>
            <returns>This Argument for fluent usage</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Argument.AddAttributes(System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.AttributeValue})">
            <summary>Adds <see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/>s to an <see cref="T:Ubiquity.NET.Llvm.Values.Argument"/></summary>
            <param name="attributes"><see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/>s to add</param>
            <returns>This Argument for fluent usage</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Argument.RemoveAttribute(Ubiquity.NET.Llvm.Values.AttributeKind)">
            <summary>Removes an <see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> from an <see cref="T:Ubiquity.NET.Llvm.Values.Argument"/></summary>
            <param name="kind"><see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> to remove</param>
            <returns>This Argument for fluent usage</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Argument.RemoveAttribute(System.String)">
            <summary>Removes a named attribute from an <see cref="T:Ubiquity.NET.Llvm.Values.Argument"/></summary>
            <param name="name">Name of the attribute to remove</param>
            <returns>This Argument for fluent usage</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.AttributeCollectionExtensions">
            <summary>Extension methods for a collection of <see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/></summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeCollectionExtensions.Remove(System.Collections.Generic.ICollection{Ubiquity.NET.Llvm.Values.AttributeValue},Ubiquity.NET.Llvm.Values.AttributeKind)">
            <summary>Removes an attribute from a collection</summary>
            <param name="set">Attribute collection (set) to remove the attribute from</param>
            <param name="kind"><see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> to remove</param>
            <returns><see langword="true"/> if <paramref name="kind"/> was in <paramref name="set"/> before being removed</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeCollectionExtensions.Remove(System.Collections.Generic.ICollection{Ubiquity.NET.Llvm.Values.AttributeValue},System.String)">
            <summary>Removes an attribute from a collection</summary>
            <param name="set">Attribute collection (set) to remove the attribute from</param>
            <param name="name">Name of the attribute to remove</param>
            <returns><see langword="true"/> if <paramref name="name"/> was in <paramref name="set"/> before being removed</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.IAttributeDictionary">
            <summary>Interface to an Attribute Dictionary</summary>
            <remarks>
            <para>This interface provides a full collection of all the
            attributes keyed by the <see cref="T:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex"/>
            </para>
            <note>This conceptually corresponds to the functionality of the
            LLVM AttributeSet class for Versions prior to 5. In LLVM 5 the
            equivalent type is currently AttributeList. In v5 AttributeSet
            has no index and is therefore more properly a set than in the
            past. To help remove confusion and satisfy .NET naming rules this
            is called a Dictionary as that reflects the use here and fits
            the direction of LLVM</note>
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.IAttributeContainer">
            <summary>Interface for objects that contain Attributes</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IAttributeContainer.Context">
            <summary>Gets the <see cref="T:Ubiquity.NET.Llvm.Context"/> that owns these attributes </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IAttributeContainer.Attributes">
            <summary>Gets the full set of Attributes keyed by <see cref="T:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex"/></summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.AttributeContainerMixins">
            <summary>Provides a layer of simplicity and backwards compatibility for manipulating attributes on Values</summary>
            <remarks>At some point when Default interface methods are available (proposed for C#8) these methods can leverage that</remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeContainerMixins.Contains(System.Collections.Generic.ICollection{Ubiquity.NET.Llvm.Values.AttributeValue},Ubiquity.NET.Llvm.Values.AttributeKind)">
            <summary>Determines if a collection of <see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/> contains a given <see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/></summary>
            <param name="self">Collection to test</param>
            <param name="kind"><see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> to search for</param>
            <returns><see langword="true"/> if found</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeContainerMixins.AddAttributes``1(``0,Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeKind[])">
            <summary>Adds attributes to an <see cref="T:Ubiquity.NET.Llvm.Values.IAttributeContainer"/></summary>
            <typeparam name="T">Container type</typeparam>
            <param name="self">Container to add the attributes to</param>
            <param name="index"><see cref="T:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex"/> to add the attributes to</param>
            <param name="values">Attributes to add to the container</param>
            <returns><paramref name="self"/> for fluent use</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeContainerMixins.AddAttribute``1(``0,Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeKind)">
            <summary>Adds a single <see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> to an <see cref="T:Ubiquity.NET.Llvm.Values.IAttributeContainer"/></summary>
            <typeparam name="T">Container type</typeparam>
            <param name="self">Container to add the attribute to</param>
            <param name="index"><see cref="T:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex"/> to add the attribute to</param>
            <param name="kind">Attribute to add to the container</param>
            <returns><paramref name="self"/> for fluent use</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeContainerMixins.AddAttribute``1(``0,Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeValue)">
            <summary>Adds a single <see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/> to an <see cref="T:Ubiquity.NET.Llvm.Values.IAttributeContainer"/></summary>
            <typeparam name="T">Container type</typeparam>
            <param name="self">Container to add the attribute to</param>
            <param name="index"><see cref="T:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex"/> to add the attribute to</param>
            <param name="attrib">Attribute to add to the container</param>
            <returns><paramref name="self"/> for fluent use</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeContainerMixins.AddAttributes``1(``0,Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeValue[])">
            <summary>Adds <see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/>s to an <see cref="T:Ubiquity.NET.Llvm.Values.IAttributeContainer"/></summary>
            <typeparam name="T">Container type</typeparam>
            <param name="self">Container to add the attribute to</param>
            <param name="index"><see cref="T:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex"/> to add the attributes to</param>
            <param name="attributes">Attribute to add to the container</param>
            <returns><paramref name="self"/> for fluent use</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeContainerMixins.AddAttributes``1(``0,Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.AttributeValue})">
            <summary>Adds <see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/>s to an <see cref="T:Ubiquity.NET.Llvm.Values.IAttributeContainer"/></summary>
            <typeparam name="T">Container type</typeparam>
            <param name="self">Container to add the attribute to</param>
            <param name="index"><see cref="T:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex"/> to add the attributes to</param>
            <param name="attributes">Attribute to add to the container</param>
            <returns><paramref name="self"/> for fluent use</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeContainerMixins.AddAttributes``1(``0,Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.IAttributeDictionary)">
            <summary>Adds the attributes from and <see cref="T:Ubiquity.NET.Llvm.Values.IAttributeDictionary"/> to an <see cref="T:Ubiquity.NET.Llvm.Values.IAttributeContainer"/></summary>
            <typeparam name="T">Container type</typeparam>
            <param name="self">Container to add the attributes to</param>
            <param name="index"><see cref="T:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex"/> to add the attributes to  </param>
            <param name="attributes"><see cref="T:Ubiquity.NET.Llvm.Values.IAttributeDictionary"/> containing the attributes to add to the container</param>
            <returns><paramref name="self"/> for fluent use</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeContainerMixins.RemoveAttribute``1(``0,Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeKind)">
            <summary>Removes an <see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> from an <see cref="T:Ubiquity.NET.Llvm.Values.IAttributeContainer"/></summary>
            <typeparam name="T">Container type</typeparam>
            <param name="self">Container to remove the attribute from</param>
            <param name="index"><see cref="T:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex"/> to remove the attribute from </param>
            <param name="kind">Attribute to remove from the container</param>
            <returns><paramref name="self"/> for fluent use</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeContainerMixins.RemoveAttribute``1(``0,Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,System.String)">
            <summary>Removes a named attribute from an <see cref="T:Ubiquity.NET.Llvm.Values.IAttributeContainer"/></summary>
            <typeparam name="T">Container type</typeparam>
            <param name="self">Container to remove the attribute from</param>
            <param name="index"><see cref="T:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex"/> to remove the attribute from </param>
            <param name="name">Attribute name to remove from the container</param>
            <returns><paramref name="self"/> for fluent use</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.AttributeKind">
            <summary>Enumeration for the known LLVM attributes</summary>
            <remarks>
            <para>It is important to note that the integer values of this enum do NOT necessarily
            correlate to the LLVM attribute IDs. LLVM has moved away from using an enum Flags model
            as the number of attributes reached the limit of available bits. Thus, the enum was
            dropped. Instead, strings are used to identify attributes. However, for maximum
            compatibility and ease of use for this library the enum is retained and the provided
            attribute manipulation classes will map the enum to the associated string.</para>
            <note type="warning">As a result of the changes in LLVM this set of attributes is
            fluid and subject to change from version to version. Thus, code using any attributes
            that have changed or were removed will produce compile time errors. That is useful
            and by design so that any changes in LLVM naming will break at compile time instead
            of at runtime.</note>
            </remarks>
            <seealso href="xref:llvm_langref#function-attributes">LLVM Function Attributes</seealso>
            <seealso href="xref:llvm_langref#parameter-attributes">LLVM Parameter Attributes</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.None">
            <summary>No attributes</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.Alignment">
            <summary>This indicates that the pointer value may be assumed by the optimizer to
            have the specified alignment.</summary>
            <remarks>
            <note type="note">
            This attribute has additional semantics when combined with the byval attribute.
            </note>
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.AllocSize">
            <summary>This attribute indicates that the annotated function will always return at
            least a given number of bytes (or null).</summary>
            <remarks>Its arguments are zero-indexed parameter numbers; if one argument is provided,
            then its assumed that at least CallSite.Args[EltSizeParam] bytes will be available at
            the returned pointer. If two are provided, then its assumed that CallSite.Args[EltSizeParam]
            * CallSite.Args[NumEltsParam] bytes are available. The referenced parameters must be integer
            types. No assumptions are made about the contents of the returned block of memory.
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.AlwaysInline">
            <summary>is attribute indicates that the inliner should attempt to inline this function
            into callers whenever possible, ignoring any active inlining size threshold for this caller.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.ArgMemOnly">
            <summary>indicates that the only memory accesses inside function are loads and stores from
            objects pointed to by its pointer-typed arguments, with arbitrary offsets</summary>
            <remarks>This attribute indicates that the only memory accesses inside function are loads and
            stores from objects pointed to by its pointer-typed arguments, with arbitrary offsets. Or in
            other words, all memory operations in the function can refer to memory only using pointers
            based on its function arguments. Note that argmemonly can be used together with readonly
            attribute in order to specify that function reads only from its arguments.</remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.Builtin">
            <summary>This indicates that the callee function at a call site should be recognized as a
            built-in function, even though the functions declaration uses the nobuiltin attribute.</summary>
            <remarks>
            This is only valid at call sites for direct calls to functions that are declared with the
            nobuiltin attribute.</remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.ByVal">
            <summary>This indicates that the pointer parameter should really be passed by value to the function.</summary>
            <remarks>
            <para>The attribute implies that a hidden copy of the pointee is made between the caller and
            the callee, so the callee is unable to modify the value in the caller. This attribute is only
            valid on LLVM pointer arguments. It is generally used to pass structs and arrays by value, but
            is also valid on pointers to scalars. The copy is considered to belong to the caller not the
            callee (for example, readonly functions should not write to byval parameters). This is not a
            valid attribute for return values.</para>
            <para>The byval attribute also supports specifying an alignment with the align attribute. It
            indicates the alignment of the stack slot to form and the known alignment of the pointer
            specified to the call site. If the alignment is not specified, then the code generator makes
            a target-specific assumption.</para>
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.Cold">
            <summary>This attribute indicates that this function is rarely called.</summary>
            <remarks>
            When computing edge weights, basic blocks post-dominated by a cold function call are also considered to be cold; and, thus, given low weight.
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.Convergent">
            <summary>This attribute marks a function as convergent</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.Dereferenceable">
            <summary>This indicates that the parameter or return pointer is dereferenceable</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.DereferenceableOrNull">
            <summary>This indicates that the parameter or return value isnt both non-null and non-dereferenceable (up to 'n' bytes) at the same time.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.InAlloca">
            <summary>The inalloca argument attribute allows the caller to take the address of outgoing stack arguments.</summary>
            <remarks>
            <para>An inalloca argument must be a pointer to stack memory produced by an <see cref="T:Ubiquity.NET.Llvm.Instructions.Alloca"/>
            instruction. The alloca, or argument allocation, must also be tagged with the inalloca keyword.
            Only the last argument may have the inalloca attribute, and that argument is guaranteed to be
            passed in memory.</para>
            <para>An argument allocation may be used by a call at most once because the call may deallocate
            it. The inalloca attribute cannot be used in conjunction with other attributes that affect argument
            storage, like <see cref="F:Ubiquity.NET.Llvm.Values.AttributeKind.InReg"/>, <see cref="F:Ubiquity.NET.Llvm.Values.AttributeKind.Nest"/>, <see cref="F:Ubiquity.NET.Llvm.Values.AttributeKind.StructRet"/>, or <see cref="F:Ubiquity.NET.Llvm.Values.AttributeKind.ByVal"/>.
            The inalloca attribute also disables LLVMs implicit lowering of large aggregate return values,
            which means that frontend authors must lower them with sret pointers.</para>
            <para>When the call site is reached, the argument allocation must have been the most recent stack
            allocation that is still live, or the results are undefined. It is possible to allocate additional
            stack space after an argument allocation and before its call site, but it must be cleared off with
            llvm.stackrestore.</para>
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.InReg">
            <summary>This indicates that this parameter or return value should be treated in a special target-dependent fashion
            while emitting code for a function call or return (usually, by putting it in a register as opposed to memory, though
            some targets use it to distinguish between two different kinds of registers). Use of this attribute is target-specific.
            </summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.InaccessibleMemOnly">
            <summary>This attribute indicates that the function may only access memory that is not accessible by the module being compiled.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.InaccessibleMemOrArgMemOnly">
            <summary>This attribute indicates that the function may only access memory that is either not accessible by the module being compiled, or is pointed to by its pointer arguments.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.InlineHint">
            <summary>This attribute indicates that the source code contained a hint that inlining this function is desirable (such as the inline keyword in C/C++). It is just a hint; it imposes no requirements on the inliner.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.JumpTable">
            <summary>This attribute indicates that the function should be added to a jump-instruction table at code-generation time,</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.MinSize">
            <summary>This attribute suggests that optimization passes and code generator passes make choices that keep the code size of this function as small as possible</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.Naked">
            <summary>This attribute disables prologue / epilogue emission for the function. This can have very system-specific consequences.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.Nest">
            <summary>This indicates that the pointer parameter can be excised using the trampoline intrinsics.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.NoAlias">
            <summary>This indicates that objects accessed via pointer values based on the argument or return value are not also accessed, during the execution of the function, via pointer values not based on the argument or return value. </summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.NoBuiltin">
            <summary>This indicates that the callee function at a call site is not recognized as a built-in function.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.NoCapture">
            <summary>This indicates that the callee does not make any copies of the pointer that outlive the callee itself.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.NoDuplicate">
            <summary>This attribute indicates that calls to the function cannot be duplicated.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.NoImplicitFloat">
            <summary>This attributes disables implicit floating point instructions.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.NoInline">
            <summary>This attribute indicates that the inliner should never inline this function in any situation.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.NoRecurse">
            <summary>This function attribute indicates that the function does not call itself either directly or indirectly down any possible call path</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.NoRedZone">
            <summary>This attribute indicates that the code generator should not use a red zone, even if the target-specific ABI normally permits it</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.NoReturn">
            <summary>This function attribute indicates that the function never returns normally.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.NoUnwind">
            <summary>This function attribute indicates that the function never raises an exception.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.NonLazyBind">
            <summary>This attribute suppresses lazy symbol binding for the function.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.NonNull">
            <summary>This indicates that the parameter or return pointer is not null.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.OptimizeForSize">
            <summary>Optimize for size</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.OptimizeNone">
            <summary>Do not optimize</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.ReadNone">
            <summary>On a function, this attribute indicates that the function computes its result (or decides to unwind an exception) based strictly on its arguments, without dereferencing any pointer arguments or otherwise accessing any mutable state</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.ReadOnly">
            <summary>On a function, this attribute indicates that the function does not write through any pointer arguments (including byval arguments) or otherwise modify any state (e.g. memory, control registers, etc) visible to caller functions</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.Returned">
            <summary>This indicates that the function always returns the argument as its return value.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.ReturnsTwice">
            <summary>This attribute indicates that this function can return twice.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.SExt">
            <summary>This indicates to the code generator that the parameter or return value should be sign-extended to the extent
            required by the targets ABI (which is usually 32-bits) by the caller (for a parameter) or the callee (for a return value).
            </summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.SafeStack">
            <summary>This attribute indicates that SafeStack protection is enabled for this function.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.SanitizeAddress">
            <summary>This attribute indicates that AddressSanitizer checks (dynamic address safety analysis) are enabled for this function.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.SanitizeMemory">
            <summary>This attribute indicates that MemorySanitizer checks (dynamic detection of accesses to uninitialized memory) are enabled for this function.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.SanitizeThread">
            <summary>This attribute indicates that ThreadSanitizer checks (dynamic thread safety analysis) are enabled for this function.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.Speculatable">
            <summary>This function attribute indicates that the function does not have any effects besides calculating its result and does not have undefined behavior.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.StackAlignment">
            <summary>This attribute indicates that, when emitting the prologue and epilogue, the back-end should forcibly align the stack pointer.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.StackProtect">
            <summary>This attribute indicates that the function should emit a stack smashing protector.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.StackProtectReq">
            <summary>This attribute indicates that the function should always emit a stack smashing protector.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.StackProtectStrong">
            <summary>This attribute indicates that the function should emit a stack smashing protector.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.StructRet">
            <summary>This indicates that the pointer parameter specifies the address of a structure that is the return value of the function in the source program.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.SwiftError">
            <summary>This attribute is motivated to model and optimize Swift error handling.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.SwiftSelf">
            <summary>This indicates that the parameter is the self/context parameter.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.UWTable">
            <summary>This attribute indicates that the ABI being targeted requires that an unwind table entry be produced for this function even if we can show that no exceptions passes by it.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.WriteOnly">
            <summary>This attribute indicates the item is write only</summary>
            <remarks>
            On a function, this attribute indicates that the function may write to but does not read from memory.
            On an argument, this attribute indicates that the function may write to but does not read through this pointer argument (even though it may read from the memory that the pointer points to).
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AttributeKind.ZExt">
            <summary>This indicates to the code generator that the parameter or return value should be zero-extended to the extent
            required by the targets ABI by the caller (for a parameter) or the callee (for a return value).</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.FunctionIndexKinds">
            <summary>Enumeration flags to indicate which attribute set index an attribute may apply to</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.FunctionIndexKinds.None">
            <summary>Invalid attributes don't apply to any index</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.FunctionIndexKinds.Function">
            <summary>The attribute is applicable to a function</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.FunctionIndexKinds.Return">
            <summary>The attribute is applicable to a function's return</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.FunctionIndexKinds.Parameter">
            <summary>The attribute is applicable to a function's parameter</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.AttributeKindExtensions">
            <summary>Utility class to provide extension methods for validating usage of attribute kinds</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeKindExtensions.GetAttributeName(Ubiquity.NET.Llvm.Values.AttributeKind)">
            <summary>Gets the symbolic name of the attribute</summary>
            <param name="kind"><see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> to get the name of</param>
            <returns>Name of the attribute</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeKindExtensions.RequiresIntValue(Ubiquity.NET.Llvm.Values.AttributeKind)">
            <summary>Gets a value indicating whether the attribute requires an integer parameter value</summary>
            <param name="kind"><see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> to check</param>
            <returns><see langword="true"/> if the attribute requires an integer value</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeKindExtensions.LookupId(System.UInt32)">
            <summary>Looks up the <see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> for an LLVM attribute id</summary>
            <param name="id">LLVM attribute id</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> that corresponds to the LLVM id</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.AttributeValue">
            <summary>Single attribute for functions, function returns and function parameters</summary>
            <remarks>
            This is the equivalent to the underlying llvm::AttributeImpl class. The name was changed to
            AttributeValue in .NET to prevent confusion with the standard <see cref="T:System.Attribute"/> class
            that is used throughout .NET libraries.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.AttributeValue.Context">
            <summary>Gets the context that owns this <see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/></summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeValue.GetHashCode">
            <summary>Gets a hash code for this instance</summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeValue.Equals(System.Object)">
            <summary>Performs equality checks against an <see cref="T:System.Object"/></summary>
            <param name="obj">object to test for equality with this instance</param>
            <returns><see langword="true"/> if <paramref name="obj"/> is equal to this instance</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeValue.Equals(Ubiquity.NET.Llvm.Values.AttributeValue)">
            <summary>Performs equality checks against an <see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/></summary>
            <param name="other">object to test for equality with this instance</param>
            <returns><see langword="true"/> if <paramref name="other"/> is equal to this instance</returns>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.AttributeValue.Kind">
            <summary>Gets the kind of the attribute</summary>
            <value>The <see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> or <see cref="F:Ubiquity.NET.Llvm.Values.AttributeKind.None"/> for named attributes</value>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.AttributeValue.Name">
            <summary>Gets the Name of the attribute</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.AttributeValue.StringValue">
            <summary>Gets the value for named attributes with values</summary>
            <value>The value as a string or <see lang="null"/> if the attribute has no value</value>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.AttributeValue.IntegerValue">
            <summary>Gets the Integer value of the attribute or <see lang="null"/> if the attribute doesn't have a value</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.AttributeValue.TypeValue">
            <summary>Gets the Type value of this attribute, if any</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.AttributeValue.IsString">
            <summary>Gets a value indicating whether this attribute is a target specific string value</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.AttributeValue.HasIntegerVaue">
            <summary>Gets a value indicating whether this attribute has an integer attribute</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.AttributeValue.IsEnum">
            <summary>Gets a value indicating whether this attribute is a simple enumeration value</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeValue.IsValidOn(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Tests if the attribute is valid for a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> on a given <see cref="T:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex"/></summary>
            <param name="index">Attribute index to test if the attribute is valid on</param>
            <param name="value"><see cref="T:Ubiquity.NET.Llvm.Values.Value"/> </param>
            <returns><see lang="true"/> if the attribute is valid on the specified <paramref name="index"/> of the given <paramref name="value"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeValue.VerifyValidOn(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.Value)">
            <summary>Verifies the attribute is valid for a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> on a given <see cref="T:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex"/></summary>
            <param name="index">Index to verify</param>
            <param name="value">Value to check this attribute on</param>
            <exception cref="T:System.ArgumentException">The attribute is not valid on <paramref name="value"/> for the <paramref name="index"/></exception>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeValue.ToString">
            <summary>Gets a string representation of the attribute</summary>
            <returns>Attribute as a string</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeValue.op_Equality(Ubiquity.NET.Llvm.Values.AttributeValue,Ubiquity.NET.Llvm.Values.AttributeValue)">
            <summary>Tests attributes for equality</summary>
            <param name="left">Left side of the comparison</param>
            <param name="right">Right side of the comparison</param>
            <returns><see lang="true"/> if the attributes are equal</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.AttributeValue.op_Inequality(Ubiquity.NET.Llvm.Values.AttributeValue,Ubiquity.NET.Llvm.Values.AttributeValue)">
            <summary>Tests attributes for inequality</summary>
            <param name="left">Left side of the comparison</param>
            <param name="right">Right side of the comparison</param>
            <returns><see lang="true"/> if the attributes are not equal</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.BasicBlock">
            <summary>Provides access to an LLVM Basic block</summary>
            <remarks>
            A basic block is a sequence of instructions with a single entry
            and a single exit. The exit point must be a <see cref="P:Ubiquity.NET.Llvm.Values.BasicBlock.Terminator"/>
            instruction or the block is not (yet) well-formed.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.BasicBlock.ContainingFunction">
            <summary>Gets the function containing the block</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.BasicBlock.FirstInstruction">
            <summary>Gets the first instruction in the block</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.BasicBlock.LastInstruction">
            <summary>Gets the last instruction in the block</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.BasicBlock.Terminator">
            <summary>Gets the terminator instruction for the block</summary>
            <remarks>
            May be null if the block is not yet well-formed
            as is commonly the case while generating code for a new block
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.BasicBlock.Instructions">
            <summary>Gets all instructions in the block</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.BasicBlock.GetNextInstruction(Ubiquity.NET.Llvm.Instructions.Instruction)">
            <summary>Gets the instruction that follows a given instruction in a block</summary>
            <param name="instruction">instruction in the block to get the next instruction from</param>
            <returns>Next instruction or null if none</returns>
            <exception cref="T:System.ArgumentException">Thrown when <paramref cref="T:Ubiquity.NET.Llvm.Instructions.Instruction"/> is from a different block</exception>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.BasicBlockCollection.Count">
            <summary>Gets a count of the blocks in the collection</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.BasicBlockCollection.Add(Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Add a block to the underlying function</summary>
            <param name="item"><see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> to add to the function</param>
            <remarks>
            The block is appended to the end of the list of blocks owned by the function
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.BasicBlockCollection.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.BasicBlockCollection.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.BlockAddress">
            <summary>Constant address of a block</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.BlockAddress.Function">
            <summary>Gets the <see cref="P:Ubiquity.NET.Llvm.Values.BlockAddress.Function"/> that owns the block</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.BlockAddress.BasicBlock">
            <summary>Gets the <see cref="P:Ubiquity.NET.Llvm.Values.BlockAddress.BasicBlock"/> the address refers to</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.Constant">
            <summary>Contains an LLVM Constant value</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Constant.IsZeroValue">
            <summary>Gets a value indicating whether the constant is a Zero value for the its type</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Constant.NullValueFor(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Create a NULL pointer for a given type</summary>
            <param name="typeRef">Type of pointer to create a null vale for</param>
            <returns>Constant NULL pointer of the specified type</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Constant.ToMetadata">
            <summary>Gets the constant as a Metadata node</summary>
            <returns>Constant value as a metadata constant</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Constant.AllOnesValueFor(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a constant instance of <paramref name="typeRef"/> with all bits in the instance set to 1</summary>
            <param name="typeRef">Type of value to create</param>
            <returns>Constant for the type with all instance bits set to 1</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Constant.UndefinedValueFor(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates an <see cref="T:Ubiquity.NET.Llvm.Values.Constant"/> representing an undefined value for <paramref name="typeRef"/></summary>
            <param name="typeRef">Type to create the undefined value for</param>
            <returns>
            <see cref="T:Ubiquity.NET.Llvm.Values.Constant"/> representing an undefined value of <paramref name="typeRef"/>
            </returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Constant.ConstPointerToNullFor(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Create a constant NULL pointer for a given type</summary>
            <param name="typeRef">Type of pointer to create a null value for</param>
            <returns>Constant NULL pointer of the specified type</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantAggregate">
            <summary>Base class for aggregate constants (with operands).</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantAggregateZero">
            <summary>Constant aggregate of value 0</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantArray">
            <summary>LLVM Constant Array</summary>
            <remarks>
            Due to how LLVM treats constant arrays internally, creating a constant array
            with the From method overloads may not actually produce a ConstantArray
            instance. At the least it will produce a Constant. LLVM will determine the
            appropriate internal representation based on the input types and values
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ConstantArray.From(Ubiquity.NET.Llvm.Types.ITypeRef,Ubiquity.NET.Llvm.Values.Constant[])">
            <summary>Create a constant array of values of a given type</summary>
            <param name="elementType">Type of elements in the array</param>
            <param name="values">Values to initialize the array</param>
            <returns>Constant representing the array</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ConstantArray.From(Ubiquity.NET.Llvm.Types.ITypeRef,System.Int32,Ubiquity.NET.Llvm.Values.Constant[])">
            <summary>Create a constant array of values of a given type with a fixed size, zero filling any unspecified values</summary>
            <param name="elementType">Type of elements in the array</param>
            <param name="len">Length of the array</param>
            <param name="values">Values to initialize the array</param>
            <returns>Constant representing the array</returns>
            <remarks>
            If the number of arguments provided for the values is less than <paramref name="len"/>
            then the remaining elements of the array are set with the null value for the <paramref name="elementType"/>
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ConstantArray.From(Ubiquity.NET.Llvm.Types.ITypeRef,System.Collections.Generic.IList{Ubiquity.NET.Llvm.Values.Constant})">
            <summary>Create a constant array of values of a given type</summary>
            <param name="elementType">Type of elements in the array</param>
            <param name="values">Values to initialize the array</param>
            <returns>Constant representing the array</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantData">
            <summary>Base class for constants with no operands</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantDataArray">
            <summary>Array of constant data</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantDataSequential">
            <summary>
            A vector or array constant whose element type is a simple 1/2/4/8-byte integer
            or float/double, and whose elements are just simple data values
            (i.e. ConstantInt/ConstantFP).
            </summary>
            <remarks>
            This Constant node has no operands because
            it stores all of the elements of the constant as densely packed data, instead
            of as <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>s
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.ConstantDataSequential.IsString">
            <summary>Gets a value indicating whether this constant is a string</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.ConstantDataSequential.IsI8Sequence">
            <summary>Gets a value indicating whether this constant is a sequence of 8bit integral values</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ConstantDataSequential.ExtractAsString">
            <summary>Extract a string value from the constant (Assumes encoding ASCII)</summary>
            <returns>Extracted string</returns>
            <exception cref="T:System.InvalidOperationException">If IsI8Sequence isn't <see langword="true"/></exception>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ConstantDataSequential.ExtractAsString(System.Text.Encoding)">
            <summary>summary</summary>
            <param name="encoding">encoding</param>
            <returns>string</returns>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.ConstantDataSequential.RawData">
            <summary>Gets the raw Data for the data sequential as a <see cref="T:System.Span`1"/> of <see cref="T:System.Byte"/></summary>
            <remarks>
            This retrieves the underlying data, which may be empty, independent of the actual element type. Thus,
            issues of endian mismatch can occur between host assumptions and target. Thus, caution is warranted
            when using this property.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.ConstantDataSequential.Count">
            <summary>Gets the count of elements in this <see cref="T:Ubiquity.NET.Llvm.Values.ConstantDataSequential"/></summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantDataVector">
            <summary>Vector of Constant Data</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantExpression">
            <summary>While technically a type in LLVM, ConstantExpression is primarily a static factory for Constants</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.ConstantExpression.OpCode">
            <summary>Gets the constant instruction expression op code</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ConstantExpression.IntToPtrExpression(Ubiquity.NET.Llvm.Values.Constant,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Gets an IntToPtr expression to convert an integral value to a pointer</summary>
            <param name="value">Constant value to cast to a pointer</param>
            <param name="type">Type of the pointer to cast <paramref name="value"/> to</param>
            <returns>New pointer constant</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ConstantExpression.BitCast(Ubiquity.NET.Llvm.Values.Constant,Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a constant bit cast expression</summary>
            <param name="value">value to cast</param>
            <param name="toType">Type to cast to</param>
            <returns>Constant cast expression</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ConstantExpression.GetElementPtr(Ubiquity.NET.Llvm.Values.Constant,Ubiquity.NET.Llvm.Values.Constant[])">
            <summary>Creates a constant GetElementPtr expression</summary>
            <param name="value">Constant value to get the element pointer for</param>
            <param name="args">Pointer index args</param>
            <returns>GetElementPtr expression</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ConstantExpression.GetElementPtr(Ubiquity.NET.Llvm.Values.Constant,System.Collections.Generic.IEnumerable{Ubiquity.NET.Llvm.Values.Constant})">
            <summary>Creates a constant GetElementPtr expression</summary>
            <param name="value">Constant value to get the element pointer for</param>
            <param name="args">Pointer index args</param>
            <returns>GetElementPtr expression</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantFP">
            <summary>Floating point constant value in LLVM</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.ConstantFP.Value">
            <summary>Gets the value of the constant, possibly losing precision</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ConstantFP.GetValueWithLoss(System.Boolean@)">
            <summary>Gets the value of the constant, possibly losing precision</summary>
            <param name="loosesInfo">flag indicating if precision is lost</param>
            <returns>The value of the constant</returns>
            <remarks>
            Loss can occur when getting a target specific high resolution value,
            such as an 80bit Floating point value.
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantInt">
            <summary>Represents an arbitrary bit width integer constant in LLVM</summary>
            <remarks>
            Note - for integers, in LLVM, signed or unsigned is not part of the type of
            the integer. The distinction between them is determined entirely by the
            instructions used on the integer values.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.ConstantInt.BitWidth">
            <summary>Gets the number of bits in this integer constant</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.ConstantInt.ZeroExtendedValue">
            <summary>Gets the value of the constant zero extended to a 64 bit value</summary>
            <exception cref="T:System.InvalidOperationException">If <see cref="P:Ubiquity.NET.Llvm.Values.ConstantInt.BitWidth"/> is greater than 64 bits</exception>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.ConstantInt.SignExtendedValue">
            <summary>Gets the value of the constant sign extended to a 64 bit value</summary>
            <exception cref="T:System.InvalidOperationException">If <see cref="P:Ubiquity.NET.Llvm.Values.ConstantInt.BitWidth"/> is greater than 64 bits</exception>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantPointerNull">
            <summary>Represents a constant Null pointer</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ConstantPointerNull.From(Ubiquity.NET.Llvm.Types.ITypeRef)">
            <summary>Creates a constant null pointer to a given type</summary>
            <param name="type">Type of the pointer</param>
            <returns>Constant null value of the specified type</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantStruct">
            <summary>Constant Structure</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantTokenNone">
            <summary>Constant token that is empty</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ConstantVector">
            <summary>Vector of constant values</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.FunctionParameterList">
            <summary>Support class to provide read only list semantics to the parameters of a method</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.GlobalAlias">
            <summary>LLVM Global Alias for a function or global value</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalAlias.Aliasee">
            <summary>Gets or sets the aliasee that this Alias refers to</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.GlobalIFunc">
            <summary>Global Indirect Function</summary>
            <remarks>
            represents a single indirect function in the IR. Indirect function uses
            ELF symbol type extension to mark that the address of a declaration should
            be resolved at runtime by calling a resolver function.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalIFunc.Resolver">
            <summary>Gets or sets the ifunc resolver</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.GlobalIFunc.RemoveFromParent">
            <summary>Removes this instance from the parent module without destroying it</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.GlobalIndirectSymbol">
            <summary>Global Indirect Symbol</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalIndirectSymbol.IndirectSymbol">
            <summary>Gets or sets the symbol this indirectly references</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.GlobalObject">
            <summary>Base class for Global objects in an LLVM Module</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalObject.Alignment">
            <summary>Gets or sets the alignment requirements for this object</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalObject.Section">
            <summary>Gets or sets the linker section this object belongs to</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalObject.Comdat">
            <summary>Gets or sets the comdat attached to this object, if any</summary>
            <remarks>
            Setting this property to <see langword="null"/> or an
            empty string will remove any comdat setting for the
            global object.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.GlobalObject.SetMetadata(System.UInt32,Ubiquity.NET.Llvm.LlvmMetadata)">
            <summary>Sets metadata for this value</summary>
            <param name="kindID">Kind id for the metadata</param>
            <param name="node">Metadata wrapped as a value</param>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalObject.Metadata">
            <summary>Gets a snap-shot collection of the metadata for this global</summary>
            <returns>Enumerable of the metadata nodes for the global</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.GlobalObjectExtensions">
            <summary>Fluent style extensions for properties of <see cref="T:Ubiquity.NET.Llvm.Values.GlobalObject"/></summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.GlobalObjectExtensions.Comdat(Ubiquity.NET.Llvm.Values.GlobalObject,System.String)">
            <summary>Sets a named <see cref="T:Ubiquity.NET.Llvm.Comdat"/> for a <see cref="T:Ubiquity.NET.Llvm.Values.GlobalObject"/></summary>
            <param name="self">Global to get the Comdat for</param>
            <param name="name">name of the ComDat</param>
            <returns><paramref name="self"/> for fluent use</returns>
            <remarks>
            This finds a <see cref="T:Ubiquity.NET.Llvm.Comdat"/> in the <see cref="P:Ubiquity.NET.Llvm.Values.GlobalValue.ParentModule"/>
            of the object if it exists or creates a new one if it doesn't and assigns the <see cref="P:Ubiquity.NET.Llvm.Values.GlobalObject.Comdat"/>
            property with the <see cref="T:Ubiquity.NET.Llvm.Comdat"/>.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.GlobalObjectExtensions.Comdat(Ubiquity.NET.Llvm.Values.GlobalObject,System.String,Ubiquity.NET.Llvm.ComdatKind)">
            <summary>Sets a named <see cref="T:Ubiquity.NET.Llvm.Comdat"/> for a <see cref="T:Ubiquity.NET.Llvm.Values.GlobalObject"/></summary>
            <param name="self">Global to get the Comdat for</param>
            <param name="name">name of the Comdat</param>
            <param name="kind">Kind of Comdat to create if it doesn't exist already</param>
            <returns><paramref name="self"/> for fluent use</returns>
            <remarks>
            This finds a <see cref="T:Ubiquity.NET.Llvm.Comdat"/> in the <see cref="P:Ubiquity.NET.Llvm.Values.GlobalValue.ParentModule"/>
            of the object if it exists or creates a new one if it doesn't and assigns the <see cref="P:Ubiquity.NET.Llvm.Values.GlobalObject.Comdat"/>
            property with the <see cref="T:Ubiquity.NET.Llvm.Comdat"/>.
            </remarks>
            <seealso cref="P:Ubiquity.NET.Llvm.Values.GlobalObject.Comdat"/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.GlobalObjectExtensions.SectionName(Ubiquity.NET.Llvm.Values.GlobalObject,System.String)">
            <summary>Sets the linker section name for a <see cref="T:Ubiquity.NET.Llvm.Values.GlobalObject"/></summary>
            <param name="self"><see cref="T:Ubiquity.NET.Llvm.Values.GlobalObject"/> to set the section for</param>
            <param name="name">Name of the section</param>
            <returns><paramref name="self"/> for fluent use</returns>
            <seealso cref="P:Ubiquity.NET.Llvm.Values.GlobalObject.Section"/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.GlobalObjectExtensions.Alignment(Ubiquity.NET.Llvm.Values.GlobalObject,System.UInt32)">
            <summary>Sets the alignment for a <see cref="T:Ubiquity.NET.Llvm.Values.GlobalObject"/></summary>
            <param name="self">Object to set the alignment of</param>
            <param name="value">Alignment value to set</param>
            <returns><paramref name="self"/> for fluent use</returns>
            <seealso cref="P:Ubiquity.NET.Llvm.Values.GlobalObject.Alignment"/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.Linkage">
            <summary>Linkage specification for functions and globals</summary>
            <seealso href="xref:llvm_langref#linkage-types">LLVM Linkage Types</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.External">
            <summary>Externally visible Global</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.AvailableExternally">
            <summary>Available Externally</summary>
            <remarks>Globals with available_externally linkage are never emitted into the object file corresponding to the LLVM module.
            From the linkers perspective, an available_externally global is equivalent to an external declaration. They exist to allow
            in-lining and other optimizations to take place given knowledge of the definition of the global, which is known to be somewhere
            outside the module. Globals with available_externally linkage are allowed to be discarded at will, and allow in-lining and other
            optimizations. This linkage type is only allowed on definitions, not declarations.
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.LinkOnceAny">
            <summary>Keep a single copy when linking</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.LinkOnceODR">
            <summary>Like <see cref="F:Ubiquity.NET.Llvm.Values.Linkage.LinkOnceAny"/> but can only be replaced by equivalent (One Definition Rule)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.Weak">
            <summary>Keep one copy when linking (weak)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.WeakODR">
            <summary>Like <seealso cref="F:Ubiquity.NET.Llvm.Values.Linkage.Weak"/> but only replaced by something equivalent (e.g. One Definition Rule)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.Append">
            <summary>Special purpose, applies only to global arrays</summary>
            <seealso href="xref:llvm_langref#linkage-types"/>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.Internal">
            <summary>Rename collision when linking (i.e static function)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.Private">
            <summary>Link as <see cref="F:Ubiquity.NET.Llvm.Values.Linkage.Internal"/> but omit from the generated symbol table</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.DllImport">
            <summary>Global to be imported from a DLL</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.DllExport">
            <summary>Global to be Exported from a DLL</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.ExternalWeak">
            <summary>External weak linkage</summary>
            <remarks>
            The semantics of this linkage follow the ELF object file model: the symbol is weak until linked,
            if not linked, the symbol becomes null instead of being an undefined reference.
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.Common">
            <summary>Tentative definitions</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.LinkerPrivate">
            <summary>Like <see cref="F:Ubiquity.NET.Llvm.Values.Linkage.Private"/> but the linker remove this symbol</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Linkage.LinkerPrivateWeak">
            <summary>Weak form of <see cref="F:Ubiquity.NET.Llvm.Values.Linkage.LinkerPrivate"/></summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.Visibility">
            <summary>Enumeration for the visibility of a global value</summary>
            <remarks>
            A symbol with <see cref="F:Ubiquity.NET.Llvm.Values.Linkage.Internal"/> or <see cref="F:Ubiquity.NET.Llvm.Values.Linkage.Private"/>
            must have <see cref="F:Ubiquity.NET.Llvm.Values.Visibility.Default"/> visibility.
            </remarks>
            <seealso href="xref:llvm_langref#visibility-styles">LLVM Visibility Styles</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Visibility.Default">
            <summary>Default visibility for a <see cref="T:Ubiquity.NET.Llvm.Values.GlobalValue"/></summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Visibility.Hidden">
            <summary>Two declarations of an object with hidden visibility refer to the same object if they are in the same shared object</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.Visibility.Protected">
            <summary>Symbol cannot be overridden by another module</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.UnnamedAddressKind">
            <summary>Unnamed address state of a global value</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.UnnamedAddressKind.None">
            <summary>Address of the global is significant</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.UnnamedAddressKind.Local">
            <summary>Address of the global is locally significant</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.UnnamedAddressKind.Global">
            <summary>Address of the global is globally significant</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.GlobalValue">
            <summary>LLVM Global value </summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalValue.Visibility">
            <summary>Gets or sets the visibility of this global value</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalValue.Linkage">
            <summary>Gets or sets the linkage specification for this symbol</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalValue.UnnamedAddress">
            <summary>Gets or sets a value indicating whether this is an Unnamed address</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalValue.IsDeclaration">
            <summary>Gets a value indicating whether this is a declaration</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalValue.ParentModule">
            <summary>Gets the Module containing this global value</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.GlobalValueExtensions">
            <summary>Fluent style extensions for modifying properties of a <see cref="T:Ubiquity.NET.Llvm.Values.GlobalValue"/></summary>
            <remarks>
            These are not members of <see cref="T:Ubiquity.NET.Llvm.Values.GlobalValue"/> to allow the generic return type so that the return
            is for the specific type provided as input instead of the base type of GlobalValue.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.GlobalValueExtensions.Visibility``1(``0,Ubiquity.NET.Llvm.Values.Visibility)">
            <summary>Visibility of this global value</summary>
            <typeparam name="T">Type of the value (Must be <see cref="T:Ubiquity.NET.Llvm.Values.GlobalValue"/> or a type derived from it)</typeparam>
            <param name="self">Value to modify</param>
            <param name="value">New value to set</param>
            <returns><paramref name="self"/> for fluent usage patterns</returns>
            <seealso cref="P:Ubiquity.NET.Llvm.Values.GlobalValue.Visibility"/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.GlobalValueExtensions.Linkage``1(``0,Ubiquity.NET.Llvm.Values.Linkage)">
            <summary>Linkage specification for this symbol</summary>
            <typeparam name="T">Type of the value (Must be <see cref="T:Ubiquity.NET.Llvm.Values.GlobalValue"/> or a type derived from it)</typeparam>
            <param name="self">Value to modify</param>
            <param name="value">New value to set</param>
            <returns><paramref name="self"/> for fluent usage patterns</returns>
            <seealso cref="P:Ubiquity.NET.Llvm.Values.GlobalValue.Linkage"/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.GlobalValueExtensions.UnnamedAddress``1(``0,Ubiquity.NET.Llvm.Values.UnnamedAddressKind)">
            <summary>Sets the UnnamedAddress property of a value</summary>
            <typeparam name="T">Type of the value (Must be <see cref="T:Ubiquity.NET.Llvm.Values.GlobalValue"/> or a type derived from it)</typeparam>
            <param name="self">Value to modify</param>
            <param name="value">New value to set</param>
            <returns><paramref name="self"/> for fluent usage patterns</returns>
            <seealso cref="P:Ubiquity.NET.Llvm.Values.GlobalValue.UnnamedAddress"/>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.GlobalVariable">
            <summary>An LLVM Global Variable</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalVariable.IsExternallyInitialized">
            <summary>Gets or sets a value indicating whether this variable is initialized in an external module</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalVariable.IsConstant">
            <summary>Gets or sets a value indicating whether this global is a Constant</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalVariable.IsThreadLocal">
            <summary>Gets or sets a value indicating whether this global is stored per thread</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.GlobalVariable.Initializer">
            <summary>Gets or sets the initial value for the variable</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.GlobalVariable.AddDebugInfo(Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariableExpression)">
            <summary>Adds a <see cref="T:Ubiquity.NET.Llvm.DebugInfo.DIGlobalVariableExpression"/> for a <see cref="T:Ubiquity.NET.Llvm.Values.GlobalVariable"/></summary>
            <param name="expression">Expression to add</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.GlobalVariable.RemoveFromParent">
            <summary>Removes the value from its parent module, but does not delete it</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex">
            <summary>Function index for attributes</summary>
            <remarks>
            Attributes on functions apply to the function itself, the return type
            or one of the function's parameters. This enumeration is used to
            identify where the attribute applies.
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex.Function">
            <summary>The attribute applies to the function itself</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex.ReturnType">
            <summary>The attribute applies to the return type of the function</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.FunctionAttributeIndex.Parameter0">
            <summary>The attribute applies to the first parameter of the function</summary>
            <remarks>
            Additional parameters are identified by simply adding an integer value to
            this value. (i.e. FunctionAttributeIndex.Parameter0 + 1 )
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.IAttributeAccessor">
            <summary>Interface for raw attribute access</summary>
            <remarks>
            As of LLVM v3.9x and later, Functions and call sites use distinct LLVM-C API sets for
            manipulating attributes. Fortunately, they have consistent signatures so this interface
            is used to abstract the difference via derived types specialized for each case.
            Going forward this is the most direct way to manipulate attributes on a value as all the
            other forms ultimately come down to this interface.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IAttributeAccessor.GetAttributeCountAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex)">
            <summary>Gets the count of attributes on a given index</summary>
            <param name="index">Index to get the count for</param>
            <returns>Number of attributes on the specified index</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IAttributeAccessor.GetAttributesAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex)">
            <summary>Gets the attributes on a given index</summary>
            <param name="index">index to get the attributes for</param>
            <returns>Attributes for the index</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IAttributeAccessor.GetAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeKind)">
            <summary>Gets a specific attribute at a given index</summary>
            <param name="index">Index to get the attribute from</param>
            <param name="kind"><see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> to get</param>
            <returns>The specified attribute or the default <see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IAttributeAccessor.GetAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,System.String)">
            <summary>Gets a named attribute at a given index</summary>
            <param name="index">Index to get the attribute from</param>
            <param name="name">name of the attribute to get</param>
            <returns>The specified attribute or the default <see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/></returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IAttributeAccessor.AddAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeValue)">
            <summary>Adds an <see cref="T:Ubiquity.NET.Llvm.Values.AttributeValue"/> at a specified index</summary>
            <param name="index">Index to add the attribute to</param>
            <param name="attrib">Attribute to add</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IAttributeAccessor.RemoveAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeKind)">
            <summary>Removes an <see cref="T:Ubiquity.NET.Llvm.Values.AttributeKind"/> at a specified index</summary>
            <param name="index">Index to add the attribute to</param>
            <param name="kind">Attribute to Remove</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IAttributeAccessor.RemoveAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,System.String)">
            <summary>Removes a named attribute at a specified index</summary>
            <param name="index">Index to add the attribute to</param>
            <param name="name">Name of the attribute to remove</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.AsmDialect">
            <summary>Assembly language output dialect</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AsmDialect.ATT">
            <summary>AT&amp;T Style</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.AsmDialect.Intel">
            <summary>Intel Style</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.InlineAsm">
            <summary>Inline Assembly for the target</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.InlineAsm.#ctor(Ubiquity.NET.Llvm.Interop.LLVMValueRef)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.Values.InlineAsm"/> class from an <see cref="T:Ubiquity.NET.Llvm.Interop.LLVMValueRef"/></summary>
            <param name="valueRef">low level LLVM reference</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.CallingConvention">
            <summary>Calling Convention for functions</summary>
            <seealso href="xref:llvm_langref#calling-conventions">LLVM calling conventions</seealso>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.C">
            <summary> The default llvm calling convention, compatible with C</summary>
            <remarks>
            This convention is the only calling convention that supports varargs calls.
            As with typical C calling conventions, the callee/caller have to
            tolerate certain amounts of prototype mismatch
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.FastCall">
            <summary>Fast calling convention</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.ColdCall">
            <summary>Cold calling</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.GlasgowHaskellCompiler">
            <summary>Glasgow Haskell Compiler</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.HiPE">
            <summary>The High=Performance Erlang convention</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.WebKitJS">
            <summary>Webkit JavaScript calling convention</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.AnyReg">
            <summary>Calling convention for dynamic register based calls (e.g.stackmap and patchpoint intrinsics)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.PreserveMost">
            <summary>Preserve most calling convention for runtime calls that preserves most registers.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.PreserveAll">
            <summary>Preserve all calling convention for runtime calls that preserves (almost) all registers.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.Swift">
            <summary>Swift calling convention</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.CxxFastTls">
            <summary>Calling convention for access functions.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.FirstTargetSpecific">
            <summary>Marker enum that identifies the start of the target specific conventions all values greater than or equal to this value are target specific</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.X86StdCall">
            <summary>X86 stdcall convention</summary>
            <remarks>
            This calling convention is mostly used by the Win32 API. It is basically the same as the C
            convention with the difference in that the callee is responsible for popping the arguments
            from the stack.
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.X86FastCall">
            <summary>X86 fast call convention</summary>
            <remarks>
            'fast' analog of <see cref="F:Ubiquity.NET.Llvm.Values.CallingConvention.X86StdCall"/>. Passes first two arguments
            in ECX:EDX registers, others - via stack. Callee is responsible for
            stack cleaning.
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.ArmAPCS">
            <summary>ARM APCS (officially obsolete but some old targets use it)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.ArmAAPCS">
            <summary>ARM Architecture Procedure Calling Standard calling convention (aka EABI). Soft float variant</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.ArmAAPCSVfp">
            <summary>Same as <see cref="F:Ubiquity.NET.Llvm.Values.CallingConvention.ArmAAPCS"/> but uses hard floating point ABI</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.MSP430Interrupt">
            <summary>Calling convention used for MSP430 interrupt routines</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.X86ThisCall">
            <summary>Similar to <see cref="F:Ubiquity.NET.Llvm.Values.CallingConvention.X86StdCall"/>, passes first 'this' argument in ECX all others via stack</summary>
            <remarks>
            Callee is responsible for stack cleaning. MSVC uses this by default for C++ instance methods in its ABI
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.PtxKernel">
            <summary>Call to a PTX kernel</summary>
            <remarks>Passes all arguments in parameter space</remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.PtxDevice">
            <summary>Call to a PTX device function</summary>
            <remarks>
            Passes all arguments in register or parameter space.
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.SpirFunction">
            <summary>Calling convention for SPIR non-kernel device functions.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.SpirKernel">
            <summary>Calling convention for SPIR kernel functions.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.IntelOpenCLBuiltIn">
            <summary>Calling conventions for Intel OpenCL built-ins</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.X86x64SysV">
            <summary>The C convention as specified in the x86-64 supplement to the System V ABI, used on most non-Windows systems.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.X86x64Win64">
            <summary>The C convention as implemented on Windows/x86-64 and AArch64.</summary>
            <remarks>
            <para>This convention differs from the more common <see cref="F:Ubiquity.NET.Llvm.Values.CallingConvention.X86x64SysV"/> convention in a number of ways, most notably in
            that XMM registers used to pass arguments are shadowed by GPRs, and vice versa.</para>
            <para>On AArch64, this is identical to the normal C (AAPCS) calling convention for normal functions,
            but floats are passed in integer registers to variadic functions</para>
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.X86VectorCall">
            <summary>MSVC calling convention that passes vectors and vector aggregates in SSE registers</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.HHVM">
            <summary>Calling convention used by HipHop Virtual Machine (HHVM)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.HHVMCCall">
            <summary>HHVM calling convention for invoking C/C++ helpers</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.X86Interrupt">
            <summary>x86 hardware interrupt context</summary>
            <remarks>
            Callee may take one or two parameters, where the 1st represents a pointer to hardware context frame
            and the 2nd represents hardware error code, the presence of the later depends on the interrupt vector
            taken. Valid for both 32- and 64-bit subtargets.
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.AVRInterrupt">
            <summary>Used for AVR interrupt routines</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.AVRSignal">
            <summary>Calling convention used for AVR signal routines</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.AVRBuiltIn">
            <summary>Calling convention used for special AVR rtlib functions which have an "optimized" convention to preserve registers.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.AMDGpuVertexShader">
            <summary>Calling convention used for Mesa vertex shaders.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.AMDGpuGeometryShader">
            <summary>Calling convention used for Mesa geometry shaders.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.AMDGpuPixelShader">
            <summary>Calling convention used for Mesa pixel shaders.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.AMDGpuComputeShader">
            <summary>Calling convention used for Mesa compute shaders.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.AMDGpuKernel">
            <summary>Calling convention for AMDGPU code object kernels.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.X86RegCall">
            <summary>Register calling convention used for parameters transfer optimization</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.AMDGpuHullShader">
            <summary>Calling convention used for Mesa hull shaders. (= tessellation control shaders)</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.MSP430BuiltIn">
            <summary>Calling convention used for special MSP430 rtlib functions which have an "optimized" convention using additional registers.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.AMDGpuLS">
            <summary>Calling convention used for AMDPAL vertex shader if tessellation is in use.</summary>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.AMDGpuEs">
            <summary>Calling convention used for AMDPAL shader stage before geometry shader if geometry is in use.</summary>
            <remarks>
            Either the domain (= tessellation evaluation) shader if tessellation is in use, or otherwise the vertex shader.
            </remarks>
        </member>
        <member name="F:Ubiquity.NET.Llvm.Values.CallingConvention.MaxCallingConvention">
            <summary>The highest possible calling convention ID. Must be some 2^k - 1.</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.IrFunction">
            <summary>LLVM Function definition</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IrFunction.Signature">
            <summary>Gets the signature type of the function</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IrFunction.EntryBlock">
            <summary>Gets the Entry block for this function</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IrFunction.BasicBlocks">
            <summary>Gets the basic blocks for the function</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IrFunction.Parameters">
            <summary>Gets the parameters for the function including any method definition specific attributes (i.e. ByVal)</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IrFunction.CallingConvention">
            <summary>Gets or sets the Calling convention for the method</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IrFunction.IntrinsicId">
            <summary>Gets the LLVM instrinsicID for the method</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IrFunction.IsVarArg">
            <summary>Gets a value indicating whether the method signature accepts variable arguments</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IrFunction.ReturnType">
            <summary>Gets the return type of the function</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IrFunction.PersonalityFunction">
            <summary>Gets or sets the personality function for exception handling in this function</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IrFunction.DISubProgram">
            <summary>Gets or sets the debug information for this function</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IrFunction.GcName">
            <summary>Gets or sets the Garbage collection engine name that this function is generated to work with</summary>
            <seealso href="xref:llvm_docs_garbagecollection">Garbage Collection with LLVM</seealso>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.IrFunction.Attributes">
            <summary>Gets the attributes for this function</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.Verify">
            <summary>Verifies the function is valid and all blocks properly terminated</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.Verify(System.String@)">
            <summary>Verifies the function without throwing an exception</summary>
            <param name="errMsg">Error message if any, or <see cref="F:System.String.Empty"/> if no errors detected</param>
            <returns><see langword="true"/> if no errors found</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.PrependBasicBlock(System.String)">
            <summary>Add a new basic block to the beginning of a function</summary>
            <param name="name">Name (label) for the block</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> created and inserted at the beginning of the function</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.AppendBasicBlock(Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Appends a new basic block to a function</summary>
            <param name="block">Existing block to append to the function's list of blocks</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.AppendBasicBlock(System.String)">
            <summary>Creates an appends a new basic block to a function</summary>
            <param name="name">Name (label) of the block</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> created and inserted onto the end of the function</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.InsertBasicBlock(System.String,Ubiquity.NET.Llvm.Values.BasicBlock)">
            <summary>Inserts a basic block before another block in the function</summary>
            <param name="name">Name of the block</param>
            <param name="insertBefore">Block to insert the new block before</param>
            <returns>New <see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> inserted</returns>
            <exception cref="T:System.ArgumentException"><paramref name="insertBefore"/> belongs to a different function</exception>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.FindOrCreateNamedBlock(System.String)">
            <summary>Retrieves or creates block by name</summary>
            <param name="name">Block name (label) to look for or create</param>
            <returns><see cref="T:Ubiquity.NET.Llvm.Values.BasicBlock"/> If the block was created it is appended to the end of function</returns>
            <remarks>
            This method tries to find a block by it's name and returns it if found, if not found a new block is
            created and appended to the current function.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.AddAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeValue)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.GetAttributeCountAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.GetAttributesAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.GetAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeKind)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.GetAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.RemoveAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,Ubiquity.NET.Llvm.Values.AttributeKind)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.RemoveAttributeAtIndex(Ubiquity.NET.Llvm.Values.FunctionAttributeIndex,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.IrFunction.EraseFromParent">
            <summary>Removes this function from the parent module</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.UndefValue">
            <summary>Represents an undefined value in LLVM IR</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.Use">
            <summary>LLVM Use, which is essentially a tuple of the <see cref="P:Ubiquity.NET.Llvm.Values.Use.User"/> and the <see cref="P:Ubiquity.NET.Llvm.Values.Use.Value"/> used</summary>
            <remarks>
            A Use in LLVM forms a link in a directed graph of dependencies for values.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Use.User">
            <summary>Gets the <see cref="P:Ubiquity.NET.Llvm.Values.Use.User"/> of this <see cref="T:Ubiquity.NET.Llvm.Values.Use"/></summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Use.Value">
            <summary>Gets the <see cref="P:Ubiquity.NET.Llvm.Values.Use.Value"/> used</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Use.#ctor(Ubiquity.NET.Llvm.Interop.LLVMUseRef)">
            <summary>Initializes a new instance of the <see cref="T:Ubiquity.NET.Llvm.Values.Use"/> class from low level LLVM <see cref="T:Ubiquity.NET.Llvm.Interop.LLVMUseRef"/></summary>
            <param name="useRef">LLVM raw reference</param>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.User">
            <summary>Contains an LLVM User value</summary>
            <remarks>
            A user is one role in the user->uses relationship
            conveyed by the LLVM value model. A User can contain
            references (e.g. uses) of other values.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.User.Operands">
            <summary>Gets a list of the operands for this User</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.User.Uses">
            <summary>Gets a collection of <see cref="T:Ubiquity.NET.Llvm.Values.Use"/>s used by this User</summary>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.Value">
            <summary>LLVM Value</summary>
            <remarks>
            Value is the root of a hierarchy of types representing values in LLVM. Values (and derived classes)
            are never constructed directly with the new operator. Instead, they are produced by other classes
            in this library internally. This is because they are just wrappers around the LLVM-C API handles
            and must maintain the "uniqueing" semantics. (e.g. allowing reference equality for values that are
            fundamentally the same value). This is generally hidden in the internals of the Ubiquity.NET.Llvm library so
            that callers need not be concerned with the details but can rely on the expected behavior that two
            Value instances referring to the same actual value (i.e. a function) are actually the same .NET object
            as well within the same <see cref="T:Ubiquity.NET.Llvm.Context"/>
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Value.Name">
            <summary>Gets or sets name of the value (if any)</summary>
            <remarks>
            <note type="note">
            LLVM will add a numeric suffix to the name set if a
            value with the name already exists. Thus, the name
            read from this property may not match what is set.
            </note>
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Value.IsUndefined">
            <summary>Gets a value indicating whether this value is Undefined</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Value.IsNull">
            <summary>Gets a value indicating whether the Value represents the NULL value for the values type</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Value.NativeType">
            <summary>Gets the type of the value</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Value.Context">
            <summary>Gets the context for this value</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Value.IsInstruction">
            <summary>Gets a value indicating whether the Value is an instruction</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Value.IsFunction">
            <summary>Gets a value indicating whether the Value is a function</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.Value.IsCallSite">
            <summary>Gets a value indicating whether the Value is a call-site</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Value.ToString">
            <summary>Generates a string representing the LLVM syntax of the value</summary>
            <returns>string version of the value formatted by LLVM</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Value.ReplaceAllUsesWith(Ubiquity.NET.Llvm.Values.Value)">
            <summary>Replace all uses of a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> with another one</summary>
            <param name="other">New value</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Value.TryGetExtendedPropertyValue``1(System.String,``0@)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Value.AddExtendedPropertyValue(System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Value.FromHandle(Ubiquity.NET.Llvm.Interop.LLVMValueRef)">
            <summary>Gets an Ubiquity.NET.Llvm managed wrapper for a LibLLVM value handle</summary>
            <param name="valueRef">Value handle to wrap</param>
            <returns>Ubiquity.NET.Llvm managed instance for the handle</returns>
            <remarks>
            This method uses a cached mapping to ensure that two calls given the same
            input handle returns the same managed instance so that reference equality
            works as expected.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.Value.FromHandle``1(Ubiquity.NET.Llvm.Interop.LLVMValueRef)">
            <summary>Gets an Ubiquity.NET.Llvm managed wrapper for a LibLLVM value handle</summary>
            <typeparam name="T">Required type for the handle</typeparam>
            <param name="valueRef">Value handle to wrap</param>
            <returns>Ubiquity.NET.Llvm managed instance for the handle</returns>
            <remarks>
            This method uses a cached mapping to ensure that two calls given the same
            input handle returns the same managed instance so that reference equality
            works as expected.
            </remarks>
            <exception cref="T:System.InvalidCastException">When the handle is for a different type of handle than specified by <typeparamref name="T"/></exception>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ValueAttributeDictionary">
            <summary>re-usable implementation of IAttributeDictionary for containers that implement IAttributeAccessor</summary>
            <remarks>
            This uses the low-level methods of IAttributeAccessor to abstract out the differences in the
            LLVM-C API for attributes on CallSites vs. Functions
            </remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ValueExtensions">
            <summary>Provides extension methods to <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> that cannot be achieved as members of the class</summary>
            <remarks>
            Using generic static extension methods allows for fluent coding while retaining the type of the "this" parameter.
            If these were members of the <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> class then the only return type could be <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>,
            thus losing the original type and requiring a cast to get back to it.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ValueExtensions.RegisterName``1(``0,System.String)">
            <summary>Sets the virtual register name for a value</summary>
            <typeparam name="T"> Type of the value to set the name for</typeparam>
            <param name="value">Value to set register name for</param>
            <param name="name">Name for the virtual register the value represents</param>
            <remarks>
            <para>Technically speaking only an <see cref="T:Ubiquity.NET.Llvm.Instructions.Instruction"/> can have register name
            information. However, since LLVM will perform constant folding in the <see cref="T:Ubiquity.NET.Llvm.Instructions.InstructionBuilder"/>
            most of the methods in <see cref="T:Ubiquity.NET.Llvm.Instructions.InstructionBuilder"/> return a <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> rather
            than a more specific <see cref="T:Ubiquity.NET.Llvm.Instructions.Instruction"/>. Thus, without this extension method here,
            code would need to know ahead of time that an actual instruction would be produced then cast the result
            to an <see cref="T:Ubiquity.NET.Llvm.Instructions.Instruction"/> and then set the debug location. This makes the code rather
            ugly and tedious to manage. Placing this as a generic extension method ensures that the return type matches
            the original and no additional casting is needed, which would defeat the purpose of doing this. For
            <see cref="T:Ubiquity.NET.Llvm.Values.Value"/> types that are not instructions this does nothing. This allows for a simpler fluent
            style of programming where the actual type is retained even in cases where an <see cref="T:Ubiquity.NET.Llvm.Instructions.InstructionBuilder"/>
            method will always return an actual instruction.</para>
            <para>Since the <see cref="P:Ubiquity.NET.Llvm.Values.Value.Name"/> property is available on all <see cref="T:Ubiquity.NET.Llvm.Values.Value"/>s this is slightly
            redundant. It is useful for maintaining the fluent style of coding along with expressing intent more clearly.
            (e.g. using this makes it expressly clear that the intent is to set the virtual register name and not the
            name of a local variable etc...) Using the fluent style allows a significant reduction in the number of
            overloaded methods in <see cref="T:Ubiquity.NET.Llvm.Instructions.InstructionBuilder"/> to account for all variations with or without a name.
            </para>
            </remarks>
            <returns><paramref name="value"/> for fluent usage</returns>
        </member>
        <member name="T:Ubiquity.NET.Llvm.Values.ValueOperandListCollection`1">
            <summary>Support class to provide read/update semantics to the operands of a container element</summary>
            <typeparam name="T">Type of elements in the collection</typeparam>
            <remarks>
            This class is used to implement Operand lists of elements including sub lists based on an offset.
            The latter case is useful for types that expose some fixed set of operands as properties and some
            arbitrary number of additional items as operands.
            </remarks>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.ValueOperandListCollection`1.Item(System.Int32)">
            <summary>Gets the operand at the specified index</summary>
            <param name="index">Index of the operand to receive</param>
            <returns>Item at the specified index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is out of range for this collection</exception>
        </member>
        <member name="P:Ubiquity.NET.Llvm.Values.ValueOperandListCollection`1.Count">
            <summary>Gets the count of operands in this collection</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ValueOperandListCollection`1.GetEnumerator">
            <summary>Gets an enumerator for this collection</summary>
            <returns>Enumerator for the operands in this collection</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ValueOperandListCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets an enumerator for this collection</summary>
            <returns>Enumerator for the operands in this collection</returns>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ValueOperandListCollection`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Ubiquity.NET.Llvm.Values.ValueOperandListCollection`1.GetOperand``1(System.Index)">
            <summary>Specialized indexer to get the element as a specific derived type</summary>
            <typeparam name="TItem">Type of the element (must be derived from <see cref="T:Ubiquity.NET.Llvm.LlvmMetadata"/></typeparam>
            <param name="i">index for the item</param>
            <returns>Item at the specified index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is out of range for the collection</exception>
            <exception cref="T:System.InvalidCastException">If the element at the index is not castable to <typeparamref name="TItem"/></exception>
            <remarks>This provides a common (and likely internally optimized) means of getting an element as a specific type</remarks>
        </member>
        <member name="T:Ubiquity.NET.Llvm.WriteOnce`1">
            <summary>Wrapper class to provide Write-Once semantics to a value</summary>
            <typeparam name="T">Type of value to store</typeparam>
            <remarks>
            This provides write once semantics for fields that may require initialization
            outside the context of a constructor, but once set should never be set again.
            Allowing a sort of lazy <see langword="readonly"/>.
            </remarks>
        </member>
        <member name="M:Ubiquity.NET.Llvm.WriteOnce`1.ToString">
            <inheritdoc/>
        </member>
        <member name="P:Ubiquity.NET.Llvm.WriteOnce`1.Value">
            <summary>Gets or sets the value for this instance</summary>
            <exception cref="T:System.InvalidOperationException">Getting the value when no value is set</exception>
            <exception cref="T:System.InvalidOperationException">Setting the value when a value is already set</exception>
        </member>
        <member name="T:Ubiquity.NET.Llvm.WriteOnce`1.Initializer">
            <summary>Initializer</summary>
            <param name="value">value to initialize</param>
        </member>
        <member name="M:Ubiquity.NET.Llvm.WriteOnce`1.InitializeWith(Ubiquity.NET.Llvm.WriteOnce{`0}.Initializer)">
            <summary>Initializes the value via a delegate using an out parameter</summary>
            <param name="initializer">delegate to initialize the value from</param>
            <returns>This instance for fluent style use</returns>
        </member>
        <member name="P:Ubiquity.NET.Llvm.WriteOnce`1.HasValue">
            <summary>Gets a value indicating whether the <see cref="P:Ubiquity.NET.Llvm.WriteOnce`1.Value"/> was set or not</summary>
        </member>
        <member name="P:Ubiquity.NET.Llvm.WriteOnce`1.ValueOrDefault">
            <summary>Gets the current value or the default value for <typeparamref name="T"/> if not yet set</summary>
        </member>
        <member name="M:Ubiquity.NET.Llvm.WriteOnce`1.op_Implicit(Ubiquity.NET.Llvm.WriteOnce{`0})~`0">
            <summary>Convenience implicit cast as a wrapper around the <see cref="P:Ubiquity.NET.Llvm.WriteOnce`1.Value"/> parameter</summary>
            <param name="value"> <see cref="T:Ubiquity.NET.Llvm.WriteOnce`1"/> instance to extract a value from</param>
        </member>
    </members>
</doc>
