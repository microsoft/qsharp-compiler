// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

module Microsoft.Quantum.QsCompiler.CompilerOptimization.VariableRenaming

open System
open System.Collections.Immutable
open System.Text.RegularExpressions
open Microsoft.Quantum.QsCompiler.DataTypes
open Microsoft.Quantum.QsCompiler.SyntaxExtensions
open Microsoft.Quantum.QsCompiler.SyntaxTokens
open Microsoft.Quantum.QsCompiler.SyntaxTree
open Microsoft.Quantum.QsCompiler.Transformations.Core

open ComputationExpressions
open Utils


/// Returns a copy of the given variable stack inside of a new scope
let private enterScope map = Map.empty :: map

/// Returns a copy of the given variable stack outside of the current scope.
/// Throws an ArgumentException if the given variable stack is empty.
let private exitScope = List.tail

/// Returns the value associated to the given key in the given variable stack.
/// If the key is associated with multiple values, returns the one highest on the stack.
/// Returns None if the key isn't associated with any values.
let private tryGet key = List.tryPick (Map.tryFind key)

/// Returns a copy of the given variable stack with the given key set to the given value.
/// Throws an ArgumentException if the given variable stack is empty.
let private set (key, value) = function
| [] -> ArgumentException "No scope to define variables in" |> raise
| head :: tail -> Map.add key value head :: tail

/// A regex that matches the original name of a mangled variable name
let private varNameRegex = Regex("^__qsVar\d+__(.+)__$")


/// The ScopeTransformation used to ensure unique variable names.
/// When called on a function body, will transform it such that all local variables defined
/// in the function body have unique names, generating new variable names if needed.
/// Autogenerated variable names have the form __qsVar[X]__[name]__.
type VariableRenamer(argTuple: QsArgumentTuple) =
    inherit ScopeTransformation()

    /// The number of times a variable is referenced
    let mutable numUses = Map.empty
    /// The current dictionary of new names to substitute for variables
    let mutable newNames = [Map.empty]
    /// Whether we should skip entering the next scope we encounter
    let mutable skipScope = false

    /// Given a possibly-mangled variable name, returns the original variable name
    let demangle varName =
        let m = varNameRegex.Match varName
        if m.Success then m.Groups.[1].Value else varName

    /// Given a new variable name, generates a new unique name and updates the state accordingly
    let generateUniqueName varName =
        let baseName = demangle varName
        let mutable num, newName = 0, baseName
        while numUses.ContainsKey newName do
            num <- num + 1
            newName <- sprintf "__qsVar%d__%s__" num baseName
        numUses <- Map.add newName 0 numUses
        newNames <- set (varName, newName) newNames
        newName

    /// Processes the initial argument tuple from the function declaration
    let rec processArgTuple = function
    | QsTupleItem {VariableName = ValidName name} -> generateUniqueName name.Value |> ignore
    | QsTupleItem {VariableName = InvalidName} -> ()
    | QsTuple items -> Seq.iter processArgTuple items

    do processArgTuple argTuple

    /// Returns the number of times a variable is referenced
    member internal __.getNumUses name = Map.tryFind name numUses


    override __.Transform x =
        if skipScope then
            skipScope <- false
            base.Transform x
        else
            newNames <- enterScope newNames
            let result = base.Transform x
            newNames <- exitScope newNames
            result

    override __.Expression = { new ExpressionTransformation() with
        override expr.Kind = { new ExpressionKindTransformation() with
            override __.ExpressionTransformation ex = expr.Transform ex
            override __.TypeTransformation t = expr.Type.Transform t

            override __.onIdentifier (sym, tArgs) =
                maybe {
                    let! name =
                        match sym with
                        | LocalVariable name -> Some name.Value
                        | _ -> None
                    let! newName = tryGet name newNames
                    numUses <- Map.add newName (Map.find newName numUses + 1) numUses
                    return Identifier (LocalVariable (NonNullable<_>.New newName), tArgs)
                } |? Identifier (sym, tArgs)
        }
    }

    override this.StatementKind = { new StatementKindTransformation() with
        override __.ExpressionTransformation x = this.Expression.Transform x
        override __.LocationTransformation x = this.onLocation x
        override __.ScopeTransformation x = this.Transform x
        override __.TypeTransformation x = this.Expression.Type.Transform x

        override this.onSymbolTuple syms =
            match syms with
            | VariableName item -> VariableName (NonNullable<_>.New (generateUniqueName item.Value))
            | VariableNameTuple items -> Seq.map this.onSymbolTuple items |> ImmutableArray.CreateRange |> VariableNameTuple
            | InvalidItem | DiscardedItem -> syms

        override this.onVariableDeclaration stm =
            let rhs = this.ExpressionTransformation stm.Rhs
            let lhs = this.onSymbolTuple stm.Lhs
            QsBinding<TypedExpression>.New stm.Kind (lhs, rhs) |> QsVariableDeclaration

        override this.onForStatement stm =
            let iterVals = this.ExpressionTransformation stm.IterationValues
            let loopVar = fst stm.LoopItem |> this.onSymbolTuple
            let loopVarType = this.TypeTransformation (snd stm.LoopItem)
            let body = this.ScopeTransformation stm.Body
            QsForStatement.New ((loopVar, loopVarType), iterVals, body) |> QsForStatement

        override __.onRepeatStatement stm =
            newNames <- enterScope newNames
            skipScope <- true
            let result = base.onRepeatStatement stm
            newNames <- exitScope newNames
            result

        override this.onQubitScope (stm : QsQubitScope) =
            let kind = stm.Kind
            let rhs = this.onQubitInitializer stm.Binding.Rhs
            let lhs = this.onSymbolTuple stm.Binding.Lhs
            let body = this.ScopeTransformation stm.Body
            QsQubitScope.New kind ((lhs, rhs), body) |> QsQubitScope
    }
