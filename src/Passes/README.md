# Profile adoption tool

# Getting started

## Quick start

Once the project is built (see next sections), you can generate a new QIR as follows:

```sh
./Source/Apps/qat --generate --profile baseProfile ../examples/QirAllocationAnalysis/analysis-example.ll
```

Likewise, you can validate that a QIR follows a specification by running:

```sh
./Source/Apps/qat --validate --profile baseProfile ../examples/QirAllocationAnalysis/analysis-example.ll
```

## Example

In this example, we start with a QIR generated by the Q# frontend. Rather than giving the full 3445 lines of QIR, we instead give the frontend code:

```
namespace TeleportChain {
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Arrays;
    open Microsoft.Quantum.Measurement;
    open Microsoft.Quantum.Preparation;

    operation PrepareEntangledPair(left : Qubit, right : Qubit) : Unit is Adj + Ctl {
        H(left);
        CNOT(left, right);
    }

    operation ApplyCorrection(src : Qubit, intermediary : Qubit, dest : Qubit) : Unit {
        if (MResetZ(src) == One) { Z(dest); }
        if (MResetZ(intermediary) == One) { X(dest); }
    }

    operation TeleportQubitUsingPresharedEntanglement(src : Qubit, intermediary : Qubit, dest : Qubit) : Unit {
        Adjoint PrepareEntangledPair(src, intermediary);
        ApplyCorrection(src, intermediary, dest);
    }

    operation TeleportQubit(src : Qubit, dest : Qubit) : Unit {
        use intermediary = Qubit();
        PrepareEntangledPair(intermediary, dest);
        TeleportQubitUsingPresharedEntanglement(src, intermediary, dest);
    }

    operation DemonstrateEntanglementSwapping() : (Result, Result) {
        use (reference, src, intermediary, dest) = (Qubit(), Qubit(), Qubit(), Qubit());
        PrepareEntangledPair(reference, src);
        TeleportQubit(src, dest);
        return (MResetZ(reference), MResetZ(dest));
    }

    @EntryPoint()
    operation DemonstrateTeleportationUsingPresharedEntanglement() : Unit {
        let nPairs = 2;
        use (leftMessage, rightMessage, leftPreshared, rightPreshared) = (Qubit(), Qubit(), Qubit[nPairs], Qubit[nPairs]);
        PrepareEntangledPair(leftMessage, rightMessage);
        for i in 0..nPairs-1 {
            PrepareEntangledPair(leftPreshared[i], rightPreshared[i]);
        }

        TeleportQubitUsingPresharedEntanglement(rightMessage, leftPreshared[0], rightPreshared[0]);
        for i in 1..nPairs-1 {
            TeleportQubitUsingPresharedEntanglement(rightPreshared[i-1], leftPreshared[i], rightPreshared[i]);
        }

        let _ = MResetZ(leftMessage);
        let _ =  MResetZ(rightPreshared[nPairs-1]);
    }
}
```

Once compiled and the initial QIR is generated and save in the file `analysis-example.ll`, we execute the command

```
./Source/Apps/qat --generate --profile baseProfile ./analysis-example.ll
```

The QAT tool will now attempt to map the QIR in `analysis-example.ll` into a QIR which is compatible with the base format. Removing type and function declarations, the correspoding code reads:

```
; ModuleID = './analysis-example.ll'
source_filename = "./analysis-example.ll"

define internal fastcc void @TeleportChain__DemonstrateTeleportationUsingPresharedEntanglement__body() unnamed_addr {
entry:
  call void @__quantum__qis__h(%Qubit* null)
  call void @__quantum__qis__cnot(%Qubit* null, %Qubit* nonnull inttoptr (i64 1 to %Qubit*))
  call void @__quantum__qis__h(%Qubit* null)
  call void @__quantum__qis__cnot(%Qubit* null, %Qubit* nonnull inttoptr (i64 2 to %Qubit*))
  call void @__quantum__qis__h(%Qubit* nonnull inttoptr (i64 1 to %Qubit*))
  call void @__quantum__qis__cnot(%Qubit* nonnull inttoptr (i64 1 to %Qubit*), %Qubit* nonnull inttoptr (i64 3 to %Qubit*))
  call void @__quantum__qis__cnot(%Qubit* nonnull inttoptr (i64 1 to %Qubit*), %Qubit* null)
  call void @__quantum__qis__h(%Qubit* nonnull inttoptr (i64 1 to %Qubit*))
  %0 = call i1 @__quantum__qir__read_result(%Result* nonnull inttoptr (i64 4 to %Result*))
  call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*), %Result* nonnull inttoptr (i64 4 to %Result*))
  call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*))
  br i1 %0, label %then0__1.i.i, label %continue__1.i.i

then0__1.i.i:                                     ; preds = %entry
  call void @__quantum__qis__z(%Qubit* nonnull inttoptr (i64 2 to %Qubit*))
  br label %continue__1.i.i

continue__1.i.i:                                  ; preds = %then0__1.i.i, %entry
  %1 = call i1 @__quantum__qir__read_result(%Result* nonnull inttoptr (i64 5 to %Result*))
  call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 5 to %Result*))
  call void @__quantum__qis__reset__body(%Qubit* null)
  br i1 %1, label %then0__2.i.i, label %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.1.exit

then0__2.i.i:                                     ; preds = %continue__1.i.i
  call void @__quantum__qis__x(%Qubit* nonnull inttoptr (i64 2 to %Qubit*))
  br label %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.1.exit

TeleportChain__TeleportQubitUsingPresharedEntanglement__body.1.exit: ; preds = %continue__1.i.i, %then0__2.i.i
  call void @__quantum__qis__cnot(%Qubit* nonnull inttoptr (i64 2 to %Qubit*), %Qubit* nonnull inttoptr (i64 1 to %Qubit*))
  call void @__quantum__qis__h(%Qubit* nonnull inttoptr (i64 2 to %Qubit*))
  %2 = call i1 @__quantum__qir__read_result(%Result* nonnull inttoptr (i64 6 to %Result*))
  call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*), %Result* nonnull inttoptr (i64 6 to %Result*))
  call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*))
  br i1 %2, label %then0__1.i.i2, label %continue__1.i.i3

then0__1.i.i2:                                    ; preds = %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.1.exit
  call void @__quantum__qis__z(%Qubit* nonnull inttoptr (i64 3 to %Qubit*))
  br label %continue__1.i.i3

continue__1.i.i3:                                 ; preds = %then0__1.i.i2, %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.1.exit
  %3 = call i1 @__quantum__qir__read_result(%Result* nonnull inttoptr (i64 7 to %Result*))
  call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*), %Result* nonnull inttoptr (i64 7 to %Result*))
  call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*))
  br i1 %3, label %then0__2.i.i4, label %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit

then0__2.i.i4:                                    ; preds = %continue__1.i.i3
  call void @__quantum__qis__x(%Qubit* nonnull inttoptr (i64 3 to %Qubit*))
  br label %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit

TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit: ; preds = %continue__1.i.i3, %then0__2.i.i4
  call void @__quantum__qis__mz__body(%Qubit* null, %Result* null)
  call void @__quantum__qis__reset__body(%Qubit* null)
  call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 3 to %Qubit*), %Result* nonnull inttoptr (i64 1 to %Result*))
  call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 3 to %Qubit*))
  ret void
}

```

We note the absence of loops, and that quantum registers are "allocated" at compile time meaning that each qubit instance is assigned a unique ID. As some code may be dead and optimised away, the qubit allocation is not garantueed to be sequential at this point in time. Future work will include writing a qubit ID remapper which will allow qubit IDs to become strictly increasing with no gaps inbetween.

We also note that the function `TeleportChain__TeleportQubitUsingPresharedEntanglement__body` was cloned twice. This is due to the allocation of qubits and the function being called twice. At present, the analyser does not take qubit release into account and just assumes that it will never be released due to the complicated nature for dealing with nested functions at compile time.

## Dependencies

This library is written in C++ and depends on:

- LLVM

Additional development dependencies include:

- CMake
- clang-format
- clang-tidy

## Building the passes

To build the passes, create a new build directory and switch to that directory:

```sh
mkdir Debug
cd Debug/
```

To build the library, first configure CMake from the build directory

```sh
cmake ..
```

and then make your target

```sh
make [target]
```

The default target is `all`. Other valid targets are the name of the folders in `libs/` found in the passes root.

# Profile adoption tool

## Building QAT

First

```sh
cd Debug
make qat
```

then

```sh
./Source/Apps/qat
```

## Implementing a profile pass

As an example of how one can implement a new profile pass, we here show the implementational details of our example pass which allows mapping the teleportation code to the base profile:

```c++
        pb.registerPipelineParsingCallback([](StringRef name, FunctionPassManager &fpm,
                                              ArrayRef<PassBuilder::PipelineElement> /*unused*/) {
          // Base profile
          if (name == "restrict-qir<base-profile>")
          {
            RuleSet rule_set;

            // Defining the mapping
            auto factory = RuleFactory(rule_set);

            factory.useStaticQuantumArrayAllocation();
            factory.useStaticQuantumAllocation();
            factory.useStaticResultAllocation();

            factory.optimiseBranchQuatumOne();
            //  factory.optimiseBranchQuatumZero();

            factory.disableReferenceCounting();
            factory.disableAliasCounting();
            factory.disableStringSupport();

            fpm.addPass(TransformationRulePass(std::move(rule_set)));
            return true;
          }

          return false;
        });
      }};
```

Transformations of the IR will happen on the basis of what rules are added to the rule set. The purpose of the factory is to make easy to add rules that serve a single purpose as well as making a basis for making rules unit testable.

## Implementing new rules

Implementing new rules consists of two steps: Defining a pattern that one wish to replace and implementing the corresponding replacement logic. Inside a factory member function, this look as follows:

```c++
  auto get_element =
      Call("__quantum__rt__array_get_element_ptr_1d", "arrayName"_cap = _, "index"_cap = _);
  auto cast_pattern = BitCast("getElement"_cap = get_element);
  auto load_pattern = Load("cast"_cap = cast_pattern);

  addRule({std::move(load_pattern), access_replacer});
```

where `addRule` adds the rule to the current rule set.

### Capturing patterns

The pattern defined in this snippet matches IR like:

```c++
  %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared, i64 0)
  %1 = bitcast i8* %0 to %Qubit**
  %2 = load %Qubit*, %Qubit** %1, align 8
```

In the above rule, the first and a second argument of `__quantum__rt__array_get_element_ptr_1d` is captured as `arrayName` and `index`, respectively. Likewise, the bitcast instruction is captured as `cast`. Each of these captures will be available inside the replacement function `access_replacer`.

### Implementing replacement logic

After a positive match is found, the lead instruction alongside a IRBuilder, a capture table and a replacement table is passed to the replacement function. Here is an example on how one can access the captured variables to perform a transformation of the IR:

```c++
  auto access_replacer = [qubit_alloc_manager](Builder &builder, Value *val, Captures &cap,
                                               Replacements &replacements) {
    // ...
    auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap["index"]);
    // ...
    auto llvm_size = cst->getValue();
    auto offset    = qubit_alloc_manager->getOffset(cap["arrayName"]->getName().str());

    auto idx = llvm::APInt(llvm_size.getBitWidth(), llvm_size.getZExtValue() + offset);
    auto new_index = llvm::ConstantInt::get(builder.getContext(), idx);
    auto instr = new llvm::IntToPtrInst(new_index, ptr_type);
    instr->takeName(val);

    // Replacing the lead instruction with a the new instruction
    replacements.push_back({llvm::dyn_cast<Instruction>(val), instr});

    // Deleting the getelement and cast operations
    replacements.push_back({llvm::dyn_cast<Instruction>(cap["getElement"]), nullptr});
    replacements.push_back({llvm::dyn_cast<Instruction>(cap["cast"]), nullptr});

    return true;
  };
```

# Passes

## Running a pass

You can run a pass using [opt](https://llvm.org/docs/CommandGuide/opt.html) as follows:

```sh
cd examples/ClassicalIrCommandline
make emit-llvm-bc
opt -load-pass-plugin ../../{Debug,Release}/libOpsCounter.{dylib,so} --passes="print<operation-counter>" -disable-output classical-program.bc
```

For a detailed tutorial, see examples.

## Creating a new pass

To make it easy to create a new pass, we have created a few templates to get you started quickly:

```sh
./manage create-pass HelloWorld
Available templates:

1. Function Pass

Select a template:1
```

At the moment you only have one choice which is a function pass. Over time we will add additional templates. Once you have instantiated your template, you are ready to build it:

```sh
mkdir Debug
cd Debug
cmake ..
-- The C compiler identification is AppleClang 12.0.5.12050022
-- The CXX compiler identification is AppleClang 12.0.5.12050022
(...)
-- Configuring done
-- Generating done
-- Build files have been written to: ./qsharp-compiler/src/Passes/Debug

make

[ 25%] Building CXX object libs/CMakeFiles/OpsCounter.dir/OpsCounter/OpsCounter.cpp.o
[ 50%] Linking CXX shared library libOpsCounter.dylib
[ 50%] Built target OpsCounter
[ 75%] Building CXX object libs/CMakeFiles/HelloWorld.dir/HelloWorld/HelloWorld.cpp.o
[100%] Linking CXX shared library libHelloWorld.dylib
[100%] Built target HelloWorld
```

Your new pass is ready to be implemented. Open `libs/HelloWorld/HelloWorld.cpp` to implement the details of the pass. At the moment, the
template will not do much except for print the function names of your code. To test your new pass go to the directory `examples/ClassicalIrCommandline`,
build an IR and run the pass:

```sh
cd ../examples/ClassicalIrCommandline
make
opt -load-pass-plugin ../../Debug/libs/libHelloWorld.{dylib,so} --passes="hello-world" -disable-output classical-program.ll
```

If everything worked, you should see output like this:

```sh
Implement your pass here: foo
Implement your pass here: bar
Implement your pass here: main
```

## CI

Before making a pull request with changes to this library, please ensure that style checks passes, that the code compiles,
unit test passes and that there are no erros found by the static analyser.

To setup the CI environment, run following commands

```sh
source develop.env
virtualenv develop__venv
source develop__venv/bin/activate
pip install -r requirements.txt
```

These adds the necessary environment variables to ensure that you have the `TasksCI` package and all required dependencies.

To check the style, run

```sh
./manage stylecheck
```

To test that the code compiles and tests passes run

```sh
./manage test
```

Finally, to analyse the code, run

```sh
./manage lint
```

You can run all processes by running:

```sh
./manage runci
```

As `clang-tidy` and `clang-format` acts slightly different from version to version and on different platforms, it is recommended
that you use a docker image to perform these steps. TODO(TFR): The docker image is not added yet and this will be documented in the future.

# Developer FAQ

## Pass does not load

One error that you may encounter is that an analysis pass does not load with output similar to this:

```sh
opt -load-pass-plugin ../../Debug/libQSharpPasses.dylib -enable-debugify  --passes="operation-counter" -disable-output   classical-program.bc
Failed to load passes from '../../Debug/libQSharpPasses.dylib'. Request ignored.
opt: unknown pass name 'operation-counter'
```

This is likely becuase you have forgotten to instantiate static class members. For instance, in the case of an instance of `llvm::AnalysisInfoMixin` you are required to have static member `Key`:

```cpp
class COpsCounterPass :  public llvm::AnalysisInfoMixin<COpsCounterPass> {
private:
  static llvm::AnalysisKey Key; //< REQUIRED by llvm registration
  friend struct llvm::AnalysisInfoMixin<COpsCounterPass>;
};
```

If you forget to instantiate this variable in your corresponding `.cpp` file,

```cpp
// llvm::AnalysisKey COpsCounterPass::Key; //< Uncomment this line to make everything work
```

everything will compile, but the pass will fail to load. There will be no linking errors either.
