# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

from .formatting import main as style_check_main
from .builder import main as builder_main
from .coverage import main as coverage_main
from .linting import main as lint_main, clang_tidy_diagnose

import click
import logging
import sys
import os
import re
from typing import Union

OptionalInt = Union[int, None]
OptionalStr = Union[str, None]

# Important directories
LIB_DIR = os.path.abspath(os.path.dirname((__file__)))
TEMPLATE_DIR = os.path.join(LIB_DIR, "templates")
SOURCE_DIR = os.path.abspath(os.path.dirname(os.path.dirname(LIB_DIR)))

# Logging configuration
logger = logging.getLogger()
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)

# By default we only log errors
logger.setLevel(logging.ERROR)


@click.group()
@click.option('--loglevel', default="error")
def cli(loglevel: str) -> None:
    """
    Implements the general CLI options such as logging level.
    """

    # Valid values
    levels = {
        "critical": 50,
        "error": 40,
        "warning": 30,
        "info": 20,
        "debug": 10,
        "notset": 0
    }

    # Getting the logging level and updating
    loglevel = loglevel.lower()
    if loglevel not in levels:
        logger.critical("Invalid log level")
        sys.exit(-1)

    logger.setLevel(levels[loglevel])
    logger.info("Loglevel set to {}".format(loglevel))


@cli.command()
@click.option('--fix-issues', default=False, is_flag=True)
def stylecheck(fix_issues: bool) -> None:
    """
    Command for checking the style and optionally fixing issues. 
    Note that some issues are not automatically fixed.
    """

    logger.info("Invoking style checker")
    style_check_main(fix_issues)


@cli.command()
@click.option("--diagnose", default=False, is_flag=True)
@click.option('--fix-issues', default=False, is_flag=True)
@click.option('--force', default=False, is_flag=True)
def lint(diagnose: bool, fix_issues: bool, force: bool) -> None:
    """
    Command for linting the code.
    """

    # Helpful option in order to diagnose Clang tidy.
    if diagnose:
        clang_tidy_diagnose()

        # In case we are diagnosing, no run is performed.
        return

    # Allowing Clang tidy to attempt to fix issues. Generally,
    # it is discouraged to use this features as it may result in
    # a catastrophy
    if fix_issues:
        if not force:
            print("""Fixing isssues using Clang Tidy will break your code.
Make sure that you have committed your changes BEFORE DOING THIS.
Even so, this feature is experimental and there have been reports of
clang-tidy modying system libraries - therefore, USE THIS FEATURE AT
YOUR OWN RISK.

Write 'I understand' to proceed.""")
            print(":")
            x = input()
            if x.lower() != "i understand":
                print("Wrong answer - stopping!")
                exit(-1)

    # Running the linter
    logger.info("Invoking linter")
    lint_main(fix_issues)


@cli.command()
@click.option('--debug/--no-debug', default=True)
@click.option('--generator', default=None)
def test(debug: bool, generator: OptionalStr) -> None:
    """
    Command to build and test the code base.
    """

    logger.info("Building and testing")

    build_dir = "Debug"
    if not debug:
        build_dir = "Release"

    builder_main(build_dir, generator, True)


@cli.command()
def runci() -> None:
    """
    Command to run all CI commands, starting with style check
    then linting and finally unit tests.
    """

    build_dir = "Debug"

    style_check_main(False)
    lint_main(False)
    builder_main(build_dir, None, True)


@click.option(
    "--output",
    default=None,
)
@click.option(
    "--format",
    default="html",
)
@cli.command()
def coverage(output: OptionalStr, format: str) -> None:
    """
    Generates a test coverage report
    """

    build_dir = "Debug"

    # Creating a build that generate coverage information and runs the
    # corresponding tests
    builder_main(build_dir, None, False, ["-DMICROSOFT_GENERATE_COVERAGE=ON"])

    # Generating report
    coverage_main(build_dir, output, format)


@cli.command()
@click.argument(
    "name"
)
@click.option(
    "--template",
    default=None,
)
def create_pass(name: str, template: OptionalStr) -> None:
    """
    Helper command to create a new pass from a template. Templates 
    can be found in the template directory of the TasksCI tool.
    """

    # Checking whether the target already exists
    target_dir = os.path.join(SOURCE_DIR, "Source", name)
    if os.path.exists(target_dir):
        logger.error("Pass '{}' already exists".format(name))
        exit(-1)

    # In case no template was specified, we list the option
    # such that the user can choose one
    if template is None:

        # Listing options
        options = []
        print("Available templates:")
        print("")
        for template_name in os.listdir(TEMPLATE_DIR):
            if os.path.isdir(os.path.join(TEMPLATE_DIR, template_name)):
                options.append(template_name)

                # Printing option
                pretty_template_name = re.sub(r'(?<!^)(?=[A-Z])', ' ', template_name)
                print("{}. {}".format(len(options), pretty_template_name))

        # Getting a selection
        n = 0
        print("")
        print("Type 'q' or 'quit' to abort.")
        print("")
        while n < 1 or n > len(options) + 1:
            try:
                n = input("Select a template:")

                if n == "q" or n == "quit":
                    logger.info("User aborted.")
                    exit(0)

                n = int(n)
            except:  # noqa: E722
                logger.error("Invalid choice")
                exit(-1)

        # Getting the template
        template = options[n - 1]

    # Checking that the template is valid. Note that even though
    # we list the templates above, the user may have specified an
    # invalid template via the command line.
    template_dir = os.path.join(TEMPLATE_DIR, template)
    if not os.path.exists(template_dir):
        logger.error("Template does not exist")
        exit(-1)

    # Creating an operation name by transforming the original name
    # from "CamelCase" to "camel-case"
    operation_name = re.sub(r'(?<!^)(?=[A-Z])', '-', name).lower()
    logger.info(" ".join(["Creating", name, "in", target_dir]))
    os.makedirs(target_dir)

    # Copying template files one by one, substituting
    # values into the template
    for root, dirs, files in os.walk(template_dir):

        # Creating dirs
        for d in dirs:
            os.makedirs(os.path.join(target_dir, d))

        # Generating files
        for f in files:
            src = os.path.join(root, f)
            dest = os.path.join(target_dir, f).format(name=name)

            # Allow templates to end with .tpl to avoid autofomatting
            # by editors
            if dest.endswith(".tpl"):
                dest, _ = dest.rsplit(".", 1)

            # Getting the source contents
            with open(src, "r") as fb:
                contents = fb.read()

            # Replacing names in templates
            contents = contents.replace("{name}", name)
            contents = contents.replace("{operation_name}", operation_name)

            # Writing contents
            with open(dest, "w") as fb:
                fb.write(contents)

            logger.info("- Wrote {}".format(dest))


if __name__ == '__main__':
    cli()
