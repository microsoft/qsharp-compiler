# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

import logging
from .builder import configure_cmake, build_project
from . import toolchain
from .settings import PROJECT_ROOT
import os
import subprocess
import sys
from typing import Union

OptionalInt = Union[int, None]
OptionalStr = Union[str, None]

logger = logging.getLogger("Linter")


def clang_tidy_diagnose() -> None:
    """
    Helper function to print the configuration of Clang tidy
    """

    # Getting the config
    config = subprocess.check_output(
        [toolchain.discover_tidy(), '-dump-config'], cwd=PROJECT_ROOT).decode()

    # Getting the list of checks
    check_list = subprocess.check_output(
        [toolchain.discover_tidy(), '-list-checks'], cwd=PROJECT_ROOT).decode()

    # Printing it all to the user
    checks = [x.strip() for x in check_list.split("\n") if '-' in x]

    print("Working directory: {}".format(PROJECT_ROOT))
    print("")
    print(config)
    print("")
    print("Clang tidy checks:")

    for check in sorted(checks):
        print(" -", check)


def run_clang_tidy(build_dir: str, filename: str, fix_issues: bool = False) -> bool:
    """
    Function that runs Clang tidy for a single file given a build directory
    and a filename.
    """

    # Configuring the command line arguments
    clang_tidy_binary = toolchain.discover_tidy()

    cmd = [clang_tidy_binary]
    output_file = os.path.abspath(os.path.join(build_dir, 'clang_tidy_fixes.yaml'))

    cmd.append('-header-filter=".*\\/(Passes)\\/(Source)\\/.*"')
    cmd.append('-p=' + build_dir)
    cmd.append('-export-fixes={}'.format(output_file))
    cmd.append('--use-color')

    if fix_issues:
        cmd.append("-fix")

    cmd.append(filename)

    logger.info("Working dir '{}'".format(PROJECT_ROOT))
    logger.info("Running '{}'".format(" ".join(cmd)))

    # Getting the output
    p = subprocess.Popen(
        " ".join(cmd),
        stdout=subprocess.PIPE,
        stdin=subprocess.PIPE,
        stderr=subprocess.PIPE,
        cwd=PROJECT_ROOT,
        shell=True)

    output, err = p.communicate()

    output = output.decode()
    err = err.decode()

    logger.info(output)
    logger.info(err)

    if p.returncode != 0:

        # The return value is negative even if the user code is without
        # errors, so we check whether there are any errors specified in
        # error output
        if "error" in err:
            sys.stderr.write(output)
            sys.stderr.write(err)

            logger.error("{} failed static analysis".format(filename))
            return False

    logger.info("All good!")
    return True


def main_cpp(fix_issues: bool) -> bool:
    """
    Main function for C++ linting. This function builds and lints 
    the code.
    """

    logger.info("Linting")
    build_dir = os.path.join(PROJECT_ROOT, "Debug")
    source_dir = os.path.join(PROJECT_ROOT, "Source")
    generator = None
    extensions = ["cpp"]

    # Configuring CMake
    configure_cmake(build_dir, generator)

    # Building
    build_project(build_dir, generator)

    # Generating list of files
    # TODO(TFR): Ensure that it is only those which were changed that are
    # analysed
    files_to_analyse = []

    for root, dirs, files in os.walk(source_dir):
        for filename in files:
            if "." not in filename:
                continue

            _, ext = filename.rsplit(".", 1)
            if ext in extensions:
                files_to_analyse.append(os.path.join(root, filename))

    success = True
    for filename in files_to_analyse:
        success = success and run_clang_tidy(build_dir, filename, fix_issues=fix_issues)
    return success


def main(fix_issues: bool) -> None:
    if not main_cpp(fix_issues):
        sys.exit(-1)
