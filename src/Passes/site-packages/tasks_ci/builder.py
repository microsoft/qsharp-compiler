# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

import os
from . import settings
from . import toolchain
from .settings import PROJECT_ROOT
import logging
import subprocess
import sys
from typing import Union, List, Optional

OptionalInt = Optional[int]
OptionalStr = Union[str, None]


logger = logging.getLogger()


def configure_cmake(build_dir: str, generator=None,
                    cmake_flags: Optional[List[str]] = None) -> None:
    """
    Function that creates a build directory and runs
    cmake to configure make, ninja or another generator.
    """

    cmake_flags = cmake_flags or []

    logger.info("Source: {}".format(PROJECT_ROOT))
    logger.info("Build : {}".format(build_dir))

    os.chdir(PROJECT_ROOT)
    os.makedirs(build_dir, exist_ok=True)

    cmake_cmd = [toolchain.discover_cmake()]

    if generator is not None:
        cmake_cmd += ['-G', generator]

    cmake_cmd += [PROJECT_ROOT]
    cmake_cmd += cmake_flags

    exit_code = subprocess.call(cmake_cmd, cwd=build_dir)
    if exit_code != 0:
        logger.error('Failed to configure project')
        sys.exit(exit_code)


def build_project(build_dir: str, generator: OptionalStr = None,
                  concurrency: OptionalInt = None) -> None:
    """
    Given a build directory, this function builds all targets using
    a specified generator and concurrency.
    """

    if generator in ["make", None]:
        cmd = ["make"]
    elif generator == "ninja":
        cmd = ["ninja"]

    if concurrency is None:
        concurrency = settings.get_degree_of_concurrency()

    cmd.append('-j{}'.format(concurrency))

    exit_code = subprocess.call(cmd, cwd=build_dir)

    if exit_code != 0:
        logger.error('Failed to make the project')
        sys.exit(-1)


def run_tests(build_dir: str, concurrency: OptionalInt = None) -> None:
    """
    Runs the unit tests given a build directory.
    """
    fail = False

    # Lit is disabled for the time being
    # TODO(tfr): Consider whether lit should be moved back into the system
    if False:
        # Running lit tests
        lit_cmd = ["lit", "tests/", "-v"]
        exit_code = subprocess.call(lit_cmd, cwd=build_dir)

        if exit_code != 0:
            logger.error('Lit test failed')
            fail = True

    # Running CMake tests
    cmake_cmd = [toolchain.discover_ctest()]

    if concurrency is not None:
        raise BaseException("No support for concurrent testing at the moment.")

    exit_code = subprocess.call(cmake_cmd, cwd=build_dir)
    if exit_code != 0:
        logger.error('CTest failed project')

        # Getting output of failed
        cmake_cmd.append("--rerun-failed")
        cmake_cmd.append("--output-on-failure")
        subprocess.call(cmake_cmd, cwd=build_dir)

        fail = True

    if fail:
        sys.exit(exit_code)


def main(build_dir: str, generator: OptionalStr = None,
         test: bool = False, cmake_flags: List[str] = []) -> None:
    """
    Runs the entire build process by first configuring, the building
    and optionally testing the codebase.
    """

    configure_cmake(build_dir, generator, cmake_flags)

    build_project(build_dir, generator)

    if test:
        run_tests(build_dir)
